# Phase 2b: 실시간 협업 WebSocket 아키텍처 설계

**작성자**: Claude Opus 4.6 (설계/알고리즘 담당)
**작성일**: 2026-02-23
**상태**: 설계 완료 → Sonnet 구현 대기
**현재 완성도**: 35% → **목표: 100%**

---

## 1. 현황 분석

### 1.1 기존 구현 (35%)

| 기능 | 파일 | 상태 |
|------|------|------|
| SSE(Server-Sent Events) 연결 | `utils/realTimeSync.ts:178-206` | ✅ 구현 (WebSocket 아님) |
| 폴링 폴백 (2초 간격) | `utils/realTimeSync.ts:211-227` | ✅ 구현 |
| 오프라인 이벤트 큐 | `utils/realTimeSync.ts:90-94` | ✅ 구현 |
| 사용자 프레즌스 추적 | `collaboration/RealTimeCollaboration.tsx:425-483` | ✅ 구현 (Mock) |
| 커서 추적 (100ms 쓰로틀) | `collaboration/RealTimeCollaboration.tsx:540-565` | ✅ 구현 (Mock) |
| 채팅 시스템 | `collaboration/RealTimeCollaboration.tsx:681-720` | ✅ 구현 (Mock) |
| 30초 하트비트 | `utils/realTimeSync.ts:414-431` | ✅ 구현 |
| Mock 협업 서버 | `utils/realTimeSync.ts:643-701` | ✅ 개발/데모용 |

### 1.2 미구현 (65%)

| 기능 | 상태 |
|------|------|
| Django Channels WebSocket 서버 | ❌ 미구현 |
| 실제 WebSocket 클라이언트 연결 | ❌ 미구현 |
| 이벤트 소싱 패턴 (영속적 이벤트 로그) | ❌ 미구현 |
| 충돌 해결 메커니즘 (OT/CRDT) | ❌ 미구현 |
| 버전 히스토리 스냅샷 | ❌ 미구현 |
| 세션 복구 (재연결) | ❌ 미구현 |
| 실시간 평가 진행 동기화 | ❌ 미구현 |

---

## 2. 아키텍처 설계

### 2.1 전체 구조

```
┌──────────────────────────────────────────────────────┐
│                  React Frontend                       │
│                                                      │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────┐  │
│  │ useWebSocket │  │ usePresence  │  │ useChat    │  │
│  │    Hook      │  │    Hook      │  │   Hook     │  │
│  └──────┬───────┘  └──────┬───────┘  └─────┬──────┘  │
│         │                 │                │          │
│  ┌──────▼─────────────────▼────────────────▼──────┐  │
│  │          WebSocketManager (Singleton)           │  │
│  │  - 연결 관리, 재연결, 하트비트, 이벤트 라우팅   │  │
│  └──────────────────────┬─────────────────────────┘  │
│                         │ ws://                       │
└─────────────────────────┼────────────────────────────┘
                          │
              ┌───────────▼───────────┐
              │   Nginx / Reverse     │
              │   Proxy (ws:// → wss:)│
              └───────────┬───────────┘
                          │
┌─────────────────────────▼────────────────────────────┐
│                Django Backend (ASGI)                   │
│                                                      │
│  ┌──────────────────────────────────────────────┐    │
│  │          Django Channels                      │    │
│  │                                              │    │
│  │  ┌────────────┐  ┌─────────────┐  ┌───────┐ │    │
│  │  │ Project    │  │ Evaluation  │  │ Chat  │ │    │
│  │  │ Consumer   │  │ Consumer    │  │Consumer│ │    │
│  │  └──────┬─────┘  └──────┬──────┘  └───┬───┘ │    │
│  │         │               │              │     │    │
│  │  ┌──────▼───────────────▼──────────────▼──┐  │    │
│  │  │         Channel Layer (Redis)          │  │    │
│  │  └────────────────────────────────────────┘  │    │
│  └──────────────────────────────────────────────┘    │
│                                                      │
│  ┌──────────────────────────────────────────────┐    │
│  │         이벤트 스토어 (PostgreSQL)             │    │
│  │  - 모든 이벤트 영속 저장                       │    │
│  │  - 버전 히스토리 조회                          │    │
│  └──────────────────────────────────────────────┘    │
└──────────────────────────────────────────────────────┘
```

### 2.2 WebSocket 채널 구조

```
                    ws://host/ws/
                         │
         ┌───────────────┼───────────────┐
         │               │               │
    /ws/project/     /ws/evaluation/   /ws/chat/
     {project_id}/    {project_id}/    {project_id}/
         │               │               │
   ┌─────┴─────┐   ┌────┴────┐    ┌────┴────┐
   │ 모델 편집  │   │ 평가 진행│    │ 메시지  │
   │ 기준 변경  │   │ 비교 저장│    │ 타이핑  │
   │ 대안 변경  │   │ 진행률  │    │ 멘션    │
   │ 가중치    │   │ 일관성  │    │         │
   └───────────┘   └─────────┘    └─────────┘
```

---

## 3. Django Channels 설계

### 3.1 ASGI 설정

```python
# backend: config/asgi.py

import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
from channels.security.websocket import AllowedHostsOriginValidator
from evaluations.middleware import InvitationTokenAuthMiddleware

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = ProtocolTypeRouter({
    'http': get_asgi_application(),
    'websocket': AllowedHostsOriginValidator(
        InvitationTokenAuthMiddleware(
            AuthMiddlewareStack(
                URLRouter([
                    # routing은 evaluations/routing.py에서 정의
                ])
            )
        )
    ),
})
```

### 3.2 WebSocket Routing

```python
# backend: evaluations/routing.py

from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/project/(?P<project_id>\d+)/$',
            consumers.ProjectConsumer.as_asgi()),
    re_path(r'ws/evaluation/(?P<project_id>\d+)/$',
            consumers.EvaluationConsumer.as_asgi()),
    re_path(r'ws/chat/(?P<project_id>\d+)/$',
            consumers.ChatConsumer.as_asgi()),
]
```

### 3.3 Project Consumer (핵심)

```python
# backend: evaluations/consumers/project_consumer.py

import json
from channels.generic.websocket import AsyncJsonWebsocketConsumer
from channels.db import database_sync_to_async
from django.utils import timezone

class ProjectConsumer(AsyncJsonWebsocketConsumer):
    """프로젝트 모델 편집 실시간 동기화"""

    async def connect(self):
        self.project_id = self.scope['url_route']['kwargs']['project_id']
        self.group_name = f'project_{self.project_id}'
        self.user = self.scope.get('user')
        self.user_id = str(self.user.id) if self.user else 'anonymous'

        # 그룹 참가
        await self.channel_layer.group_add(self.group_name, self.channel_name)
        await self.accept()

        # 프레즌스 브로드캐스트
        await self.broadcast_presence('join')

        # 현재 접속자 목록 전송
        active_users = await self.get_active_users()
        await self.send_json({
            'type': 'presence.snapshot',
            'users': active_users,
            'server_time': timezone.now().isoformat(),
        })

    async def disconnect(self, close_code):
        await self.broadcast_presence('leave')
        await self.remove_user_presence()
        await self.channel_layer.group_discard(self.group_name, self.channel_name)

    async def receive_json(self, content):
        """클라이언트 메시지 수신 및 라우팅"""
        msg_type = content.get('type')

        handlers = {
            'model.update':       self.handle_model_update,
            'cursor.move':        self.handle_cursor_move,
            'presence.heartbeat': self.handle_heartbeat,
            'lock.acquire':       self.handle_lock_acquire,
            'lock.release':       self.handle_lock_release,
        }

        handler = handlers.get(msg_type)
        if handler:
            await handler(content)

    # === 모델 업데이트 ===

    async def handle_model_update(self, content):
        """기준/대안/가중치 변경 처리"""
        event = {
            'entity_type': content['entity_type'],  # 'criterion' | 'alternative' | 'weight'
            'action': content['action'],             # 'create' | 'update' | 'delete'
            'entity_id': content['entity_id'],
            'data': content.get('data', {}),
            'version': content.get('version', 0),
        }

        # 충돌 감지
        conflict = await self.detect_conflict(event)
        if conflict:
            await self.send_json({
                'type': 'conflict.detected',
                'conflict': conflict,
                'your_event': event,
                'server_version': conflict['server_version'],
            })
            return

        # 이벤트 영속 저장
        saved_event = await self.persist_event(event)

        # 다른 사용자에게 브로드캐스트
        await self.channel_layer.group_send(self.group_name, {
            'type': 'model_update_broadcast',
            'event': saved_event,
            'sender': self.user_id,
        })

    async def model_update_broadcast(self, event):
        """그룹 내 다른 사용자에게 전달"""
        if event['sender'] != self.user_id:
            await self.send_json({
                'type': 'model.updated',
                'event': event['event'],
                'sender': event['sender'],
            })

    # === 커서 추적 ===

    async def handle_cursor_move(self, content):
        await self.channel_layer.group_send(self.group_name, {
            'type': 'cursor_broadcast',
            'user_id': self.user_id,
            'user_name': content.get('user_name', ''),
            'position': content.get('position', {}),
            'color': content.get('color', '#3B82F6'),
        })

    async def cursor_broadcast(self, event):
        if event['user_id'] != self.user_id:
            await self.send_json({
                'type': 'cursor.moved',
                'user_id': event['user_id'],
                'user_name': event['user_name'],
                'position': event['position'],
                'color': event['color'],
            })

    # === 잠금(Lock) 메커니즘 ===

    async def handle_lock_acquire(self, content):
        """특정 엔티티 편집 잠금 요청"""
        entity_key = f"{content['entity_type']}:{content['entity_id']}"
        acquired = await self.try_acquire_lock(entity_key)

        if acquired:
            await self.channel_layer.group_send(self.group_name, {
                'type': 'lock_acquired_broadcast',
                'entity_key': entity_key,
                'locked_by': self.user_id,
                'locked_by_name': content.get('user_name', ''),
            })
        else:
            lock_info = await self.get_lock_info(entity_key)
            await self.send_json({
                'type': 'lock.denied',
                'entity_key': entity_key,
                'locked_by': lock_info['user_id'],
                'locked_by_name': lock_info['user_name'],
            })

    async def lock_acquired_broadcast(self, event):
        await self.send_json({
            'type': 'lock.acquired',
            'entity_key': event['entity_key'],
            'locked_by': event['locked_by'],
            'locked_by_name': event['locked_by_name'],
        })

    async def handle_lock_release(self, content):
        entity_key = f"{content['entity_type']}:{content['entity_id']}"
        await self.release_lock(entity_key)
        await self.channel_layer.group_send(self.group_name, {
            'type': 'lock_released_broadcast',
            'entity_key': entity_key,
        })

    async def lock_released_broadcast(self, event):
        await self.send_json({
            'type': 'lock.released',
            'entity_key': event['entity_key'],
        })

    # === 충돌 감지 ===

    @database_sync_to_async
    def detect_conflict(self, event):
        """낙관적 동시성 제어: 버전 비교"""
        from .models import ProjectEvent
        latest = ProjectEvent.objects.filter(
            project_id=self.project_id,
            entity_type=event['entity_type'],
            entity_id=event['entity_id'],
        ).order_by('-version').first()

        if latest and latest.version >= event['version']:
            return {
                'server_version': latest.version,
                'server_data': latest.data,
                'server_user': latest.user_id,
                'server_timestamp': latest.timestamp.isoformat(),
            }
        return None

    @database_sync_to_async
    def persist_event(self, event):
        """이벤트를 DB에 영속 저장"""
        from .models import ProjectEvent
        saved = ProjectEvent.objects.create(
            project_id=self.project_id,
            user_id=self.user_id,
            entity_type=event['entity_type'],
            action=event['action'],
            entity_id=event['entity_id'],
            data=event.get('data', {}),
            version=event.get('version', 0) + 1,
        )
        return {
            'event_id': str(saved.id),
            'version': saved.version,
            'timestamp': saved.timestamp.isoformat(),
            **event,
        }

    # === 프레즌스 & 하트비트 ===

    async def broadcast_presence(self, action):
        await self.update_user_presence(action)
        await self.channel_layer.group_send(self.group_name, {
            'type': 'presence_broadcast',
            'user_id': self.user_id,
            'action': action,  # 'join' | 'leave'
        })

    async def presence_broadcast(self, event):
        await self.send_json({
            'type': f"presence.{event['action']}",
            'user_id': event['user_id'],
        })

    async def handle_heartbeat(self, content):
        await self.update_user_presence('heartbeat')

    # === Redis 기반 프레즌스 (헬퍼) ===

    @database_sync_to_async
    def get_active_users(self):
        from django.core.cache import cache
        key = f'presence:{self.project_id}'
        return cache.get(key, {})

    @database_sync_to_async
    def update_user_presence(self, action):
        from django.core.cache import cache
        key = f'presence:{self.project_id}'
        users = cache.get(key, {})
        if action == 'leave':
            users.pop(self.user_id, None)
        else:
            users[self.user_id] = {
                'last_seen': timezone.now().isoformat(),
                'action': action,
            }
        cache.set(key, users, timeout=120)  # 2분 TTL

    @database_sync_to_async
    def remove_user_presence(self):
        from django.core.cache import cache
        key = f'presence:{self.project_id}'
        users = cache.get(key, {})
        users.pop(self.user_id, None)
        cache.set(key, users, timeout=120)

    # === Lock 관리 (Redis) ===

    @database_sync_to_async
    def try_acquire_lock(self, entity_key):
        from django.core.cache import cache
        lock_key = f'lock:{self.project_id}:{entity_key}'
        return cache.add(lock_key, {
            'user_id': self.user_id,
            'acquired_at': timezone.now().isoformat(),
        }, timeout=60)  # 60초 자동 해제

    @database_sync_to_async
    def release_lock(self, entity_key):
        from django.core.cache import cache
        lock_key = f'lock:{self.project_id}:{entity_key}'
        lock_info = cache.get(lock_key)
        if lock_info and lock_info['user_id'] == self.user_id:
            cache.delete(lock_key)

    @database_sync_to_async
    def get_lock_info(self, entity_key):
        from django.core.cache import cache
        lock_key = f'lock:{self.project_id}:{entity_key}'
        return cache.get(lock_key, {})
```

### 3.4 Evaluation Consumer

```python
# backend: evaluations/consumers/evaluation_consumer.py

class EvaluationConsumer(AsyncJsonWebsocketConsumer):
    """평가 진행 상황 실시간 동기화"""

    async def connect(self):
        self.project_id = self.scope['url_route']['kwargs']['project_id']
        self.group_name = f'evaluation_{self.project_id}'
        await self.channel_layer.group_add(self.group_name, self.channel_name)
        await self.accept()

    async def receive_json(self, content):
        msg_type = content.get('type')

        if msg_type == 'comparison.saved':
            # 쌍대비교 저장 시 진행률 브로드캐스트
            await self.channel_layer.group_send(self.group_name, {
                'type': 'progress_update',
                'evaluator_id': content['evaluator_id'],
                'evaluator_name': content.get('evaluator_name', ''),
                'progress': content['progress'],         # 0~100
                'comparisons_done': content['comparisons_done'],
                'comparisons_total': content['comparisons_total'],
            })

        elif msg_type == 'evaluation.completed':
            # 평가 완료 시
            await self.channel_layer.group_send(self.group_name, {
                'type': 'evaluation_completed',
                'evaluator_id': content['evaluator_id'],
                'consistency_ratio': content.get('consistency_ratio'),
            })

    async def progress_update(self, event):
        await self.send_json({
            'type': 'evaluation.progress',
            **{k: v for k, v in event.items() if k != 'type'},
        })

    async def evaluation_completed(self, event):
        await self.send_json({
            'type': 'evaluation.completed',
            **{k: v for k, v in event.items() if k != 'type'},
        })
```

### 3.5 이벤트 스토어 모델

```python
# backend: evaluations/models/event_store.py

class ProjectEvent(models.Model):
    """이벤트 소싱: 모든 프로젝트 변경 이력"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    project = models.ForeignKey('projects.Project', on_delete=models.CASCADE,
                                related_name='events')
    user_id = models.CharField(max_length=100)

    entity_type = models.CharField(max_length=50)   # criterion, alternative, weight, ...
    entity_id = models.CharField(max_length=100)
    action = models.CharField(max_length=20)         # create, update, delete
    data = models.JSONField(default=dict)
    version = models.PositiveIntegerField()

    timestamp = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['timestamp']
        indexes = [
            models.Index(fields=['project', 'entity_type', 'entity_id']),
            models.Index(fields=['project', 'timestamp']),
            models.Index(fields=['project', 'version']),
        ]
        unique_together = [('project', 'entity_type', 'entity_id', 'version')]
```

---

## 4. React 프론트엔드 설계

### 4.1 WebSocketManager (싱글톤)

```typescript
// src/services/webSocketManager.ts

type MessageHandler = (data: any) => void;
type ConnectionState = 'connecting' | 'connected' | 'disconnected' | 'reconnecting';

interface WebSocketConfig {
  url: string;
  token?: string;             // JWT 또는 invitation token
  reconnectAttempts?: number;  // 기본 5
  reconnectDelay?: number;     // 기본 1000ms
  heartbeatInterval?: number;  // 기본 30000ms
}

class WebSocketManager {
  private static instances = new Map<string, WebSocketManager>();
  private ws: WebSocket | null = null;
  private handlers = new Map<string, Set<MessageHandler>>();
  private state: ConnectionState = 'disconnected';
  private reconnectCount = 0;
  private heartbeatTimer: ReturnType<typeof setInterval> | null = null;
  private offlineQueue: any[] = [];
  private config: Required<WebSocketConfig>;

  private constructor(config: WebSocketConfig) {
    this.config = {
      reconnectAttempts: 5,
      reconnectDelay: 1000,
      heartbeatInterval: 30000,
      token: '',
      ...config,
    };
  }

  static getInstance(channel: string, config: WebSocketConfig): WebSocketManager {
    if (!this.instances.has(channel)) {
      this.instances.set(channel, new WebSocketManager(config));
    }
    return this.instances.get(channel)!;
  }

  static removeInstance(channel: string): void {
    const instance = this.instances.get(channel);
    if (instance) {
      instance.disconnect();
      this.instances.delete(channel);
    }
  }

  connect(): void {
    if (this.state === 'connected' || this.state === 'connecting') return;
    this.state = 'connecting';
    this.emit('connection.state', { state: this.state });

    const url = this.config.token
      ? `${this.config.url}?token=${this.config.token}`
      : this.config.url;

    this.ws = new WebSocket(url);

    this.ws.onopen = () => {
      this.state = 'connected';
      this.reconnectCount = 0;
      this.emit('connection.state', { state: this.state });
      this.startHeartbeat();
      this.flushOfflineQueue();
    };

    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.emit(data.type, data);
      } catch {
        // non-JSON 메시지 무시
      }
    };

    this.ws.onclose = (event) => {
      this.state = 'disconnected';
      this.stopHeartbeat();
      this.emit('connection.state', { state: this.state, code: event.code });

      if (!event.wasClean && this.reconnectCount < this.config.reconnectAttempts) {
        this.scheduleReconnect();
      }
    };

    this.ws.onerror = () => {
      // onclose가 뒤이어 호출되므로 여기서는 상태만 기록
      this.emit('connection.error', { reconnectCount: this.reconnectCount });
    };
  }

  disconnect(): void {
    this.stopHeartbeat();
    if (this.ws) {
      this.ws.close(1000, 'Client disconnect');
      this.ws = null;
    }
    this.state = 'disconnected';
  }

  send(type: string, data: any): void {
    const message = { type, ...data, timestamp: new Date().toISOString() };

    if (this.state === 'connected' && this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    } else {
      // 오프라인 큐에 저장
      this.offlineQueue.push(message);
    }
  }

  on(type: string, handler: MessageHandler): () => void {
    if (!this.handlers.has(type)) {
      this.handlers.set(type, new Set());
    }
    this.handlers.get(type)!.add(handler);
    return () => this.handlers.get(type)?.delete(handler);
  }

  private emit(type: string, data: any): void {
    this.handlers.get(type)?.forEach(handler => handler(data));
    this.handlers.get('*')?.forEach(handler => handler({ type, ...data }));
  }

  private scheduleReconnect(): void {
    this.state = 'reconnecting';
    this.reconnectCount++;
    const delay = this.config.reconnectDelay * Math.pow(2, this.reconnectCount - 1);
    this.emit('connection.state', {
      state: this.state,
      attempt: this.reconnectCount,
      nextRetryMs: delay,
    });
    setTimeout(() => this.connect(), delay);
  }

  private startHeartbeat(): void {
    this.heartbeatTimer = setInterval(() => {
      this.send('presence.heartbeat', {});
    }, this.config.heartbeatInterval);
  }

  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }

  private flushOfflineQueue(): void {
    while (this.offlineQueue.length > 0) {
      const message = this.offlineQueue.shift();
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify(message));
      }
    }
  }

  getState(): ConnectionState { return this.state; }
}

export default WebSocketManager;
```

### 4.2 React Hooks

#### useWebSocket

```typescript
// src/hooks/useWebSocket.ts

import { useEffect, useRef, useCallback, useState } from 'react';
import WebSocketManager from '../services/webSocketManager';

interface UseWebSocketOptions {
  channel: string;     // 'project' | 'evaluation' | 'chat'
  projectId: number;
  token?: string;
  enabled?: boolean;   // 기본 true
}

export function useWebSocket({ channel, projectId, token, enabled = true }: UseWebSocketOptions) {
  const [connectionState, setConnectionState] = useState<string>('disconnected');
  const managerRef = useRef<WebSocketManager | null>(null);
  const cleanupFns = useRef<Array<() => void>>([]);

  useEffect(() => {
    if (!enabled || !projectId) return;

    const wsUrl = `${getWebSocketBaseUrl()}/ws/${channel}/${projectId}/`;
    const manager = WebSocketManager.getInstance(
      `${channel}_${projectId}`,
      { url: wsUrl, token }
    );
    managerRef.current = manager;

    const unsub = manager.on('connection.state', (data) => {
      setConnectionState(data.state);
    });
    cleanupFns.current.push(unsub);

    manager.connect();

    return () => {
      cleanupFns.current.forEach(fn => fn());
      cleanupFns.current = [];
      WebSocketManager.removeInstance(`${channel}_${projectId}`);
    };
  }, [channel, projectId, token, enabled]);

  const send = useCallback((type: string, data: any) => {
    managerRef.current?.send(type, data);
  }, []);

  const subscribe = useCallback((type: string, handler: (data: any) => void) => {
    const unsub = managerRef.current?.on(type, handler);
    if (unsub) cleanupFns.current.push(unsub);
    return unsub;
  }, []);

  return { connectionState, send, subscribe };
}

function getWebSocketBaseUrl(): string {
  const apiUrl = process.env.REACT_APP_API_URL || 'https://ahp-django-backend.onrender.com';
  return apiUrl.replace(/^http/, 'ws');
}
```

#### usePresence

```typescript
// src/hooks/usePresence.ts

import { useState, useEffect, useCallback, useRef } from 'react';
import { useWebSocket } from './useWebSocket';

interface ActiveUser {
  id: string;
  name: string;
  color: string;
  cursor?: { x: number; y: number; element?: string };
  lastSeen: string;
}

export function usePresence(projectId: number, currentUser: { id: string; name: string }) {
  const [activeUsers, setActiveUsers] = useState<ActiveUser[]>([]);
  const { connectionState, send, subscribe } = useWebSocket({
    channel: 'project',
    projectId,
  });
  const cursorThrottleRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    if (!subscribe) return;

    subscribe('presence.snapshot', (data) => {
      setActiveUsers(Object.entries(data.users).map(([id, info]: [string, any]) => ({
        id,
        name: info.name || id,
        color: info.color || assignColor(id),
        lastSeen: info.last_seen,
      })));
    });

    subscribe('presence.join', (data) => {
      setActiveUsers(prev => {
        if (prev.find(u => u.id === data.user_id)) return prev;
        return [...prev, { id: data.user_id, name: data.user_name, color: assignColor(data.user_id), lastSeen: new Date().toISOString() }];
      });
    });

    subscribe('presence.leave', (data) => {
      setActiveUsers(prev => prev.filter(u => u.id !== data.user_id));
    });

    subscribe('cursor.moved', (data) => {
      setActiveUsers(prev => prev.map(u =>
        u.id === data.user_id ? { ...u, cursor: data.position } : u
      ));
    });
  }, [subscribe]);

  const updateCursor = useCallback((position: { x: number; y: number; element?: string }) => {
    // 100ms 쓰로틀
    if (cursorThrottleRef.current) return;
    cursorThrottleRef.current = setTimeout(() => {
      cursorThrottleRef.current = null;
    }, 100);

    send('cursor.move', {
      user_name: currentUser.name,
      position,
      color: assignColor(currentUser.id),
    });
  }, [send, currentUser]);

  return { activeUsers, connectionState, updateCursor };
}

const COLORS = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', '#EC4899', '#06B6D4', '#F97316'];
function assignColor(userId: string): string {
  let hash = 0;
  for (let i = 0; i < userId.length; i++) hash = ((hash << 5) - hash) + userId.charCodeAt(i);
  return COLORS[Math.abs(hash) % COLORS.length];
}
```

---

## 5. 충돌 해결 메커니즘

### 5.1 전략: 낙관적 동시성 제어 + Entity Locking

AHP 프로젝트 특성상 완전한 CRDT/OT가 필요하지 않음. 대신:

```
1. 편집 시작 → Lock 요청 (soft lock, 60초 TTL)
2. Lock 획득 → 편집 가능
3. Lock 거부 → "다른 사용자가 편집 중" 표시
4. 저장 시 → 버전 비교 (낙관적 동시성)
5. 버전 충돌 → 사용자에게 선택지 제공
```

### 5.2 충돌 해결 UI 흐름

```
충돌 감지 시:

┌────────────────────────────────────────────┐
│  ⚠ 편집 충돌 감지                           │
│                                            │
│  [김관리자]님이 같은 기준을 수정했습니다.     │
│  수정 시각: 2분 전                           │
│                                            │
│  ┌──────────────┐  ┌──────────────────────┐│
│  │ 내 변경사항   │  │ 서버 변경사항          ││
│  │              │  │                      ││
│  │ 이름: 경제성  │  │ 이름: 경제적 효율성    ││
│  │ 가중치: 0.35  │  │ 가중치: 0.30          ││
│  └──────────────┘  └──────────────────────┘│
│                                            │
│  [내 변경 유지]  [서버 버전 사용]  [병합하기]  │
└────────────────────────────────────────────┘
```

### 5.3 충돌 해결 타입 정의

```typescript
// src/types/collaboration.ts

interface ConflictResolution {
  type: 'keep_mine' | 'keep_server' | 'merge';
  mergedData?: any;   // 'merge' 선택 시 사용자가 편집한 데이터
}

interface ConflictInfo {
  entity_type: string;
  entity_id: string;
  my_version: number;
  server_version: number;
  my_data: any;
  server_data: any;
  server_user: string;
  server_timestamp: string;
}
```

---

## 6. 배포 고려사항

### 6.1 Render.com에서 WebSocket 지원

현재 백엔드가 Render.com에 배포되어 있으므로:

```yaml
# render.yaml (Web Service 설정)
services:
  - type: web
    name: ahp-django-backend
    runtime: python
    plan: starter  # WebSocket 지원 필수 (무료 플랜도 지원)
    buildCommand: pip install -r requirements.txt
    startCommand: daphne -b 0.0.0.0 -p $PORT config.asgi:application
    envVars:
      - key: REDIS_URL
        fromService:
          name: ahp-redis
          type: redis
          property: connectionString

  - type: redis
    name: ahp-redis
    plan: starter  # Channel Layer용
```

### 6.2 필수 의존성

```
# requirements.txt 추가
channels==4.0.0
channels-redis==4.1.0
daphne==4.0.0
redis==5.0.0
```

### 6.3 Fallback 전략

WebSocket 연결 실패 시 기존 SSE/폴링으로 자동 폴백:

```typescript
// 연결 우선순위:
// 1. WebSocket (ws://)
// 2. SSE (EventSource)
// 3. HTTP 폴링 (2초 간격)
```

---

## 7. 구현 가이드 (Sonnet용)

### 7.1 구현 순서

```
Step 1: WebSocketManager 싱글톤 (1시간)
├── src/services/webSocketManager.ts 생성

Step 2: React Hooks (2시간)
├── src/hooks/useWebSocket.ts
├── src/hooks/usePresence.ts
└── src/hooks/useCollaboration.ts (모델 동기화용)

Step 3: 기존 RealTimeCollaboration 리팩토링 (2시간)
├── Mock 제거 → 실제 WebSocket 연결
├── 커서 추적 → usePresence Hook 사용
└── 채팅 → useWebSocket 기반으로 전환

Step 4: 충돌 해결 UI (1시간)
├── ConflictResolutionModal 컴포넌트 생성
└── 잠금 상태 표시 UI

Step 5: Django Channels 백엔드 (별도 작업)
├── config/asgi.py
├── evaluations/routing.py
├── evaluations/consumers/project_consumer.py
├── evaluations/consumers/evaluation_consumer.py
├── evaluations/consumers/chat_consumer.py
├── evaluations/models/event_store.py
└── Redis 설정
```

### 7.2 주의사항

1. **Mock 코드 삭제하지 말 것** — `MockCollaborationServer`는 개발/데모용으로 유지
2. **폴백 유지** — WebSocket 실패 시 기존 SSE/폴링 자동 전환
3. **GitHub Pages 제약** — 프론트엔드는 정적 호스팅, WebSocket은 백엔드(Render.com)에서 처리
4. **Render.com 유료 플랜** — Redis 사용을 위해 Starter 이상 필요
5. **기존 realTimeSync.ts 보존** — 새 WebSocketManager와 병행 운용 후 점진적 교체
