# Phase 2c: 고급 분석 알고리즘 설계

**작성자**: Claude Opus 4.6 (설계/알고리즘 담당)
**작성일**: 2026-02-23
**상태**: 설계 완료 → Sonnet 구현 대기
**현재 완성도**: 30% → **목표: 100%**

---

## 1. 현황 분석

### 1.1 기존 구현 (30%)

| 알고리즘 | 파일 | 상태 |
|---------|------|------|
| 고유벡터법 (기하평균 + 거듭제곱법) | `utils/ahpCalculator.ts` | ✅ 완전 구현 |
| 일관성 비율(CR) 계산 | `utils/ahpCalculator.ts:146-153` | ✅ 완전 구현 |
| 계층적 AHP 최종 점수 | `utils/ahpCalculator.ts:176-213` | ✅ 완전 구현 |
| 그룹 AHP (기하/산술/가중 평균) | `utils/ahpCalculator.ts:334-388` | ✅ 완전 구현 |
| 합의 지수 (Consensus Index) | `utils/ahpCalculator.ts:304-329` | ✅ 완전 구현 |
| Fuzzy AHP (Chang 확장 분석) | `utils/fuzzyCalculations.ts:106-154` | ✅ 완전 구현 |
| 비퍼지화 5가지 방법 | `utils/fuzzyCalculations.ts:71-101` | ✅ 완전 구현 |
| 시나리오 분석 (What-If) | `utils/scenarioAnalysis.ts:328-387` | ✅ 완전 구현 |
| 기본 Monte Carlo | `utils/scenarioAnalysis.ts:174-275` | ✅ 기본 구현 |
| 기본 민감도 분석 | `utils/scenarioAnalysis.ts:120-169` | ✅ 기본 구현 |

### 1.2 미구현/고도화 필요 (70%)

| 알고리즘 | 현재 | 필요 |
|---------|------|------|
| Monte Carlo — 분포 선택 | 균일 랜덤(±15%) | 정규/삼각/베타 분포 |
| Monte Carlo — 수렴 판정 | 고정 1000회 | 적응형 수렴 기준 |
| 민감도 — Tornado 차트 데이터 | UI 정의만 | 알고리즘 완전 구현 |
| 민감도 — 순위 역전점 정밀 탐색 | 미구현 | 이분법 탐색 |
| 그룹 합의 — AIJ/AIP | 기하평균만 | AIJ/AIP 완전 구현 |
| 그룹 합의 — Fuzzy 합의 | 미구현 | Fuzzy 집계 |
| 그룹 합의 — Shannon Entropy | 미구현 | 정보 엔트로피 합의도 |
| Pareto 최적 프론티어 | 타입만 정의 | 지배 관계 탐지 |
| 강건성(Robustness) 분석 | 미구현 | 순위 안정성 종합 지표 |
| PDF/Excel 리포트 내보내기 | Stub | 완전 구현 |

---

## 2. Monte Carlo 시뮬레이션 고도화

### 2.1 개선 아키텍처

```
입력: 쌍대비교 행렬 + 불확실성 파라미터
                    │
        ┌───────────▼───────────┐
        │  분포 샘플링 엔진      │
        │  - 정규 분포           │
        │  - 삼각 분포           │
        │  - 베타 분포           │
        │  - 균일 분포           │
        └───────────┬───────────┘
                    │ (N회 반복)
        ┌───────────▼───────────┐
        │  AHP 계산 엔진        │
        │  - 가중치 계산         │
        │  - 일관성 검사         │
        │  - 최종 순위 계산      │
        └───────────┬───────────┘
                    │
        ┌───────────▼───────────┐
        │  통계 분석 엔진        │
        │  - 평균/표준편차       │
        │  - 신뢰구간 (95%)     │
        │  - 순위 확률 분포      │
        │  - 수렴 판정           │
        └───────────┬───────────┘
                    │
        출력: MonteCarloResult
```

### 2.2 알고리즘 상세

```typescript
// src/utils/advancedMonteCarlo.ts

interface MonteCarloConfig {
  iterations: number;               // 기본 10000
  uncertaintyLevel: number;          // 0.05 ~ 0.30 (기본 0.15)
  distribution: 'normal' | 'triangular' | 'beta' | 'uniform';
  convergenceTolerance: number;      // 수렴 판정 기준 (기본 0.001)
  convergenceWindow: number;         // 수렴 체크 윈도우 (기본 500)
  seed?: number;                     // 재현성을 위한 시드
}

interface MonteCarloResult {
  // 대안별 통계
  alternatives: Array<{
    id: string;
    name: string;
    meanWeight: number;
    stdDev: number;
    confidenceInterval: { lower: number; upper: number };  // 95% CI
    rankProbabilities: number[];  // [1위 확률, 2위 확률, ...]
    mostProbableRank: number;
  }>;

  // 기준별 가중치 안정성
  criteria: Array<{
    id: string;
    name: string;
    meanWeight: number;
    stdDev: number;
    coefficientOfVariation: number;  // CV = σ/μ
  }>;

  // 전체 통계
  summary: {
    totalIterations: number;
    validIterations: number;      // CR < 0.1 충족 비율
    convergenceReached: boolean;
    convergenceIteration: number; // 수렴까지 걸린 반복 횟수
    rankStability: number;        // 0~1, 1이 가장 안정
    dominantAlternative: string;  // 1위 확률 최고 대안
    dominantProbability: number;  // 1위 달성 확률
  };
}

class AdvancedMonteCarloSimulation {

  /**
   * 시뮬레이션 실행
   */
  static run(
    comparisonMatrix: number[][],
    criteria: { id: string; name: string }[],
    alternatives: { id: string; name: string }[],
    alternativeScores: number[][],  // [대안][기준] 점수
    config: MonteCarloConfig
  ): MonteCarloResult {

    const n = criteria.length;
    const m = alternatives.length;
    const results: Array<{ weights: number[]; scores: number[]; ranks: number[] }> = [];

    let converged = false;
    let convergenceIteration = config.iterations;

    for (let iter = 0; iter < config.iterations; iter++) {
      // 1. 비교 행렬에 노이즈 추가
      const noisyMatrix = this.addNoise(comparisonMatrix, config);

      // 2. 가중치 계산
      const weights = this.calculateEigenWeights(noisyMatrix);

      // 3. 일관성 검사 (비일관적이면 스킵)
      const cr = this.calculateCR(noisyMatrix, weights);
      if (cr > 0.1) continue;

      // 4. 대안 점수에도 노이즈 추가
      const noisyScores = alternativeScores.map(row =>
        row.map(score => this.applyNoise(score, config))
      );

      // 5. 최종 점수 계산
      const finalScores = this.calculateFinalScores(weights, noisyScores);

      // 6. 순위 결정
      const ranks = this.calculateRanks(finalScores);

      results.push({ weights, scores: finalScores, ranks });

      // 7. 수렴 판정 (매 window마다)
      if (iter > 0 && iter % config.convergenceWindow === 0) {
        converged = this.checkConvergence(results, config.convergenceTolerance);
        if (converged) {
          convergenceIteration = iter;
          break;
        }
      }
    }

    return this.aggregateResults(results, criteria, alternatives, config, converged, convergenceIteration);
  }

  /**
   * 분포별 노이즈 생성
   */
  private static addNoise(matrix: number[][], config: MonteCarloConfig): number[][] {
    const n = matrix.length;
    const noisy = matrix.map(row => [...row]);

    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const original = matrix[i][j];
        const logOriginal = Math.log(original);

        let perturbation: number;
        switch (config.distribution) {
          case 'normal':
            perturbation = this.normalRandom(0, config.uncertaintyLevel);
            break;
          case 'triangular':
            perturbation = this.triangularRandom(
              -config.uncertaintyLevel, 0, config.uncertaintyLevel
            );
            break;
          case 'beta':
            // Beta(2,2) — 중앙 집중, ±uncertainty 범위 조정
            perturbation = (this.betaRandom(2, 2) - 0.5) * 2 * config.uncertaintyLevel;
            break;
          case 'uniform':
          default:
            perturbation = (Math.random() - 0.5) * 2 * config.uncertaintyLevel;
        }

        // 로그 스케일에서 노이즈 적용 (1~9 범위 유지)
        const noisyLog = logOriginal + perturbation;
        const noisyValue = Math.max(1/9, Math.min(9, Math.exp(noisyLog)));

        noisy[i][j] = noisyValue;
        noisy[j][i] = 1 / noisyValue;  // 역수 관계 유지
      }
    }
    return noisy;
  }

  /**
   * 수렴 판정: 최근 window의 평균 가중치 변동이 tolerance 이하
   */
  private static checkConvergence(
    results: Array<{ weights: number[] }>,
    tolerance: number
  ): boolean {
    const recent = results.slice(-500);
    const earlier = results.slice(-1000, -500);

    if (earlier.length < 100) return false;

    const n = recent[0].weights.length;
    let maxDiff = 0;

    for (let i = 0; i < n; i++) {
      const recentMean = recent.reduce((s, r) => s + r.weights[i], 0) / recent.length;
      const earlierMean = earlier.reduce((s, r) => s + r.weights[i], 0) / earlier.length;
      maxDiff = Math.max(maxDiff, Math.abs(recentMean - earlierMean));
    }

    return maxDiff < tolerance;
  }

  // === 확률 분포 생성기 ===

  private static normalRandom(mean: number, stdDev: number): number {
    // Box-Muller 변환
    const u1 = Math.random();
    const u2 = Math.random();
    return mean + stdDev * Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }

  private static triangularRandom(min: number, mode: number, max: number): number {
    const u = Math.random();
    const fc = (mode - min) / (max - min);
    if (u < fc) {
      return min + Math.sqrt(u * (max - min) * (mode - min));
    } else {
      return max - Math.sqrt((1 - u) * (max - min) * (max - mode));
    }
  }

  private static betaRandom(alpha: number, beta: number): number {
    // Joehnk's method for alpha, beta > 1
    const gammaA = this.gammaRandom(alpha);
    const gammaB = this.gammaRandom(beta);
    return gammaA / (gammaA + gammaB);
  }

  private static gammaRandom(shape: number): number {
    // Marsaglia and Tsang's method
    if (shape < 1) return this.gammaRandom(shape + 1) * Math.pow(Math.random(), 1 / shape);
    const d = shape - 1/3;
    const c = 1 / Math.sqrt(9 * d);
    while (true) {
      let x: number, v: number;
      do { x = this.normalRandom(0, 1); v = 1 + c * x; } while (v <= 0);
      v = v * v * v;
      const u = Math.random();
      if (u < 1 - 0.0331 * (x * x) * (x * x)) return d * v;
      if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) return d * v;
    }
  }
}
```

---

## 3. 민감도 분석 고도화

### 3.1 Tornado 차트 알고리즘

```typescript
// src/utils/advancedSensitivity.ts

interface TornadoResult {
  criteria: Array<{
    id: string;
    name: string;
    baseRank: number;           // 기본 순위
    lowWeight: number;          // 최소 가중치 (기본 -50%)
    highWeight: number;         // 최대 가중치 (기본 +50%)
    lowRankChange: number;      // 최소 가중치 시 1위 대안 점수 변화량
    highRankChange: number;     // 최대 가중치 시 1위 대안 점수 변화량
    impactRange: number;        // |highChange - lowChange|
    rankReversalOccurred: boolean;
  }>;
  sortedByImpact: string[];     // 영향력 내림차순 기준 ID
}

class TornadoAnalysis {

  /**
   * Tornado 차트 데이터 생성
   *
   * 각 기준의 가중치를 ±variationRange만큼 변화시키고
   * (나머지 기준은 비례 조정) 최종 순위 변화를 측정
   */
  static calculate(
    baseWeights: number[],
    alternativeScores: number[][],  // [대안][기준]
    criteria: { id: string; name: string }[],
    alternatives: { id: string; name: string }[],
    variationRange: number = 0.5    // ±50% 변화
  ): TornadoResult {

    const n = criteria.length;
    const baseFinalScores = this.computeFinalScores(baseWeights, alternativeScores);
    const baseRanks = this.getRanks(baseFinalScores);
    const topAlternativeIdx = baseRanks.indexOf(1);

    const results = criteria.map((criterion, idx) => {
      // 가중치를 줄인 경우
      const lowWeights = this.adjustWeight(baseWeights, idx, -variationRange);
      const lowScores = this.computeFinalScores(lowWeights, alternativeScores);
      const lowRanks = this.getRanks(lowScores);

      // 가중치를 늘린 경우
      const highWeights = this.adjustWeight(baseWeights, idx, variationRange);
      const highScores = this.computeFinalScores(highWeights, alternativeScores);
      const highRanks = this.getRanks(highScores);

      const lowChange = lowScores[topAlternativeIdx] - baseFinalScores[topAlternativeIdx];
      const highChange = highScores[topAlternativeIdx] - baseFinalScores[topAlternativeIdx];

      return {
        id: criterion.id,
        name: criterion.name,
        baseRank: baseRanks[topAlternativeIdx],
        lowWeight: lowWeights[idx],
        highWeight: highWeights[idx],
        lowRankChange: lowChange,
        highRankChange: highChange,
        impactRange: Math.abs(highChange - lowChange),
        rankReversalOccurred: lowRanks[topAlternativeIdx] !== 1 || highRanks[topAlternativeIdx] !== 1,
      };
    });

    // 영향력 내림차순 정렬
    const sorted = [...results].sort((a, b) => b.impactRange - a.impactRange);

    return {
      criteria: results,
      sortedByImpact: sorted.map(r => r.id),
    };
  }

  /**
   * 특정 기준 가중치를 변화시키고 나머지를 비례 조정
   */
  private static adjustWeight(weights: number[], targetIdx: number, ratio: number): number[] {
    const adjusted = [...weights];
    const original = adjusted[targetIdx];
    const newWeight = Math.max(0.01, Math.min(0.99, original * (1 + ratio)));
    adjusted[targetIdx] = newWeight;

    // 나머지 기준 비례 재배분 (합 = 1 유지)
    const remaining = 1 - newWeight;
    const othersSum = weights.reduce((s, w, i) => i === targetIdx ? s : s + w, 0);

    for (let i = 0; i < adjusted.length; i++) {
      if (i !== targetIdx) {
        adjusted[i] = (weights[i] / othersSum) * remaining;
      }
    }

    return adjusted;
  }
}
```

### 3.2 순위 역전점 정밀 탐색

```typescript
/**
 * 이분법으로 순위가 바뀌는 정확한 가중치 지점을 찾음
 */
static findRankReversalPoints(
  baseWeights: number[],
  alternativeScores: number[][],
  criterionIdx: number,
  precision: number = 0.001
): Array<{ weight: number; rankBefore: number[]; rankAfter: number[] }> {

  const reversalPoints: Array<{ weight: number; rankBefore: number[]; rankAfter: number[] }> = [];
  const steps = 200; // 0.005 단위로 탐색

  let prevRanks: number[] | null = null;

  for (let step = 0; step <= steps; step++) {
    const ratio = (step / steps) * 2 - 1; // -1.0 ~ +1.0
    const weights = this.adjustWeight(baseWeights, criterionIdx, ratio);
    const scores = this.computeFinalScores(weights, alternativeScores);
    const ranks = this.getRanks(scores);

    if (prevRanks && !this.ranksEqual(prevRanks, ranks)) {
      // 순위 변화 발견 → 이분법으로 정밀 탐색
      const exactPoint = this.bisectionSearch(
        baseWeights, alternativeScores, criterionIdx,
        ((step - 1) / steps) * 2 - 1,
        ratio,
        precision
      );

      reversalPoints.push({
        weight: this.adjustWeight(baseWeights, criterionIdx, exactPoint)[criterionIdx],
        rankBefore: prevRanks,
        rankAfter: ranks,
      });
    }
    prevRanks = ranks;
  }

  return reversalPoints;
}

private static bisectionSearch(
  baseWeights: number[], scores: number[][], idx: number,
  lo: number, hi: number, precision: number
): number {
  const baseRanks = this.getRanks(
    this.computeFinalScores(this.adjustWeight(baseWeights, idx, lo), scores)
  );

  while (hi - lo > precision) {
    const mid = (lo + hi) / 2;
    const midWeights = this.adjustWeight(baseWeights, idx, mid);
    const midRanks = this.getRanks(this.computeFinalScores(midWeights, scores));

    if (this.ranksEqual(baseRanks, midRanks)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return (lo + hi) / 2;
}
```

---

## 4. 그룹 합의 알고리즘

### 4.1 AIJ (Aggregation of Individual Judgments)

```typescript
/**
 * AIJ: 개별 쌍대비교를 먼저 집계 → 단일 합의 행렬 → 가중치 계산
 *
 * 특징: 그룹을 하나의 의사결정자로 취급
 * 적용: 모든 평가자가 합의된 판단을 내릴 수 있는 경우
 */
static aggregateIndividualJudgments(
  matrices: number[][][],     // 평가자별 비교 행렬
  evaluatorWeights?: number[] // 평가자 중요도 가중치 (동일 시 생략)
): { consensusMatrix: number[][]; weights: number[]; cr: number } {

  const k = matrices.length;        // 평가자 수
  const n = matrices[0].length;     // 기준 수
  const w = evaluatorWeights || Array(k).fill(1 / k);

  // 가중 기하 평균으로 합의 행렬 생성
  const consensus = Array.from({ length: n }, () => Array(n).fill(1));

  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      let logSum = 0;
      for (let e = 0; e < k; e++) {
        logSum += w[e] * Math.log(matrices[e][i][j]);
      }
      consensus[i][j] = Math.exp(logSum);
      consensus[j][i] = 1 / consensus[i][j];
    }
  }

  const weights = calculateEigenWeights(consensus);
  const cr = calculateCR(consensus, weights);

  return { consensusMatrix: consensus, weights, cr };
}
```

### 4.2 AIP (Aggregation of Individual Priorities)

```typescript
/**
 * AIP: 개별 가중치를 먼저 계산 → 가중치를 집계
 *
 * 특징: 개별 일관성을 유지한 채 집계
 * 적용: 각 평가자의 독립적 판단이 중요한 경우
 */
static aggregateIndividualPriorities(
  matrices: number[][][],
  evaluatorWeights?: number[]
): {
  individualWeights: number[][];
  individualCRs: number[];
  consensusWeights: number[];
  consensusMethod: 'geometric_mean';
} {

  const k = matrices.length;
  const w = evaluatorWeights || Array(k).fill(1 / k);

  // 1. 각 평가자별 가중치 계산
  const individualWeights = matrices.map(m => calculateEigenWeights(m));
  const individualCRs = matrices.map((m, i) => calculateCR(m, individualWeights[i]));

  // 2. 가중 기하 평균으로 합의 가중치 생성
  const n = individualWeights[0].length;
  const rawConsensus = Array(n).fill(0);

  for (let i = 0; i < n; i++) {
    let logSum = 0;
    for (let e = 0; e < k; e++) {
      logSum += w[e] * Math.log(individualWeights[e][i]);
    }
    rawConsensus[i] = Math.exp(logSum);
  }

  // 3. 정규화
  const sum = rawConsensus.reduce((s, v) => s + v, 0);
  const consensusWeights = rawConsensus.map(v => v / sum);

  return {
    individualWeights,
    individualCRs,
    consensusWeights,
    consensusMethod: 'geometric_mean',
  };
}
```

### 4.3 Fuzzy 그룹 합의

```typescript
/**
 * Fuzzy 그룹 합의: 삼각 퍼지 수로 변환 후 합의
 *
 * Saaty 스케일 → TFN 매핑:
 * 1 → (1, 1, 1)
 * 3 → (2, 3, 4)
 * 5 → (4, 5, 6)
 * 7 → (6, 7, 8)
 * 9 → (9, 9, 9)
 * 중간값은 선형 보간
 */
static fuzzyGroupConsensus(
  matrices: number[][][],
  evaluatorWeights?: number[]
): {
  fuzzyConsensusMatrix: [number, number, number][][];
  defuzzifiedWeights: number[];
  fuzzyWeights: [number, number, number][];
  linguisticLabels: string[];
} {

  const k = matrices.length;
  const n = matrices[0].length;
  const w = evaluatorWeights || Array(k).fill(1 / k);

  // 1. 각 평가자의 비교값을 TFN으로 변환
  const fuzzyMatrices = matrices.map(m => this.crispToFuzzy(m));

  // 2. 가중 퍼지 기하평균
  const fuzzyConsensus: [number, number, number][][] = Array.from(
    { length: n },
    () => Array.from({ length: n }, (): [number, number, number] => [1, 1, 1])
  );

  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      let logL = 0, logM = 0, logU = 0;
      for (let e = 0; e < k; e++) {
        const [l, m, u] = fuzzyMatrices[e][i][j];
        logL += w[e] * Math.log(l);
        logM += w[e] * Math.log(m);
        logU += w[e] * Math.log(u);
      }
      fuzzyConsensus[i][j] = [Math.exp(logL), Math.exp(logM), Math.exp(logU)];
      fuzzyConsensus[j][i] = [
        1 / Math.exp(logU),
        1 / Math.exp(logM),
        1 / Math.exp(logL),
      ];
    }
  }

  // 3. Chang's Extent Analysis로 퍼지 가중치 계산
  const fuzzyWeights = this.changExtentAnalysis(fuzzyConsensus);

  // 4. 중심값(centroid) 비퍼지화
  const defuzzifiedWeights = fuzzyWeights.map(([l, m, u]) => (l + m + u) / 3);
  const sum = defuzzifiedWeights.reduce((s, v) => s + v, 0);
  const normalizedWeights = defuzzifiedWeights.map(v => v / sum);

  // 5. 언어적 레이블
  const linguisticLabels = normalizedWeights.map(w => {
    if (w >= 0.3) return '매우 중요';
    if (w >= 0.2) return '중요';
    if (w >= 0.1) return '보통';
    if (w >= 0.05) return '덜 중요';
    return '매우 덜 중요';
  });

  return {
    fuzzyConsensusMatrix: fuzzyConsensus,
    defuzzifiedWeights: normalizedWeights,
    fuzzyWeights,
    linguisticLabels,
  };
}

private static SAATY_TO_TFN: Record<number, [number, number, number]> = {
  1: [1, 1, 1],
  2: [1, 2, 3],
  3: [2, 3, 4],
  4: [3, 4, 5],
  5: [4, 5, 6],
  6: [5, 6, 7],
  7: [6, 7, 8],
  8: [7, 8, 9],
  9: [9, 9, 9],
};
```

### 4.4 Shannon Entropy 기반 합의도

```typescript
/**
 * Shannon Entropy를 이용한 평가자 간 합의 수준 측정
 *
 * H = -Σ p_i * ln(p_i) (정보 엔트로피)
 * 합의도 = 1 - H/H_max (0: 완전 불일치, 1: 완전 합의)
 */
interface ShannonConsensusResult {
  overallConsensus: number;         // 0~1 전체 합의도
  criteriaConsensus: Array<{
    id: string;
    name: string;
    consensus: number;              // 해당 기준에 대한 합의도
    entropy: number;                // 정보 엔트로피
    maxEntropy: number;
    weights: number[];              // 각 평가자의 가중치
  }>;
  evaluatorAgreement: Array<{
    evaluatorId: string;
    agreementScore: number;         // 다른 평가자들과의 평균 일치도
    outlierScore: number;           // 이상치 정도 (높을수록 소수 의견)
  }>;
  consensusLevel: 'strong' | 'moderate' | 'weak' | 'none';
}

static calculateShannonConsensus(
  individualWeights: number[][],  // [평가자][기준]
  criteria: { id: string; name: string }[],
  evaluatorIds: string[]
): ShannonConsensusResult {

  const k = individualWeights.length;  // 평가자 수
  const n = criteria.length;           // 기준 수

  const criteriaConsensus = criteria.map((criterion, j) => {
    // 기준 j에 대한 각 평가자의 가중치 수집
    const weights = individualWeights.map(w => w[j]);

    // 가중치를 확률 분포로 변환
    const sum = weights.reduce((s, w) => s + w, 0);
    const probs = weights.map(w => w / sum);

    // Shannon Entropy 계산
    const entropy = -probs.reduce((h, p) => {
      return p > 0 ? h + p * Math.log(p) : h;
    }, 0);

    const maxEntropy = Math.log(k);  // 균등 분포의 엔트로피
    const consensus = maxEntropy > 0 ? 1 - (entropy / maxEntropy) : 1;

    return {
      id: criterion.id,
      name: criterion.name,
      consensus,
      entropy,
      maxEntropy,
      weights,
    };
  });

  // 전체 합의도 = 기준별 합의도의 가중 평균
  const overallConsensus = criteriaConsensus.reduce((s, c) => s + c.consensus, 0) / n;

  // 평가자별 합의 점수 (다른 평가자들과의 코사인 유사도 평균)
  const evaluatorAgreement = evaluatorIds.map((evalId, i) => {
    const similarities: number[] = [];
    for (let j = 0; j < k; j++) {
      if (i === j) continue;
      similarities.push(cosineSimilarity(individualWeights[i], individualWeights[j]));
    }
    const agreementScore = similarities.reduce((s, v) => s + v, 0) / similarities.length;

    // 이상치 점수: 1 - agreementScore
    return {
      evaluatorId: evalId,
      agreementScore,
      outlierScore: 1 - agreementScore,
    };
  });

  const consensusLevel =
    overallConsensus >= 0.8 ? 'strong' :
    overallConsensus >= 0.6 ? 'moderate' :
    overallConsensus >= 0.4 ? 'weak' : 'none';

  return {
    overallConsensus,
    criteriaConsensus,
    evaluatorAgreement,
    consensusLevel,
  };
}

function cosineSimilarity(a: number[], b: number[]): number {
  let dot = 0, normA = 0, normB = 0;
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }
  return dot / (Math.sqrt(normA) * Math.sqrt(normB));
}
```

---

## 5. Pareto 최적 프론티어

```typescript
// src/utils/paretoAnalysis.ts

interface ParetoResult {
  alternatives: Array<{
    id: string;
    name: string;
    scores: Record<string, number>;  // 기준별 점수
    isDominated: boolean;
    dominatedBy: string[];           // 지배하는 대안 ID 목록
    paretoRank: number;              // Pareto 순위 (1 = 최적 프론티어)
  }>;
  paretoFrontier: string[];          // 최적 프론티어 대안 ID 목록
  dominanceMatrix: boolean[][];      // [i][j] = i가 j를 지배하는지
}

class ParetoAnalysis {

  /**
   * Pareto 지배 관계 분석
   *
   * 대안 A가 대안 B를 지배: 모든 기준에서 A ≥ B이고, 하나 이상에서 A > B
   */
  static analyze(
    alternatives: { id: string; name: string }[],
    criteriaScores: Record<string, number>[],  // [대안 인덱스] → {기준ID: 점수}
    criteriaDirection: Record<string, 'maximize' | 'minimize'>
  ): ParetoResult {

    const m = alternatives.length;
    const dominanceMatrix = Array.from({ length: m }, () => Array(m).fill(false));
    const dominatedBy: string[][] = Array.from({ length: m }, () => []);

    // 지배 관계 판정
    for (let i = 0; i < m; i++) {
      for (let j = 0; j < m; j++) {
        if (i === j) continue;
        if (this.dominates(criteriaScores[i], criteriaScores[j], criteriaDirection)) {
          dominanceMatrix[i][j] = true;
          dominatedBy[j].push(alternatives[i].id);
        }
      }
    }

    // Pareto 순위 계산 (비지배 레벨)
    const paretoRanks = this.calculateParetoRanks(dominanceMatrix);

    const result: ParetoResult = {
      alternatives: alternatives.map((alt, i) => ({
        id: alt.id,
        name: alt.name,
        scores: criteriaScores[i],
        isDominated: dominatedBy[i].length > 0,
        dominatedBy: dominatedBy[i],
        paretoRank: paretoRanks[i],
      })),
      paretoFrontier: alternatives
        .filter((_, i) => paretoRanks[i] === 1)
        .map(a => a.id),
      dominanceMatrix,
    };

    return result;
  }

  private static dominates(
    a: Record<string, number>,
    b: Record<string, number>,
    direction: Record<string, 'maximize' | 'minimize'>
  ): boolean {
    let atLeastOneBetter = false;
    for (const [key, dir] of Object.entries(direction)) {
      const aVal = a[key] ?? 0;
      const bVal = b[key] ?? 0;
      if (dir === 'maximize') {
        if (aVal < bVal) return false;
        if (aVal > bVal) atLeastOneBetter = true;
      } else {
        if (aVal > bVal) return false;
        if (aVal < bVal) atLeastOneBetter = true;
      }
    }
    return atLeastOneBetter;
  }

  private static calculateParetoRanks(dominanceMatrix: boolean[][]): number[] {
    const m = dominanceMatrix.length;
    const ranks = Array(m).fill(0);
    const remaining = new Set(Array.from({ length: m }, (_, i) => i));
    let currentRank = 1;

    while (remaining.size > 0) {
      // 현재 남은 것들 중 비지배 대안 찾기
      const nonDominated: number[] = [];
      for (const i of remaining) {
        let isDominated = false;
        for (const j of remaining) {
          if (i !== j && dominanceMatrix[j][i]) {
            isDominated = true;
            break;
          }
        }
        if (!isDominated) nonDominated.push(i);
      }

      for (const idx of nonDominated) {
        ranks[idx] = currentRank;
        remaining.delete(idx);
      }
      currentRank++;
    }

    return ranks;
  }
}
```

---

## 6. 강건성(Robustness) 종합 분석

```typescript
// src/utils/robustnessAnalysis.ts

interface RobustnessResult {
  overallRobustness: number;  // 0~1 (1 = 완전 강건)
  components: {
    sensitivityStability: number;    // 가중치 변화 대비 순위 안정성
    monteCarloStability: number;     // MC 시뮬레이션 기반 순위 일관성
    groupConsensus: number;          // 평가자 간 합의도
    consistencyQuality: number;      // 평균 일관성 품질
  };
  riskLevel: 'low' | 'medium' | 'high';
  recommendations: string[];
}

class RobustnessAnalysis {

  /**
   * 4가지 관점의 강건성 종합 점수
   */
  static evaluate(
    sensitivityResult: TornadoResult,
    monteCarloResult: MonteCarloResult,
    shannonConsensus: ShannonConsensusResult,
    consistencyRatios: number[]
  ): RobustnessResult {

    // 1. 민감도 안정성: 순위 역전이 발생하지 않는 기준의 비율
    const totalCriteria = sensitivityResult.criteria.length;
    const stableCriteria = sensitivityResult.criteria.filter(c => !c.rankReversalOccurred).length;
    const sensitivityStability = totalCriteria > 0 ? stableCriteria / totalCriteria : 1;

    // 2. MC 안정성: 1위 대안의 1위 달성 확률
    const monteCarloStability = monteCarloResult.summary.dominantProbability;

    // 3. 그룹 합의도
    const groupConsensus = shannonConsensus.overallConsensus;

    // 4. 일관성 품질: CR < 0.05 비율
    const goodCR = consistencyRatios.filter(cr => cr < 0.05).length;
    const consistencyQuality = consistencyRatios.length > 0
      ? goodCR / consistencyRatios.length
      : 1;

    // 종합 점수 (가중 평균)
    const weights = { sensitivity: 0.3, monteCarlo: 0.3, consensus: 0.2, consistency: 0.2 };
    const overallRobustness =
      weights.sensitivity * sensitivityStability +
      weights.monteCarlo * monteCarloStability +
      weights.consensus * groupConsensus +
      weights.consistency * consistencyQuality;

    // 리스크 레벨 판정
    const riskLevel =
      overallRobustness >= 0.7 ? 'low' :
      overallRobustness >= 0.4 ? 'medium' : 'high';

    // 개선 권고사항 생성
    const recommendations: string[] = [];
    if (sensitivityStability < 0.7) {
      recommendations.push('일부 기준의 가중치 변화에 순위가 민감합니다. 해당 기준의 쌍대비교를 재검토하세요.');
    }
    if (monteCarloStability < 0.6) {
      recommendations.push('시뮬레이션에서 1위 대안의 확률이 낮습니다. 대안 간 차이가 충분히 명확한지 확인하세요.');
    }
    if (groupConsensus < 0.5) {
      recommendations.push('평가자 간 의견 차이가 큽니다. 그룹 토의를 통해 합의를 도출하세요.');
    }
    if (consistencyQuality < 0.5) {
      recommendations.push('일부 평가자의 일관성이 낮습니다. 일관성 개선 가이드를 제공하세요.');
    }
    if (recommendations.length === 0) {
      recommendations.push('분석 결과가 전반적으로 강건합니다. 결과를 신뢰할 수 있습니다.');
    }

    return {
      overallRobustness,
      components: {
        sensitivityStability,
        monteCarloStability,
        groupConsensus,
        consistencyQuality,
      },
      riskLevel,
      recommendations,
    };
  }
}
```

---

## 7. 구현 가이드 (Sonnet용)

### 7.1 파일 구조

```
src/utils/
├── ahpCalculator.ts              ← [유지] 기존 핵심 계산
├── fuzzyCalculations.ts          ← [유지] 기존 퍼지 계산
├── scenarioAnalysis.ts           ← [유지] 기존 시나리오
├── advancedMonteCarlo.ts         ← [신규] MC 시뮬레이션 고도화
├── advancedSensitivity.ts        ← [신규] Tornado + 순위 역전점
├── groupConsensus.ts             ← [신규] AIJ/AIP/Fuzzy/Shannon
├── paretoAnalysis.ts             ← [신규] Pareto 최적 프론티어
└── robustnessAnalysis.ts         ← [신규] 강건성 종합 분석
```

### 7.2 구현 순서

```
Step 1: groupConsensus.ts (2시간)
├── AIJ, AIP, Fuzzy 합의, Shannon Entropy
└── 기존 ahpCalculator.ts의 그룹 로직과 연동

Step 2: advancedMonteCarlo.ts (2시간)
├── 분포 샘플링, 수렴 판정, 통계 집계
└── 기존 scenarioAnalysis.ts의 MC와 병행 유지

Step 3: advancedSensitivity.ts (1.5시간)
├── Tornado 차트 데이터 생성
└── 이분법 순위 역전점 탐색

Step 4: paretoAnalysis.ts (1시간)
├── 지배 관계 판정, Pareto 순위
└── AdvancedAnalysisDashboard와 연동

Step 5: robustnessAnalysis.ts (1시간)
├── 4가지 관점 종합 점수
└── 권고사항 자동 생성

Step 6: UI 컴포넌트 수정 (2시간)
├── MonteCarloSimulation.tsx → advancedMonteCarlo 연동
├── SensitivityAnalysisPanel.tsx → Tornado 차트 추가
├── GroupConsensusPanel.tsx → AIJ/AIP/Shannon 탭 추가
└── ComprehensiveReport.tsx → 강건성 섹션 추가
```

### 7.3 주의사항

1. **기존 파일 수정 금지** — `ahpCalculator.ts`, `fuzzyCalculations.ts`는 그대로 유지
2. **새 파일로 분리** — 고급 알고리즘은 별도 파일에 구현
3. **순수 함수로 구현** — 부수 효과 없이 입력→출력 변환만 수행
4. **성능 주의** — Monte Carlo 10000회는 Web Worker에서 실행 고려
5. **단위 테스트 작성** — 각 알고리즘에 대한 테스트 케이스 포함
