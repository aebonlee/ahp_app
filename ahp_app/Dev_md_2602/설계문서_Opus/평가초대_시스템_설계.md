# Phase 2a: 평가자 초대 시스템 설계

**작성자**: Claude Opus 4.6 (설계/알고리즘 담당)
**작성일**: 2026-02-23
**상태**: 설계 완료 → Sonnet 구현 대기
**현재 완성도**: 40% → **목표: 100%**

---

## 1. 현황 분석

### 1.1 기존 구현 (40%)

| 기능 | 파일 | 상태 |
|------|------|------|
| 이메일 벌크 초대 UI | `evaluation/assignment/InviteEvaluators.tsx` | ✅ 완료 |
| 액세스 키 생성 (`KEY_` + 8자리) | `admin/EvaluatorAssignment.tsx:114-120` | ✅ 완료 |
| QR 코드 생성 | `evaluation/QRCodeEvaluatorAssignment.tsx` | ✅ 완료 |
| 익명 평가자 세션 관리 | `evaluation/AnonymousEvaluator.tsx` | ✅ 완료 |
| 설문 링크 관리 UI | `admin/SurveyLinkManager.tsx` | ✅ 완료 |
| 초대 이력 조회 | `evaluation/assignment/InvitationHistory.tsx` | ✅ 완료 |

### 1.2 미구현 (60%)

| 기능 | 상태 |
|------|------|
| JWT 기반 초대 토큰 생명주기 관리 | ❌ 미구현 |
| 초대 상태 머신 (만료/재발송/취소) | ❌ 미구현 |
| 이메일 발송 확인/반송 추적 | ❌ 미구현 |
| 토큰 검증 미들웨어 (백엔드) | ❌ 미구현 |
| 평가자별 개별 상태 추적 | ❌ 미구현 |
| 초대 리마인더 자동 발송 | ❌ 미구현 |
| 초대 감사 로그 | ❌ 미구현 |
| 평가자 인증 강화 (토큰 + PIN) | ❌ 미구현 |

---

## 2. 아키텍처 설계

### 2.1 전체 흐름도

```
┌─────────────┐     ┌──────────────┐     ┌─────────────────┐
│  관리자(Admin) │────▶│ React Frontend│────▶│ Django Backend   │
│  초대 생성    │     │ 초대 폼 제출  │     │ 토큰 생성/발송   │
└─────────────┘     └──────────────┘     └────────┬────────┘
                                                   │
                                         ┌─────────▼─────────┐
                                         │   이메일 서비스     │
                                         │ (Django Email/SES) │
                                         └─────────┬─────────┘
                                                   │
                                         ┌─────────▼─────────┐
                                         │   평가자 수신      │
                                         │   링크 클릭        │
                                         └─────────┬─────────┘
                                                   │
                                         ┌─────────▼─────────┐
                                         │ 토큰 검증 미들웨어  │
                                         │ (만료/취소/사용 확인)│
                                         └─────────┬─────────┘
                                                   │
                                    ┌──────────────▼──────────────┐
                                    │        평가 화면 진입        │
                                    │  (PairwiseEvaluation 등)     │
                                    └─────────────────────────────┘
```

### 2.2 컴포넌트 구조

```
src/
├── services/
│   └── invitationService.ts          ← [신규] 초대 전용 서비스 레이어
│
├── hooks/
│   └── useInvitations.ts             ← [신규] 초대 관리 커스텀 Hook
│
├── components/
│   └── evaluation/
│       └── assignment/
│           ├── InviteEvaluators.tsx   ← [수정] 상태 머신 연동
│           ├── InvitationHistory.tsx  ← [수정] 개별 상태 추적 강화
│           ├── InvitationTracker.tsx  ← [신규] 실시간 초대 상태 대시보드
│           └── ReminderManager.tsx    ← [신규] 리마인더 설정/관리
│
└── types/
    └── invitation.ts                 ← [신규] 초대 관련 타입 정의
```

---

## 3. 초대 토큰 설계 (JWT 기반)

### 3.1 토큰 구조

```typescript
// JWT Payload
interface InvitationTokenPayload {
  // 표준 클레임
  iss: 'ahp-platform';          // 발행자
  sub: string;                   // 평가자 이메일 (해싱된 값)
  iat: number;                   // 발행 시각 (Unix timestamp)
  exp: number;                   // 만료 시각

  // 커스텀 클레임
  inv_id: string;                // 초대 고유 ID (UUID v4)
  proj_id: number;               // 프로젝트 ID
  eval_role: 'evaluator';        // 역할 (고정)
  permissions: string[];          // ['pairwise_compare', 'direct_input', 'survey']
  max_uses: number;              // 최대 사용 횟수 (기본 1)
  pin_required: boolean;         // PIN 인증 필요 여부
}
```

### 3.2 토큰 생성 (Django 백엔드)

```python
# backend: evaluations/services/invitation_token_service.py

import jwt
import uuid
from datetime import datetime, timedelta
from django.conf import settings
from hashlib import sha256

class InvitationTokenService:
    ALGORITHM = 'HS256'

    @classmethod
    def create_token(cls, invitation):
        """초대에 대한 JWT 토큰 생성"""
        payload = {
            'iss': 'ahp-platform',
            'sub': sha256(invitation.email.encode()).hexdigest()[:16],
            'iat': datetime.utcnow(),
            'exp': datetime.utcnow() + timedelta(days=invitation.expiry_days),
            'inv_id': str(invitation.id),
            'proj_id': invitation.project_id,
            'eval_role': 'evaluator',
            'permissions': invitation.get_permissions(),
            'max_uses': invitation.max_uses,
            'pin_required': invitation.pin_required,
        }
        return jwt.encode(payload, settings.INVITATION_SECRET_KEY, algorithm=cls.ALGORITHM)

    @classmethod
    def verify_token(cls, token):
        """토큰 검증 및 디코딩"""
        try:
            payload = jwt.decode(
                token,
                settings.INVITATION_SECRET_KEY,
                algorithms=[cls.ALGORITHM],
                issuer='ahp-platform'
            )
            return {'valid': True, 'payload': payload}
        except jwt.ExpiredSignatureError:
            return {'valid': False, 'error': 'TOKEN_EXPIRED'}
        except jwt.InvalidTokenError as e:
            return {'valid': False, 'error': 'TOKEN_INVALID', 'detail': str(e)}
```

### 3.3 토큰 보안 정책

| 항목 | 정책 |
|------|------|
| 서명 키 | `INVITATION_SECRET_KEY` (사용자 인증 JWT와 별도 키) |
| 알고리즘 | HS256 (서버-서버 간 통신 없으므로 대칭키 충분) |
| 만료 기간 | 관리자 설정 가능 (7/14/30/60/90일) |
| 최대 사용 | 기본 1회, 관리자 설정 가능 |
| 토큰 길이 | URL-safe Base64, ~300자 |
| 전송 방식 | URL 쿼리 파라미터 `?token={JWT}` |
| HTTPS 강제 | 프로덕션 환경 필수 |

---

## 4. 상태 머신 설계

### 4.1 초대 상태 전이도

```
                    ┌──────────┐
         생성 ──────▶│ PENDING  │
                    └────┬─────┘
                         │
              ┌──────────┼──────────┐
              │          │          │
              ▼          ▼          ▼
        ┌──────────┐ ┌──────┐ ┌──────────┐
        │  SENT    │ │FAILED│ │ CANCELLED│
        └────┬─────┘ └──┬───┘ └──────────┘
             │          │
             │    재발송 │
             │◀─────────┘
             │
      ┌──────┼──────────┐
      │      │          │
      ▼      ▼          ▼
┌──────────┐ ┌──────┐ ┌──────────┐
│ OPENED   │ │BOUNCED│ │ EXPIRED  │
└────┬─────┘ └──────┘ └──────────┘
     │
     ▼
┌──────────────┐
│ IN_PROGRESS  │
└────┬─────────┘
     │
     ▼
┌──────────────┐
│  COMPLETED   │
└──────────────┘
```

### 4.2 상태 정의

```typescript
// src/types/invitation.ts

type InvitationStatus =
  | 'pending'       // 초대 생성됨, 발송 대기
  | 'sent'          // 이메일 발송 완료
  | 'failed'        // 이메일 발송 실패
  | 'bounced'       // 이메일 반송됨
  | 'opened'        // 평가자가 링크 클릭 (토큰 최초 사용)
  | 'in_progress'   // 평가 진행 중
  | 'completed'     // 평가 완료
  | 'expired'       // 토큰 만료
  | 'cancelled';    // 관리자가 취소

interface InvitationStatusTransition {
  from: InvitationStatus;
  to: InvitationStatus;
  trigger: string;
  guard?: string;   // 전이 조건
}

// 허용되는 상태 전이
const ALLOWED_TRANSITIONS: InvitationStatusTransition[] = [
  { from: 'pending',     to: 'sent',        trigger: 'email_sent' },
  { from: 'pending',     to: 'failed',      trigger: 'email_failed' },
  { from: 'pending',     to: 'cancelled',   trigger: 'admin_cancel' },
  { from: 'sent',        to: 'opened',      trigger: 'token_first_use' },
  { from: 'sent',        to: 'bounced',     trigger: 'email_bounced' },
  { from: 'sent',        to: 'expired',     trigger: 'token_expired' },
  { from: 'sent',        to: 'cancelled',   trigger: 'admin_cancel' },
  { from: 'failed',      to: 'sent',        trigger: 'email_resent' },
  { from: 'bounced',     to: 'sent',        trigger: 'email_resent', guard: 'email_corrected' },
  { from: 'opened',      to: 'in_progress', trigger: 'evaluation_started' },
  { from: 'opened',      to: 'expired',     trigger: 'token_expired' },
  { from: 'in_progress', to: 'completed',   trigger: 'evaluation_submitted' },
  { from: 'in_progress', to: 'expired',     trigger: 'token_expired' },
  { from: 'expired',     to: 'sent',        trigger: 'admin_extend', guard: 'new_token_issued' },
];
```

### 4.3 상태 전이 엔진 (Django)

```python
# backend: evaluations/services/invitation_state_machine.py

class InvitationStateMachine:
    TRANSITIONS = {
        'pending':     ['sent', 'failed', 'cancelled'],
        'sent':        ['opened', 'bounced', 'expired', 'cancelled'],
        'failed':      ['sent'],               # 재발송
        'bounced':     ['sent'],               # 이메일 수정 후 재발송
        'opened':      ['in_progress', 'expired'],
        'in_progress': ['completed', 'expired'],
        'expired':     ['sent'],               # 연장 (새 토큰 발급)
        'completed':   [],                     # 최종 상태
        'cancelled':   [],                     # 최종 상태
    }

    @classmethod
    def can_transition(cls, current_status, new_status):
        return new_status in cls.TRANSITIONS.get(current_status, [])

    @classmethod
    def transition(cls, invitation, new_status, actor=None, reason=None):
        if not cls.can_transition(invitation.status, new_status):
            raise InvalidTransitionError(
                f"Cannot transition from '{invitation.status}' to '{new_status}'"
            )

        old_status = invitation.status
        invitation.status = new_status
        invitation.updated_at = timezone.now()
        invitation.save(update_fields=['status', 'updated_at'])

        # 감사 로그 기록
        InvitationAuditLog.objects.create(
            invitation=invitation,
            old_status=old_status,
            new_status=new_status,
            actor=actor,
            reason=reason,
            ip_address=get_client_ip(),
            timestamp=timezone.now(),
        )

        return invitation
```

---

## 5. Django 백엔드 API 스펙

### 5.1 데이터 모델

```python
# backend: evaluations/models/invitation.py

class Invitation(models.Model):
    """개별 평가자 초대"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    project = models.ForeignKey('projects.Project', on_delete=models.CASCADE,
                                related_name='invitations')
    email = models.EmailField()
    evaluator_name = models.CharField(max_length=100, blank=True)

    # 토큰 관리
    token = models.TextField(unique=True)           # JWT 토큰
    access_key = models.CharField(max_length=20, unique=True, blank=True)  # 단축 키
    pin_code = models.CharField(max_length=6, blank=True)  # 선택적 PIN

    # 상태
    status = models.CharField(max_length=20, default='pending',
                              choices=INVITATION_STATUS_CHOICES)

    # 설정
    expiry_days = models.PositiveIntegerField(default=14)
    max_uses = models.PositiveIntegerField(default=1)
    use_count = models.PositiveIntegerField(default=0)
    permissions = models.JSONField(default=list)     # ['pairwise_compare', ...]
    custom_message = models.TextField(blank=True)

    # 추적
    created_by = models.ForeignKey('auth.User', on_delete=models.SET_NULL, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    sent_at = models.DateTimeField(null=True)
    opened_at = models.DateTimeField(null=True)
    completed_at = models.DateTimeField(null=True)
    expires_at = models.DateTimeField()

    # 이메일 추적
    email_message_id = models.CharField(max_length=255, blank=True)
    email_delivery_status = models.CharField(max_length=20, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=['project', 'status']),
            models.Index(fields=['email']),
            models.Index(fields=['access_key']),
            models.Index(fields=['expires_at']),
        ]
        unique_together = [('project', 'email')]  # 프로젝트당 이메일 중복 방지


class InvitationBatch(models.Model):
    """벌크 초대 배치"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    project = models.ForeignKey('projects.Project', on_delete=models.CASCADE)
    created_by = models.ForeignKey('auth.User', on_delete=models.SET_NULL, null=True)
    created_at = models.DateTimeField(auto_now_add=True)

    total_count = models.PositiveIntegerField(default=0)
    sent_count = models.PositiveIntegerField(default=0)
    failed_count = models.PositiveIntegerField(default=0)
    custom_message = models.TextField(blank=True)
    expiry_days = models.PositiveIntegerField(default=14)


class InvitationAuditLog(models.Model):
    """초대 감사 로그"""
    invitation = models.ForeignKey(Invitation, on_delete=models.CASCADE,
                                   related_name='audit_logs')
    old_status = models.CharField(max_length=20)
    new_status = models.CharField(max_length=20)
    actor = models.ForeignKey('auth.User', on_delete=models.SET_NULL, null=True)
    reason = models.TextField(blank=True)
    ip_address = models.GenericIPAddressField(null=True)
    timestamp = models.DateTimeField(auto_now_add=True)
    metadata = models.JSONField(default=dict)  # 추가 정보 (User-Agent 등)
```

### 5.2 API 엔드포인트

#### 초대 관리 API

| Method | Endpoint | 설명 | 권한 |
|--------|----------|------|------|
| `POST` | `/api/v1/invitations/` | 개별 초대 생성 | project_admin |
| `POST` | `/api/v1/invitations/bulk/` | 벌크 초대 (다수 이메일) | project_admin |
| `GET` | `/api/v1/invitations/?project={id}` | 프로젝트별 초대 목록 | project_admin |
| `GET` | `/api/v1/invitations/{inv_id}/` | 초대 상세 조회 | project_admin |
| `PATCH` | `/api/v1/invitations/{inv_id}/` | 초대 수정 (메시지, 만료일) | project_admin |
| `DELETE` | `/api/v1/invitations/{inv_id}/` | 초대 취소 (soft delete) | project_admin |
| `POST` | `/api/v1/invitations/{inv_id}/resend/` | 개별 재발송 | project_admin |
| `POST` | `/api/v1/invitations/{inv_id}/extend/` | 만료 연장 (새 토큰) | project_admin |
| `POST` | `/api/v1/invitations/bulk-resend/` | 실패분 일괄 재발송 | project_admin |
| `GET` | `/api/v1/invitations/{inv_id}/audit-log/` | 감사 로그 조회 | project_admin |

#### 토큰 검증 API (평가자 접근)

| Method | Endpoint | 설명 | 권한 |
|--------|----------|------|------|
| `POST` | `/api/v1/invitations/verify-token/` | 토큰 유효성 검증 | public |
| `POST` | `/api/v1/invitations/verify-key/` | 액세스 키 검증 | public |
| `POST` | `/api/v1/invitations/verify-pin/` | PIN 추가 인증 | public |

#### 리마인더 API

| Method | Endpoint | 설명 | 권한 |
|--------|----------|------|------|
| `POST` | `/api/v1/invitations/reminders/` | 리마인더 설정 | project_admin |
| `GET` | `/api/v1/invitations/reminders/?project={id}` | 리마인더 조회 | project_admin |
| `DELETE` | `/api/v1/invitations/reminders/{id}/` | 리마인더 삭제 | project_admin |

### 5.3 API 요청/응답 예시

#### 벌크 초대 생성

```
POST /api/v1/invitations/bulk/
Content-Type: application/json
Authorization: Bearer {admin_jwt}
```

**Request:**
```json
{
  "project_id": 42,
  "evaluators": [
    { "email": "eval1@example.com", "name": "김평가" },
    { "email": "eval2@example.com", "name": "이평가" },
    { "email": "eval3@example.com" }
  ],
  "custom_message": "AHP 연구 프로젝트에 참여해 주세요.",
  "expiry_days": 14,
  "permissions": ["pairwise_compare", "survey"],
  "pin_required": false,
  "send_immediately": true
}
```

**Response (201):**
```json
{
  "batch_id": "b1a2c3d4-...",
  "total": 3,
  "created": 3,
  "duplicates": 0,
  "invitations": [
    {
      "id": "inv-001-...",
      "email": "eval1@example.com",
      "name": "김평가",
      "status": "sent",
      "access_key": "KEY_A1B2C3D4",
      "evaluation_url": "https://aebonlee.github.io/ahp_app/?token={JWT}",
      "short_url": "https://aebonlee.github.io/ahp_app/?key=KEY_A1B2C3D4",
      "expires_at": "2026-03-09T00:00:00Z"
    },
    ...
  ]
}
```

#### 토큰 검증

```
POST /api/v1/invitations/verify-token/
Content-Type: application/json
```

**Request:**
```json
{
  "token": "eyJhbGciOiJIUzI1NiIs..."
}
```

**Response (200) - 유효:**
```json
{
  "valid": true,
  "invitation_id": "inv-001-...",
  "project_id": 42,
  "project_title": "작물 품종 선정 AHP 분석",
  "evaluator_email": "eval1@example.com",
  "permissions": ["pairwise_compare", "survey"],
  "pin_required": false,
  "expires_at": "2026-03-09T00:00:00Z"
}
```

**Response (401) - 만료:**
```json
{
  "valid": false,
  "error": "TOKEN_EXPIRED",
  "message": "초대 링크가 만료되었습니다. 관리자에게 재발송을 요청하세요.",
  "expired_at": "2026-03-09T00:00:00Z"
}
```

---

## 6. 프론트엔드 서비스 설계

### 6.1 invitationService.ts

```typescript
// src/services/invitationService.ts

import api from './api';
import type {
  Invitation, InvitationBatch, InvitationCreateRequest,
  InvitationBulkRequest, TokenVerifyResponse, ReminderConfig
} from '../types/invitation';

class InvitationService {

  // === 관리자 API ===

  async createInvitation(data: InvitationCreateRequest): Promise<Invitation> {
    const response = await api.post('/api/v1/invitations/', data);
    return response.data;
  }

  async createBulkInvitations(data: InvitationBulkRequest): Promise<InvitationBatch> {
    const response = await api.post('/api/v1/invitations/bulk/', data);
    return response.data;
  }

  async getInvitations(projectId: number, filters?: {
    status?: string;
    page?: number;
    page_size?: number;
  }): Promise<{ results: Invitation[]; count: number }> {
    const params = new URLSearchParams({ project: String(projectId) });
    if (filters?.status) params.set('status', filters.status);
    if (filters?.page) params.set('page', String(filters.page));
    if (filters?.page_size) params.set('page_size', String(filters.page_size));
    const response = await api.get(`/api/v1/invitations/?${params}`);
    return response.data;
  }

  async resendInvitation(invitationId: string): Promise<void> {
    await api.post(`/api/v1/invitations/${invitationId}/resend/`);
  }

  async cancelInvitation(invitationId: string, reason?: string): Promise<void> {
    await api.delete(`/api/v1/invitations/${invitationId}/`, {
      data: { reason }
    });
  }

  async extendInvitation(invitationId: string, extraDays: number): Promise<Invitation> {
    const response = await api.post(`/api/v1/invitations/${invitationId}/extend/`, {
      extra_days: extraDays
    });
    return response.data;
  }

  async bulkResendFailed(projectId: number): Promise<{ resent_count: number }> {
    const response = await api.post('/api/v1/invitations/bulk-resend/', {
      project_id: projectId
    });
    return response.data;
  }

  async getAuditLog(invitationId: string): Promise<AuditLogEntry[]> {
    const response = await api.get(`/api/v1/invitations/${invitationId}/audit-log/`);
    return response.data;
  }

  // === 평가자 접근 API ===

  async verifyToken(token: string): Promise<TokenVerifyResponse> {
    const response = await api.post('/api/v1/invitations/verify-token/', { token });
    return response.data;
  }

  async verifyAccessKey(key: string): Promise<TokenVerifyResponse> {
    const response = await api.post('/api/v1/invitations/verify-key/', { key });
    return response.data;
  }

  async verifyPin(invitationId: string, pin: string): Promise<{ verified: boolean }> {
    const response = await api.post('/api/v1/invitations/verify-pin/', {
      invitation_id: invitationId, pin
    });
    return response.data;
  }

  // === 리마인더 API ===

  async setReminder(config: ReminderConfig): Promise<void> {
    await api.post('/api/v1/invitations/reminders/', config);
  }

  async getReminders(projectId: number): Promise<ReminderConfig[]> {
    const response = await api.get(`/api/v1/invitations/reminders/?project=${projectId}`);
    return response.data;
  }
}

export default new InvitationService();
```

### 6.2 타입 정의

```typescript
// src/types/invitation.ts

export type InvitationStatus =
  | 'pending' | 'sent' | 'failed' | 'bounced'
  | 'opened' | 'in_progress' | 'completed'
  | 'expired' | 'cancelled';

export interface Invitation {
  id: string;
  project_id: number;
  email: string;
  evaluator_name: string;
  status: InvitationStatus;
  access_key: string;
  token: string;              // JWT (관리자에게만 노출)
  evaluation_url: string;
  short_url: string;
  permissions: string[];
  pin_required: boolean;
  expiry_days: number;
  max_uses: number;
  use_count: number;
  custom_message: string;
  created_at: string;
  sent_at: string | null;
  opened_at: string | null;
  completed_at: string | null;
  expires_at: string;
}

export interface InvitationCreateRequest {
  project_id: number;
  email: string;
  evaluator_name?: string;
  custom_message?: string;
  expiry_days?: number;
  permissions?: string[];
  pin_required?: boolean;
  send_immediately?: boolean;
}

export interface InvitationBulkRequest {
  project_id: number;
  evaluators: Array<{ email: string; name?: string }>;
  custom_message?: string;
  expiry_days?: number;
  permissions?: string[];
  pin_required?: boolean;
  send_immediately?: boolean;
}

export interface TokenVerifyResponse {
  valid: boolean;
  invitation_id?: string;
  project_id?: number;
  project_title?: string;
  evaluator_email?: string;
  permissions?: string[];
  pin_required?: boolean;
  expires_at?: string;
  error?: 'TOKEN_EXPIRED' | 'TOKEN_INVALID' | 'TOKEN_REVOKED' | 'TOKEN_USED';
  message?: string;
}

export interface InvitationBatch {
  batch_id: string;
  total: number;
  created: number;
  duplicates: number;
  invitations: Invitation[];
}

export interface AuditLogEntry {
  id: string;
  old_status: InvitationStatus;
  new_status: InvitationStatus;
  actor: string | null;
  reason: string;
  ip_address: string | null;
  timestamp: string;
}

export interface ReminderConfig {
  project_id: number;
  target_statuses: InvitationStatus[];    // 어떤 상태의 평가자에게 발송할지
  schedule_type: 'once' | 'recurring';
  send_at?: string;                       // 'once' 시 발송 시각
  interval_days?: number;                 // 'recurring' 시 반복 간격
  max_reminders?: number;                 // 최대 리마인더 횟수
  custom_message?: string;
}
```

### 6.3 useInvitations Hook

```typescript
// src/hooks/useInvitations.ts

import { useState, useCallback, useEffect, useRef } from 'react';
import invitationService from '../services/invitationService';
import type { Invitation, InvitationBulkRequest, InvitationStatus } from '../types/invitation';

interface UseInvitationsOptions {
  projectId: number;
  autoRefresh?: boolean;        // 자동 새로고침 (기본 true)
  refreshInterval?: number;     // 새로고침 간격 ms (기본 30000)
}

export function useInvitations({ projectId, autoRefresh = true, refreshInterval = 30000 }: UseInvitationsOptions) {
  const [invitations, setInvitations] = useState<Invitation[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);

  // 초대 목록 조회
  const fetchInvitations = useCallback(async (filters?: { status?: InvitationStatus }) => {
    setLoading(true);
    setError(null);
    try {
      const data = await invitationService.getInvitations(projectId, filters);
      setInvitations(data.results);
    } catch (err) {
      setError('초대 목록을 불러오지 못했습니다.');
    } finally {
      setLoading(false);
    }
  }, [projectId]);

  // 벌크 초대 발송
  const sendBulkInvitations = useCallback(async (request: InvitationBulkRequest) => {
    const batch = await invitationService.createBulkInvitations(request);
    await fetchInvitations();  // 목록 갱신
    return batch;
  }, [fetchInvitations]);

  // 개별 재발송
  const resendInvitation = useCallback(async (invitationId: string) => {
    await invitationService.resendInvitation(invitationId);
    await fetchInvitations();
  }, [fetchInvitations]);

  // 초대 취소
  const cancelInvitation = useCallback(async (invitationId: string, reason?: string) => {
    await invitationService.cancelInvitation(invitationId, reason);
    await fetchInvitations();
  }, [fetchInvitations]);

  // 만료 연장
  const extendInvitation = useCallback(async (invitationId: string, extraDays: number) => {
    const updated = await invitationService.extendInvitation(invitationId, extraDays);
    setInvitations(prev => prev.map(inv => inv.id === updated.id ? updated : inv));
    return updated;
  }, []);

  // 실패분 일괄 재발송
  const resendAllFailed = useCallback(async () => {
    const result = await invitationService.bulkResendFailed(projectId);
    await fetchInvitations();
    return result;
  }, [projectId, fetchInvitations]);

  // 통계 계산
  const stats = {
    total: invitations.length,
    pending: invitations.filter(i => i.status === 'pending').length,
    sent: invitations.filter(i => i.status === 'sent').length,
    opened: invitations.filter(i => i.status === 'opened').length,
    inProgress: invitations.filter(i => i.status === 'in_progress').length,
    completed: invitations.filter(i => i.status === 'completed').length,
    failed: invitations.filter(i => i.status === 'failed' || i.status === 'bounced').length,
    expired: invitations.filter(i => i.status === 'expired').length,
    completionRate: invitations.length > 0
      ? Math.round((invitations.filter(i => i.status === 'completed').length / invitations.length) * 100)
      : 0,
  };

  // 자동 새로고침
  useEffect(() => {
    fetchInvitations();
    if (autoRefresh) {
      intervalRef.current = setInterval(fetchInvitations, refreshInterval);
    }
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [fetchInvitations, autoRefresh, refreshInterval]);

  return {
    invitations,
    loading,
    error,
    stats,
    fetchInvitations,
    sendBulkInvitations,
    resendInvitation,
    cancelInvitation,
    extendInvitation,
    resendAllFailed,
  };
}
```

---

## 7. 이메일 발송 시스템

### 7.1 이메일 서비스 (Django)

```python
# backend: evaluations/services/email_service.py

from django.core.mail import EmailMultiAlternatives
from django.template.loader import render_to_string
from django.conf import settings

class InvitationEmailService:

    @classmethod
    def send_invitation(cls, invitation):
        """초대 이메일 발송"""
        context = {
            'evaluator_name': invitation.evaluator_name or '평가자',
            'project_title': invitation.project.title,
            'admin_name': invitation.created_by.get_full_name(),
            'evaluation_url': invitation.get_evaluation_url(),
            'access_key': invitation.access_key,
            'expires_at': invitation.expires_at.strftime('%Y-%m-%d'),
            'custom_message': invitation.custom_message,
        }

        subject = f'[AHP Platform] {invitation.project.title} - 평가 참여 요청'
        text_body = render_to_string('emails/invitation.txt', context)
        html_body = render_to_string('emails/invitation.html', context)

        email = EmailMultiAlternatives(
            subject=subject,
            body=text_body,
            from_email=settings.DEFAULT_FROM_EMAIL,
            to=[invitation.email],
            headers={'X-Invitation-ID': str(invitation.id)},
        )
        email.attach_alternative(html_body, 'text/html')

        try:
            email.send(fail_silently=False)
            InvitationStateMachine.transition(invitation, 'sent')
            invitation.sent_at = timezone.now()
            invitation.email_message_id = email.extra_headers.get('Message-ID', '')
            invitation.save(update_fields=['sent_at', 'email_message_id'])
        except Exception as e:
            InvitationStateMachine.transition(invitation, 'failed',
                                              reason=str(e))

    @classmethod
    def send_reminder(cls, invitation):
        """리마인더 이메일 발송"""
        context = {
            'evaluator_name': invitation.evaluator_name or '평가자',
            'project_title': invitation.project.title,
            'evaluation_url': invitation.get_evaluation_url(),
            'days_remaining': (invitation.expires_at - timezone.now()).days,
        }

        subject = f'[AHP Platform] 리마인더: {invitation.project.title} 평가 참여'
        text_body = render_to_string('emails/reminder.txt', context)
        html_body = render_to_string('emails/reminder.html', context)

        email = EmailMultiAlternatives(
            subject=subject,
            body=text_body,
            from_email=settings.DEFAULT_FROM_EMAIL,
            to=[invitation.email],
        )
        email.attach_alternative(html_body, 'text/html')
        email.send(fail_silently=False)
```

### 7.2 이메일 템플릿 (HTML)

관리자가 설정한 `custom_message`를 포함하되, 플랫폼 브랜딩 유지:

```
┌───────────────────────────────────────────┐
│  [AHP Platform 로고]                       │
│                                           │
│  안녕하세요, {evaluator_name}님            │
│                                           │
│  {admin_name}님이 "{project_title}"        │
│  프로젝트의 평가에 참여를 요청했습니다.      │
│                                           │
│  ┌─────────────────────────────────────┐  │
│  │ {custom_message}                    │  │
│  └─────────────────────────────────────┘  │
│                                           │
│  ┌─────────────────────────────────────┐  │
│  │     [평가 시작하기]  (버튼)          │  │
│  └─────────────────────────────────────┘  │
│                                           │
│  또는 아래 코드를 입력하세요:               │
│  액세스 키: KEY_A1B2C3D4                   │
│                                           │
│  만료일: 2026-03-09                        │
│                                           │
│  ─────────────────────────────────────    │
│  본 이메일은 AHP 의사결정 플랫폼에서       │
│  자동 발송되었습니다.                       │
└───────────────────────────────────────────┘
```

---

## 8. 토큰 검증 미들웨어

### 8.1 Django Middleware

```python
# backend: evaluations/middleware/invitation_auth.py

class InvitationTokenMiddleware:
    """
    평가자 접근 시 토큰/키를 검증하는 미들웨어.
    /api/v1/evaluations/ 하위 경로에만 적용.
    """

    PROTECTED_PATHS = ['/api/v1/evaluations/']

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        if not any(request.path.startswith(p) for p in self.PROTECTED_PATHS):
            return self.get_response(request)

        # 이미 인증된 사용자 (관리자 등) → 통과
        if request.user.is_authenticated:
            return self.get_response(request)

        # 토큰 또는 키 추출
        token = request.GET.get('token') or request.headers.get('X-Invitation-Token')
        key = request.GET.get('key') or request.headers.get('X-Access-Key')

        if token:
            result = InvitationTokenService.verify_token(token)
            if result['valid']:
                invitation = Invitation.objects.get(id=result['payload']['inv_id'])
                if invitation.status in ('cancelled', 'completed'):
                    return JsonResponse({'error': 'INVITATION_INACTIVE'}, status=403)
                # 최초 접근 시 상태 전이
                if invitation.status == 'sent':
                    InvitationStateMachine.transition(invitation, 'opened')
                    invitation.opened_at = timezone.now()
                    invitation.save(update_fields=['opened_at'])
                request.invitation = invitation
                return self.get_response(request)
            else:
                return JsonResponse({'error': result['error']}, status=401)

        elif key:
            try:
                invitation = Invitation.objects.get(
                    access_key=key,
                    expires_at__gt=timezone.now(),
                )
                if invitation.status in ('cancelled', 'completed'):
                    return JsonResponse({'error': 'INVITATION_INACTIVE'}, status=403)
                if invitation.status == 'sent':
                    InvitationStateMachine.transition(invitation, 'opened')
                request.invitation = invitation
                return self.get_response(request)
            except Invitation.DoesNotExist:
                return JsonResponse({'error': 'KEY_INVALID'}, status=401)

        return JsonResponse({'error': 'AUTH_REQUIRED'}, status=401)
```

### 8.2 프론트엔드 토큰 검증 (App.tsx 연동)

```typescript
// App.tsx 또는 useAuth.ts에서 URL 파라미터 처리 강화

// 기존 코드 (변경 금지):
//   ?project=ID, ?eval=ID, ?token=TOKEN, ?key=KEY

// 추가 로직:
async function handleEvaluatorAccess() {
  const params = new URLSearchParams(window.location.search);
  const token = params.get('token');
  const key = params.get('key');

  if (token) {
    const result = await invitationService.verifyToken(token);
    if (result.valid) {
      if (result.pin_required) {
        // PIN 입력 화면으로 이동
        setActiveTab('pin-verify');
        setPendingInvitation(result);
      } else {
        // 평가 화면으로 직접 이동
        setActiveTab('evaluator-workflow');
        setSelectedProjectId(String(result.project_id));
      }
    } else {
      // 만료/무효 → 에러 화면
      setActiveTab('invitation-error');
      setInvitationError(result);
    }
  } else if (key) {
    const result = await invitationService.verifyAccessKey(key);
    // ... 동일한 처리
  }
}
```

---

## 9. 리마인더 시스템

### 9.1 Django Celery Task

```python
# backend: evaluations/tasks.py

from celery import shared_task
from celery.schedules import crontab

@shared_task
def check_and_send_reminders():
    """매일 실행: 리마인더 조건 충족 초대에 이메일 발송"""
    active_reminders = ReminderSchedule.objects.filter(
        active=True,
        next_send_at__lte=timezone.now(),
    )

    for reminder in active_reminders:
        target_invitations = Invitation.objects.filter(
            project=reminder.project,
            status__in=reminder.target_statuses,
            reminder_count__lt=reminder.max_reminders,
        )

        for invitation in target_invitations:
            InvitationEmailService.send_reminder(invitation)
            invitation.reminder_count += 1
            invitation.last_reminder_at = timezone.now()
            invitation.save(update_fields=['reminder_count', 'last_reminder_at'])

        # 다음 발송 시각 계산
        if reminder.schedule_type == 'recurring':
            reminder.next_send_at += timedelta(days=reminder.interval_days)
            reminder.save(update_fields=['next_send_at'])
        else:
            reminder.active = False
            reminder.save(update_fields=['active'])


@shared_task
def expire_overdue_invitations():
    """매시간 실행: 만료된 초대 상태 변경"""
    expired = Invitation.objects.filter(
        expires_at__lte=timezone.now(),
        status__in=['pending', 'sent', 'opened', 'in_progress'],
    )
    for invitation in expired:
        InvitationStateMachine.transition(
            invitation, 'expired',
            reason='auto_expiry'
        )

# Celery Beat Schedule
CELERY_BEAT_SCHEDULE = {
    'check-reminders': {
        'task': 'evaluations.tasks.check_and_send_reminders',
        'schedule': crontab(hour='9', minute='0'),  # 매일 오전 9시
    },
    'expire-invitations': {
        'task': 'evaluations.tasks.expire_overdue_invitations',
        'schedule': crontab(minute='0'),  # 매시간 정각
    },
}
```

---

## 10. 구현 가이드 (Sonnet용)

### 10.1 구현 순서

```
Step 1: 타입 정의 (30분)
├── src/types/invitation.ts 생성

Step 2: 서비스 레이어 (1시간)
├── src/services/invitationService.ts 생성

Step 3: 커스텀 Hook (1시간)
├── src/hooks/useInvitations.ts 생성

Step 4: 기존 컴포넌트 수정 (2시간)
├── InviteEvaluators.tsx → invitationService 사용으로 전환
├── InvitationHistory.tsx → 개별 상태 추적 강화
└── App.tsx → handleEvaluatorAccess() 토큰 검증 추가

Step 5: 신규 컴포넌트 (3시간)
├── InvitationTracker.tsx → 실시간 상태 대시보드
└── ReminderManager.tsx → 리마인더 설정 UI

Step 6: Django 백엔드 (별도 작업)
├── models/invitation.py
├── services/invitation_token_service.py
├── services/invitation_state_machine.py
├── services/email_service.py
├── middleware/invitation_auth.py
├── views/invitation_views.py
├── urls.py
└── tasks.py (Celery)
```

### 10.2 주의사항

1. **기존 URL 파라미터 처리 절대 변경 금지** (`?project=ID`, `?token=TOKEN`, `?key=KEY`)
2. **localStorage 키 충돌 방지** — 새 키는 `ahp_invitation_` 접두사 사용
3. **에러 시 graceful degradation** — 백엔드 미응답 시 기존 로컬 방식으로 fallback
4. **GitHub Pages 제약** — React Router DOM 미사용, 탭 기반 유지
5. **npm run build 반드시 성공해야 함** — TypeScript 에러 0개

---

## 부록: 보안 체크리스트

- [ ] INVITATION_SECRET_KEY를 AUTH JWT와 분리
- [ ] 토큰에 이메일 원문 포함하지 않음 (해시만)
- [ ] Rate limiting: 초대 발송 분당 10회 제한
- [ ] CORS: 허용 origin에 GitHub Pages 도메인만
- [ ] 만료된 토큰 즉시 거부 (서버 측)
- [ ] access_key brute-force 방지 (5회 실패 시 10분 lockout)
- [ ] 감사 로그에 IP, User-Agent 기록
- [ ] PIN 코드 해싱 저장 (bcrypt)
- [ ] 이메일 발송 로그 30일 보관 후 삭제
