# Phase 3a: 결제 시스템 아키텍처 설계

**작성자**: Claude Opus 4.6 (설계/알고리즘 담당)
**작성일**: 2026-02-23
**상태**: 설계 완료 → Sonnet 구현 대기
**현재 완성도**: 0% → **목표: 100%**

---

## 1. 현황 분석

### 1.1 기존 구현

| 기능 | 파일 | 상태 |
|------|------|------|
| 구독 서비스 클래스 | `services/subscriptionService.ts` | ✅ API 호출 구조 |
| 구독 페이지 | `pages/SubscriptionPage.tsx` | ✅ UI 존재 |
| 요금제 정보 (하드코딩) | `services/subscriptionService.ts:100-123` | ⚠️ 서버 미연동 |
| 사용량 추적 API 호출 | `services/subscriptionService.ts` | ✅ 엔드포인트 정의 |
| 결제 관리 페이지 | `superadmin/PaymentOptionsPage.tsx` | ✅ UI 존재 |

### 1.2 미구현

| 기능 | 상태 |
|------|------|
| Stripe 연동 (SDK, Checkout, Portal) | ❌ 미구현 |
| 결제 상태 머신 (생성→결제→활성→해지) | ❌ 미구현 |
| Webhook 처리 (결제 성공/실패/환불) | ❌ 미구현 |
| 청구서 생성 및 조회 | ❌ 미구현 |
| 무료 체험(Trial) 관리 | ❌ 미구현 |
| 프로모션 코드/쿠폰 | ❌ 미구현 |
| 사용량 기반 과금 (AI 크레딧) | ❌ 미구현 |
| PCI DSS 준수 | ❌ 미구현 |

### 1.3 하드코딩된 요금제 (현재)

```
Basic: $29/월 — 5 관리자, 3 프로젝트, 50 설문, 10 평가자
Professional: $89/월 — 20 관리자, 10 프로젝트, 200 설문, 50 평가자
Enterprise: $299/월 — 무제한
```

---

## 2. 아키텍처 설계

### 2.1 전체 구조

```
┌───────────────────────────────────────────────────┐
│                React Frontend                      │
│                                                   │
│  ┌───────────┐  ┌──────────┐  ┌────────────────┐  │
│  │ Pricing   │  │ Checkout │  │ Subscription   │  │
│  │ Page      │  │ Page     │  │ Management     │  │
│  └─────┬─────┘  └────┬─────┘  └───────┬────────┘  │
│        │              │                │            │
│  ┌─────▼──────────────▼────────────────▼────────┐  │
│  │         Stripe.js (Elements SDK)              │  │
│  │  - CardElement / PaymentElement               │  │
│  │  - Stripe Checkout Session redirect           │  │
│  │  - Customer Portal redirect                   │  │
│  └──────────────────────┬───────────────────────┘  │
│                         │                           │
└─────────────────────────┼───────────────────────────┘
                          │ HTTPS
┌─────────────────────────▼───────────────────────────┐
│              Django Backend                          │
│                                                     │
│  ┌──────────────────────────────────────────────┐   │
│  │              Billing App                      │   │
│  │                                              │   │
│  │  ┌────────────┐  ┌──────────────┐            │   │
│  │  │ Views      │  │ Webhook      │            │   │
│  │  │ (REST API) │  │ Handler      │            │   │
│  │  └─────┬──────┘  └──────┬───────┘            │   │
│  │        │                │                     │   │
│  │  ┌─────▼────────────────▼─────────────────┐  │   │
│  │  │      Billing Service Layer              │  │   │
│  │  │  - 구독 생성/변경/해지                    │  │   │
│  │  │  - 결제 상태 머신                        │  │   │
│  │  │  - 사용량 추적                           │  │   │
│  │  │  - 청구서 생성                           │  │   │
│  │  └─────┬──────────────────────────────────┘  │   │
│  │        │                                     │   │
│  │  ┌─────▼──────────────────────────────────┐  │   │
│  │  │      Stripe Python SDK (stripe)         │  │   │
│  │  └─────┬──────────────────────────────────┘  │   │
│  └────────┼──────────────────────────────────────┘   │
│           │                                         │
└───────────┼─────────────────────────────────────────┘
            │ HTTPS
    ┌───────▼───────┐
    │  Stripe API   │
    │  - Products   │
    │  - Prices     │
    │  - Customers  │
    │  - Subscriptions│
    │  - Invoices   │
    │  - Webhooks   │
    └───────────────┘
```

### 2.2 핵심 원칙

1. **카드 정보는 절대 서버를 거치지 않음** — Stripe Elements가 직접 처리 (PCI DSS 준수)
2. **Stripe이 결제의 진실 소스(Source of Truth)** — DB는 캐시 역할
3. **Webhook으로 상태 동기화** — 프론트엔드 폴링 최소화
4. **멱등성 보장** — Webhook 중복 수신 처리

---

## 3. 요금제 설계

### 3.1 플랜 구조

```
Free (무료)
├── 프로젝트: 1개
├── 평가자: 5명/프로젝트
├── 기준: 7개
├── 대안: 5개
├── AI 기능: ❌
├── 고급 분석: ❌
├── 내보내기: ❌
└── 실시간 협업: ❌

Starter ($19/월 또는 $190/년)
├── 프로젝트: 3개
├── 평가자: 15명/프로젝트
├── 기준: 15개
├── 대안: 10개
├── AI 기능: 기본 (월 50 크레딧)
├── 고급 분석: 민감도만
├── 내보내기: Excel
└── 실시간 협업: ❌

Professional ($49/월 또는 $490/년)
├── 프로젝트: 10개
├── 평가자: 50명/프로젝트
├── 기준: 30개
├── 대안: 20개
├── AI 기능: 전체 (월 200 크레딧)
├── 고급 분석: 전체
├── 내보내기: Excel + PDF
└── 실시간 협업: ✅

Enterprise ($149/월 또는 $1,490/년)
├── 프로젝트: 무제한
├── 평가자: 무제한
├── 기준: 무제한
├── 대안: 무제한
├── AI 기능: 무제한
├── 고급 분석: 전체 + API
├── 내보내기: 전체 + 브랜딩 커스텀
├── 실시간 협업: ✅
├── 우선 지원: ✅
└── SSO: ✅
```

### 3.2 Stripe Product/Price 매핑

```python
# Stripe에 생성할 Product & Price 구조

STRIPE_PRODUCTS = {
    'starter': {
        'name': 'AHP Platform - Starter',
        'prices': {
            'monthly': {'amount': 1900, 'currency': 'usd', 'interval': 'month'},
            'yearly':  {'amount': 19000, 'currency': 'usd', 'interval': 'year'},
        }
    },
    'professional': {
        'name': 'AHP Platform - Professional',
        'prices': {
            'monthly': {'amount': 4900, 'currency': 'usd', 'interval': 'month'},
            'yearly':  {'amount': 49000, 'currency': 'usd', 'interval': 'year'},
        }
    },
    'enterprise': {
        'name': 'AHP Platform - Enterprise',
        'prices': {
            'monthly': {'amount': 14900, 'currency': 'usd', 'interval': 'month'},
            'yearly':  {'amount': 149000, 'currency': 'usd', 'interval': 'year'},
        }
    },
}
```

---

## 4. 결제 상태 머신

### 4.1 구독 상태 전이도

```
                    ┌──────────────┐
         가입 ──────▶│   TRIALING   │ (14일 무료 체험)
                    └──────┬───────┘
                           │ 체험 종료 + 결제 성공
                    ┌──────▼───────┐
              ┌─────│    ACTIVE    │◀────────┐
              │     └──────┬───────┘         │
              │            │                 │
              │     결제 실패                  │ 결제 재시도 성공
              │            │                 │
              │     ┌──────▼───────┐         │
              │     │ PAST_DUE     │─────────┘
              │     └──────┬───────┘
              │            │ 3회 실패
              │     ┌──────▼───────┐
              │     │  UNPAID      │
              │     └──────┬───────┘
              │            │ 30일 경과
              │     ┌──────▼───────┐
              │     │  CANCELED    │
              │     └──────────────┘
              │
              │ 사용자 해지 요청
              │     ┌──────────────┐
              └─────▶│ CANCEL_      │ (기간 만료까지 유지)
                    │ SCHEDULED    │
                    └──────┬───────┘
                           │ 기간 종료
                    ┌──────▼───────┐
                    │  CANCELED    │
                    └──────────────┘
```

### 4.2 상태 정의

```typescript
// src/types/billing.ts

type SubscriptionStatus =
  | 'trialing'          // 무료 체험 중
  | 'active'            // 활성 구독
  | 'past_due'          // 결제 연체 (재시도 중)
  | 'unpaid'            // 미결제 (기능 제한)
  | 'cancel_scheduled'  // 해지 예약 (기간 만료까지 사용 가능)
  | 'canceled'          // 해지 완료
  | 'incomplete'        // 최초 결제 미완료
  | 'paused';           // 일시 중지

type PaymentStatus =
  | 'pending'     // 결제 대기
  | 'processing'  // 처리 중
  | 'succeeded'   // 성공
  | 'failed'      // 실패
  | 'refunded'    // 환불 완료
  | 'disputed';   // 분쟁 중
```

---

## 5. Django 백엔드 설계

### 5.1 데이터 모델

```python
# backend: billing/models.py

class StripeCustomer(models.Model):
    """Stripe Customer ↔ Django User 매핑"""
    user = models.OneToOneField('auth.User', on_delete=models.CASCADE,
                                related_name='stripe_customer')
    stripe_customer_id = models.CharField(max_length=255, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        indexes = [models.Index(fields=['stripe_customer_id'])]


class Subscription(models.Model):
    """구독 정보"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    user = models.ForeignKey('auth.User', on_delete=models.CASCADE,
                             related_name='subscriptions')
    stripe_subscription_id = models.CharField(max_length=255, unique=True)
    stripe_price_id = models.CharField(max_length=255)

    plan = models.CharField(max_length=20, choices=[
        ('free', 'Free'),
        ('starter', 'Starter'),
        ('professional', 'Professional'),
        ('enterprise', 'Enterprise'),
    ])
    billing_interval = models.CharField(max_length=10, choices=[
        ('month', 'Monthly'), ('year', 'Yearly'),
    ])

    status = models.CharField(max_length=20, default='incomplete')
    trial_end = models.DateTimeField(null=True)
    current_period_start = models.DateTimeField(null=True)
    current_period_end = models.DateTimeField(null=True)
    cancel_at = models.DateTimeField(null=True)        # 해지 예정일
    canceled_at = models.DateTimeField(null=True)       # 해지 실행일

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', 'status']),
            models.Index(fields=['stripe_subscription_id']),
        ]


class Invoice(models.Model):
    """청구서"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    subscription = models.ForeignKey(Subscription, on_delete=models.CASCADE,
                                     related_name='invoices')
    stripe_invoice_id = models.CharField(max_length=255, unique=True)

    amount = models.IntegerField()           # 센트 단위
    currency = models.CharField(max_length=3, default='usd')
    status = models.CharField(max_length=20)  # draft, open, paid, void, uncollectible
    invoice_url = models.URLField(blank=True)
    invoice_pdf = models.URLField(blank=True)
    hosted_invoice_url = models.URLField(blank=True)

    period_start = models.DateTimeField()
    period_end = models.DateTimeField()
    paid_at = models.DateTimeField(null=True)
    created_at = models.DateTimeField(auto_now_add=True)


class UsageRecord(models.Model):
    """AI 크레딧 사용량 추적"""
    user = models.ForeignKey('auth.User', on_delete=models.CASCADE)
    feature = models.CharField(max_length=50)  # 'ai_paper', 'ai_interpretation', ...
    credits_used = models.IntegerField(default=1)
    timestamp = models.DateTimeField(auto_now_add=True)
    metadata = models.JSONField(default=dict)

    class Meta:
        indexes = [models.Index(fields=['user', 'timestamp'])]


class PromoCode(models.Model):
    """프로모션 코드"""
    code = models.CharField(max_length=50, unique=True)
    stripe_coupon_id = models.CharField(max_length=255)
    discount_type = models.CharField(max_length=10, choices=[
        ('percent', 'Percentage'), ('amount', 'Fixed Amount'),
    ])
    discount_value = models.IntegerField()  # 퍼센트 또는 센트
    max_uses = models.IntegerField(null=True)
    use_count = models.IntegerField(default=0)
    valid_until = models.DateTimeField(null=True)
    active = models.BooleanField(default=True)
```

### 5.2 API 엔드포인트

| Method | Endpoint | 설명 | 권한 |
|--------|----------|------|------|
| `GET` | `/api/v1/billing/plans/` | 요금제 목록 | public |
| `POST` | `/api/v1/billing/checkout/` | Stripe Checkout 세션 생성 | auth |
| `POST` | `/api/v1/billing/portal/` | Stripe Customer Portal URL | auth |
| `GET` | `/api/v1/billing/subscription/` | 현재 구독 정보 | auth |
| `POST` | `/api/v1/billing/subscription/cancel/` | 구독 해지 예약 | auth |
| `POST` | `/api/v1/billing/subscription/reactivate/` | 해지 예약 취소 | auth |
| `POST` | `/api/v1/billing/subscription/change-plan/` | 플랜 변경 (업/다운그레이드) | auth |
| `GET` | `/api/v1/billing/invoices/` | 청구서 목록 | auth |
| `GET` | `/api/v1/billing/usage/` | 사용량 조회 | auth |
| `POST` | `/api/v1/billing/promo/validate/` | 프로모션 코드 유효성 검증 | auth |
| `POST` | `/api/v1/billing/webhooks/stripe/` | Stripe Webhook 수신 | stripe |

### 5.3 핵심 서비스 (Django)

```python
# backend: billing/services.py

import stripe
from django.conf import settings

stripe.api_key = settings.STRIPE_SECRET_KEY

class BillingService:

    @staticmethod
    def get_or_create_customer(user):
        """Django User에 대응하는 Stripe Customer 조회/생성"""
        try:
            sc = StripeCustomer.objects.get(user=user)
            return sc.stripe_customer_id
        except StripeCustomer.DoesNotExist:
            customer = stripe.Customer.create(
                email=user.email,
                name=user.get_full_name() or user.username,
                metadata={'django_user_id': str(user.id)},
            )
            StripeCustomer.objects.create(
                user=user,
                stripe_customer_id=customer.id,
            )
            return customer.id

    @staticmethod
    def create_checkout_session(user, price_id, success_url, cancel_url, promo_code=None):
        """Stripe Checkout 세션 생성 → 결제 페이지 URL 반환"""
        customer_id = BillingService.get_or_create_customer(user)

        params = {
            'customer': customer_id,
            'line_items': [{'price': price_id, 'quantity': 1}],
            'mode': 'subscription',
            'success_url': success_url + '?session_id={CHECKOUT_SESSION_ID}',
            'cancel_url': cancel_url,
            'subscription_data': {
                'trial_period_days': 14,
                'metadata': {'django_user_id': str(user.id)},
            },
            'allow_promotion_codes': True,
        }

        if promo_code:
            params['discounts'] = [{'coupon': promo_code}]
            del params['allow_promotion_codes']

        session = stripe.checkout.Session.create(**params)
        return session.url

    @staticmethod
    def create_portal_session(user, return_url):
        """Stripe Customer Portal 세션 생성 → 구독 관리 URL 반환"""
        customer_id = BillingService.get_or_create_customer(user)
        session = stripe.billing_portal.Session.create(
            customer=customer_id,
            return_url=return_url,
        )
        return session.url

    @staticmethod
    def cancel_subscription(subscription):
        """구독 해지 예약 (기간 만료 시 해지)"""
        stripe.Subscription.modify(
            subscription.stripe_subscription_id,
            cancel_at_period_end=True,
        )
        subscription.status = 'cancel_scheduled'
        subscription.cancel_at = subscription.current_period_end
        subscription.save(update_fields=['status', 'cancel_at', 'updated_at'])

    @staticmethod
    def reactivate_subscription(subscription):
        """해지 예약 취소 → 활성 복원"""
        stripe.Subscription.modify(
            subscription.stripe_subscription_id,
            cancel_at_period_end=False,
        )
        subscription.status = 'active'
        subscription.cancel_at = None
        subscription.save(update_fields=['status', 'cancel_at', 'updated_at'])

    @staticmethod
    def change_plan(subscription, new_price_id):
        """플랜 업/다운그레이드 (즉시 적용, 비례 계산)"""
        stripe_sub = stripe.Subscription.retrieve(
            subscription.stripe_subscription_id
        )
        stripe.Subscription.modify(
            subscription.stripe_subscription_id,
            items=[{
                'id': stripe_sub['items']['data'][0].id,
                'price': new_price_id,
            }],
            proration_behavior='always_invoice',  # 즉시 비례 청구
        )

    @staticmethod
    def check_usage_limit(user, feature):
        """사용량 제한 확인"""
        subscription = Subscription.objects.filter(
            user=user, status__in=['active', 'trialing']
        ).first()

        if not subscription:
            plan = 'free'
        else:
            plan = subscription.plan

        limits = PLAN_LIMITS[plan]
        current_month = timezone.now().replace(day=1)
        used = UsageRecord.objects.filter(
            user=user,
            feature=feature,
            timestamp__gte=current_month,
        ).aggregate(total=models.Sum('credits_used'))['total'] or 0

        limit = limits.get(f'{feature}_credits', 0)
        return {
            'allowed': used < limit or limit == -1,  # -1 = 무제한
            'used': used,
            'limit': limit,
            'remaining': max(0, limit - used) if limit != -1 else -1,
        }


PLAN_LIMITS = {
    'free': {
        'projects': 1,
        'evaluators_per_project': 5,
        'criteria': 7,
        'alternatives': 5,
        'ai_credits': 0,
    },
    'starter': {
        'projects': 3,
        'evaluators_per_project': 15,
        'criteria': 15,
        'alternatives': 10,
        'ai_credits': 50,
    },
    'professional': {
        'projects': 10,
        'evaluators_per_project': 50,
        'criteria': 30,
        'alternatives': 20,
        'ai_credits': 200,
    },
    'enterprise': {
        'projects': -1,        # 무제한
        'evaluators_per_project': -1,
        'criteria': -1,
        'alternatives': -1,
        'ai_credits': -1,
    },
}
```

### 5.4 Webhook 핸들러

```python
# backend: billing/webhooks.py

import stripe
from django.http import HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST

@csrf_exempt
@require_POST
def stripe_webhook(request):
    payload = request.body
    sig_header = request.META.get('HTTP_STRIPE_SIGNATURE')

    try:
        event = stripe.Webhook.construct_event(
            payload, sig_header, settings.STRIPE_WEBHOOK_SECRET
        )
    except (ValueError, stripe.error.SignatureVerificationError):
        return HttpResponse(status=400)

    # 멱등성: 이미 처리한 이벤트 스킵
    if WebhookEvent.objects.filter(stripe_event_id=event.id).exists():
        return HttpResponse(status=200)

    # 이벤트 저장
    WebhookEvent.objects.create(
        stripe_event_id=event.id,
        event_type=event.type,
        data=event.data,
    )

    handlers = {
        'checkout.session.completed':        handle_checkout_completed,
        'customer.subscription.created':     handle_subscription_created,
        'customer.subscription.updated':     handle_subscription_updated,
        'customer.subscription.deleted':     handle_subscription_deleted,
        'invoice.paid':                      handle_invoice_paid,
        'invoice.payment_failed':            handle_invoice_payment_failed,
        'customer.subscription.trial_will_end': handle_trial_ending,
    }

    handler = handlers.get(event.type)
    if handler:
        handler(event.data.object)

    return HttpResponse(status=200)


def handle_checkout_completed(session):
    """결제 완료 시 구독 생성/갱신"""
    user_id = session.metadata.get('django_user_id')
    if not user_id:
        return

    stripe_sub = stripe.Subscription.retrieve(session.subscription)
    user = User.objects.get(id=user_id)

    Subscription.objects.update_or_create(
        stripe_subscription_id=stripe_sub.id,
        defaults={
            'user': user,
            'stripe_price_id': stripe_sub['items']['data'][0].price.id,
            'plan': get_plan_from_price(stripe_sub['items']['data'][0].price.id),
            'billing_interval': stripe_sub['items']['data'][0].price.recurring.interval,
            'status': stripe_sub.status,
            'trial_end': datetime.fromtimestamp(stripe_sub.trial_end) if stripe_sub.trial_end else None,
            'current_period_start': datetime.fromtimestamp(stripe_sub.current_period_start),
            'current_period_end': datetime.fromtimestamp(stripe_sub.current_period_end),
        }
    )


def handle_subscription_updated(subscription):
    """구독 상태 변경 동기화"""
    try:
        sub = Subscription.objects.get(stripe_subscription_id=subscription.id)
        sub.status = subscription.status
        sub.current_period_start = datetime.fromtimestamp(subscription.current_period_start)
        sub.current_period_end = datetime.fromtimestamp(subscription.current_period_end)

        if subscription.cancel_at:
            sub.cancel_at = datetime.fromtimestamp(subscription.cancel_at)
            sub.status = 'cancel_scheduled'

        if subscription.canceled_at:
            sub.canceled_at = datetime.fromtimestamp(subscription.canceled_at)

        sub.save()
    except Subscription.DoesNotExist:
        pass


def handle_invoice_paid(invoice):
    """청구서 결제 완료"""
    try:
        sub = Subscription.objects.get(stripe_subscription_id=invoice.subscription)
        Invoice.objects.update_or_create(
            stripe_invoice_id=invoice.id,
            defaults={
                'subscription': sub,
                'amount': invoice.amount_paid,
                'currency': invoice.currency,
                'status': 'paid',
                'invoice_url': invoice.hosted_invoice_url or '',
                'invoice_pdf': invoice.invoice_pdf or '',
                'period_start': datetime.fromtimestamp(invoice.period_start),
                'period_end': datetime.fromtimestamp(invoice.period_end),
                'paid_at': timezone.now(),
            }
        )
    except Subscription.DoesNotExist:
        pass


def handle_invoice_payment_failed(invoice):
    """결제 실패 → 이메일 알림"""
    try:
        sub = Subscription.objects.get(stripe_subscription_id=invoice.subscription)
        sub.status = 'past_due'
        sub.save(update_fields=['status', 'updated_at'])

        # 사용자에게 결제 실패 이메일 발송
        send_payment_failed_email(sub.user, invoice)
    except Subscription.DoesNotExist:
        pass
```

---

## 6. 프론트엔드 설계

### 6.1 서비스 레이어

```typescript
// src/services/billingService.ts

import api from './api';

export interface Plan {
  id: string;
  name: string;
  description: string;
  prices: {
    monthly: { id: string; amount: number; currency: string };
    yearly: { id: string; amount: number; currency: string };
  };
  features: string[];
  limits: PlanLimits;
  recommended?: boolean;
}

export interface PlanLimits {
  projects: number;            // -1 = 무제한
  evaluatorsPerProject: number;
  criteria: number;
  alternatives: number;
  aiCredits: number;
}

export interface SubscriptionInfo {
  id: string;
  plan: string;
  status: SubscriptionStatus;
  billingInterval: 'month' | 'year';
  currentPeriodEnd: string;
  cancelAt: string | null;
  trialEnd: string | null;
}

export interface InvoiceInfo {
  id: string;
  amount: number;
  currency: string;
  status: string;
  invoiceUrl: string;
  invoicePdf: string;
  periodStart: string;
  periodEnd: string;
  paidAt: string | null;
}

class BillingService {

  async getPlans(): Promise<Plan[]> {
    const response = await api.get('/api/v1/billing/plans/');
    return response.data;
  }

  async createCheckout(priceId: string, promoCode?: string): Promise<string> {
    const baseUrl = window.location.origin + '/ahp_app';
    const response = await api.post('/api/v1/billing/checkout/', {
      price_id: priceId,
      success_url: `${baseUrl}/?tab=subscription&status=success`,
      cancel_url: `${baseUrl}/?tab=subscription&status=canceled`,
      promo_code: promoCode,
    });
    return response.data.checkout_url;
  }

  async openCustomerPortal(): Promise<string> {
    const baseUrl = window.location.origin + '/ahp_app';
    const response = await api.post('/api/v1/billing/portal/', {
      return_url: `${baseUrl}/?tab=subscription`,
    });
    return response.data.portal_url;
  }

  async getSubscription(): Promise<SubscriptionInfo | null> {
    try {
      const response = await api.get('/api/v1/billing/subscription/');
      return response.data;
    } catch {
      return null;
    }
  }

  async cancelSubscription(): Promise<void> {
    await api.post('/api/v1/billing/subscription/cancel/');
  }

  async reactivateSubscription(): Promise<void> {
    await api.post('/api/v1/billing/subscription/reactivate/');
  }

  async changePlan(newPriceId: string): Promise<void> {
    await api.post('/api/v1/billing/subscription/change-plan/', {
      new_price_id: newPriceId,
    });
  }

  async getInvoices(): Promise<InvoiceInfo[]> {
    const response = await api.get('/api/v1/billing/invoices/');
    return response.data;
  }

  async getUsage(): Promise<{
    aiCredits: { used: number; limit: number; remaining: number };
    projects: { used: number; limit: number };
  }> {
    const response = await api.get('/api/v1/billing/usage/');
    return response.data;
  }

  async validatePromoCode(code: string): Promise<{
    valid: boolean;
    discountType?: 'percent' | 'amount';
    discountValue?: number;
    message?: string;
  }> {
    const response = await api.post('/api/v1/billing/promo/validate/', { code });
    return response.data;
  }
}

export default new BillingService();
```

### 6.2 React Hook

```typescript
// src/hooks/useBilling.ts

import { useState, useEffect, useCallback } from 'react';
import billingService from '../services/billingService';
import type { Plan, SubscriptionInfo, InvoiceInfo } from '../services/billingService';

export function useBilling() {
  const [plans, setPlans] = useState<Plan[]>([]);
  const [subscription, setSubscription] = useState<SubscriptionInfo | null>(null);
  const [invoices, setInvoices] = useState<InvoiceInfo[]>([]);
  const [loading, setLoading] = useState(true);

  const fetchAll = useCallback(async () => {
    setLoading(true);
    try {
      const [plansData, subData, invoicesData] = await Promise.allSettled([
        billingService.getPlans(),
        billingService.getSubscription(),
        billingService.getInvoices(),
      ]);
      if (plansData.status === 'fulfilled') setPlans(plansData.value);
      if (subData.status === 'fulfilled') setSubscription(subData.value);
      if (invoicesData.status === 'fulfilled') setInvoices(invoicesData.value);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => { fetchAll(); }, [fetchAll]);

  const checkout = useCallback(async (priceId: string, promoCode?: string) => {
    const url = await billingService.createCheckout(priceId, promoCode);
    window.location.href = url;  // Stripe Checkout으로 리다이렉트
  }, []);

  const openPortal = useCallback(async () => {
    const url = await billingService.openCustomerPortal();
    window.location.href = url;  // Stripe Portal로 리다이렉트
  }, []);

  const cancel = useCallback(async () => {
    await billingService.cancelSubscription();
    await fetchAll();
  }, [fetchAll]);

  const reactivate = useCallback(async () => {
    await billingService.reactivateSubscription();
    await fetchAll();
  }, [fetchAll]);

  const currentPlan = plans.find(p => p.id === subscription?.plan) || null;
  const isActive = subscription?.status === 'active' || subscription?.status === 'trialing';
  const isCancelScheduled = subscription?.status === 'cancel_scheduled';

  return {
    plans, subscription, invoices, loading,
    currentPlan, isActive, isCancelScheduled,
    checkout, openPortal, cancel, reactivate,
    refresh: fetchAll,
  };
}
```

### 6.3 Stripe Elements 통합

```typescript
// src/components/billing/StripeProvider.tsx

import { Elements } from '@stripe/react-stripe-js';
import { loadStripe } from '@stripe/stripe-js';

const stripePromise = loadStripe(process.env.REACT_APP_STRIPE_PUBLIC_KEY || '');

export const StripeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => (
  <Elements stripe={stripePromise}>
    {children}
  </Elements>
);
```

---

## 7. 환불 처리

### 7.1 환불 정책

```
- 구독 후 7일 이내: 전액 환불 가능
- 7일 이후: 비례 환불 (남은 기간 기준)
- AI 크레딧 50% 이상 사용 시: 환불 불가
- Enterprise 플랜: 30일 이내 전액 환불
```

### 7.2 Django 환불 서비스

```python
# backend: billing/services.py (추가)

class RefundService:

    @staticmethod
    def process_refund(subscription, reason):
        """환불 처리"""
        # 최신 결제된 청구서 조회
        latest_invoice = Invoice.objects.filter(
            subscription=subscription,
            status='paid',
        ).order_by('-paid_at').first()

        if not latest_invoice:
            raise RefundError('환불 가능한 청구서가 없습니다.')

        # 환불 금액 계산
        days_since_payment = (timezone.now() - latest_invoice.paid_at).days
        total_days = (latest_invoice.period_end - latest_invoice.period_start).days

        if days_since_payment <= 7:
            refund_amount = latest_invoice.amount  # 전액
        elif days_since_payment <= total_days:
            remaining_ratio = (total_days - days_since_payment) / total_days
            refund_amount = int(latest_invoice.amount * remaining_ratio)
        else:
            raise RefundError('환불 가능 기간이 지났습니다.')

        # AI 크레딧 사용량 확인
        usage = UsageRecord.objects.filter(
            user=subscription.user,
            timestamp__gte=latest_invoice.period_start,
        ).aggregate(total=models.Sum('credits_used'))['total'] or 0

        limit = PLAN_LIMITS[subscription.plan].get('ai_credits', 0)
        if limit > 0 and usage > limit * 0.5:
            raise RefundError('AI 크레딧 사용량이 50%를 초과하여 환불이 불가합니다.')

        # Stripe 환불 실행
        refund = stripe.Refund.create(
            payment_intent=latest_invoice.stripe_payment_intent_id,
            amount=refund_amount,
            reason='requested_by_customer',
            metadata={'django_user_id': str(subscription.user.id), 'reason': reason},
        )

        # 구독 즉시 해지
        stripe.Subscription.delete(subscription.stripe_subscription_id)
        subscription.status = 'canceled'
        subscription.canceled_at = timezone.now()
        subscription.save()

        return {
            'refund_id': refund.id,
            'amount': refund_amount,
            'currency': refund.currency,
        }
```

---

## 8. 보안 및 PCI DSS 준수

### 8.1 체크리스트

- [ ] **카드 정보 서버 미경유**: Stripe Elements 사용, 서버는 토큰만 처리
- [ ] **Stripe Webhook 서명 검증**: `STRIPE_WEBHOOK_SECRET`으로 검증
- [ ] **HTTPS 강제**: 모든 결제 관련 통신
- [ ] **환경 변수 관리**: `STRIPE_SECRET_KEY`, `STRIPE_WEBHOOK_SECRET`은 환경 변수
- [ ] **멱등성 보장**: Webhook 이벤트 ID로 중복 처리 방지
- [ ] **접근 제어**: 결제 API는 인증된 사용자만 접근
- [ ] **감사 로그**: 모든 결제 이벤트 기록
- [ ] **테스트 모드 분리**: 개발/스테이징은 Stripe 테스트 키 사용

### 8.2 환경 변수

```bash
# .env (프론트엔드)
REACT_APP_STRIPE_PUBLIC_KEY=pk_live_... (또는 pk_test_...)

# Django settings (백엔드)
STRIPE_SECRET_KEY=sk_live_...
STRIPE_WEBHOOK_SECRET=whsec_...
STRIPE_PUBLIC_KEY=pk_live_...
```

---

## 9. 구현 가이드 (Sonnet용)

### 9.1 파일 구조

```
src/
├── services/
│   └── billingService.ts           ← [신규]
├── hooks/
│   └── useBilling.ts               ← [신규]
├── types/
│   └── billing.ts                  ← [신규]
├── components/
│   └── billing/
│       ├── StripeProvider.tsx       ← [신규] Stripe Elements 래퍼
│       ├── PricingTable.tsx         ← [신규] 요금제 비교 테이블
│       ├── CheckoutButton.tsx       ← [신규] 결제 버튼
│       ├── SubscriptionManager.tsx  ← [신규] 구독 관리 대시보드
│       ├── InvoiceList.tsx          ← [신규] 청구서 목록
│       ├── UsageMeter.tsx           ← [신규] 사용량 표시
│       └── PromoCodeInput.tsx       ← [신규] 프로모션 코드 입력
└── pages/
    └── SubscriptionPage.tsx         ← [수정] billingService 연동
```

### 9.2 구현 순서

```
Step 1: 타입 및 서비스 (1시간)
├── src/types/billing.ts
└── src/services/billingService.ts

Step 2: React Hook (30분)
└── src/hooks/useBilling.ts

Step 3: Stripe Provider (30분)
└── src/components/billing/StripeProvider.tsx
    (npm install @stripe/stripe-js @stripe/react-stripe-js)

Step 4: UI 컴포넌트 (3시간)
├── PricingTable.tsx (요금제 비교)
├── CheckoutButton.tsx (결제 버튼 → Stripe Checkout 리다이렉트)
├── SubscriptionManager.tsx (현재 구독 상태, 해지/재활성화)
├── InvoiceList.tsx (청구서 목록 + PDF 다운로드)
├── UsageMeter.tsx (AI 크레딧 사용량 게이지)
└── PromoCodeInput.tsx (프로모션 코드 입력/검증)

Step 5: SubscriptionPage 수정 (1시간)
└── 기존 페이지를 새 컴포넌트들로 교체

Step 6: Django 백엔드 (별도 작업)
├── billing/models.py
├── billing/services.py
├── billing/webhooks.py
├── billing/views.py
├── billing/urls.py
└── Stripe 대시보드 설정 (Products, Prices, Webhooks)
```

### 9.3 주의사항

1. **Stripe 테스트 키 사용** — 개발 중에는 `pk_test_`, `sk_test_` 사용
2. **기존 subscriptionService.ts 유지** — 새 billingService.ts와 병행 후 점진적 교체
3. **GitHub Pages 제약** — Checkout은 Stripe 호스팅 페이지로 리다이렉트 (SPA 내부 결제 폼 아님)
4. **카드 정보는 서버를 절대 거치지 않음** — Stripe Checkout Session 방식 사용
5. **Webhook URL은 백엔드 직접 접근** — GitHub Pages와 무관, Django 서버로 직접 수신
6. **npm run build 성공 필수** — @stripe/stripe-js 추가 후 빌드 확인
