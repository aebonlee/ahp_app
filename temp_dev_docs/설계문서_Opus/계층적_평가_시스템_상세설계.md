# ğŸ—ï¸ ê³„ì¸µì  í‰ê°€ ì‹œìŠ¤í…œ ìƒì„¸ ì„¤ê³„
## ì‘ì„±ì¼: 2024-11-11
## ì‘ì„±ì: Claude Opus 4.1
## ë²„ì „: 1.0.0

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ëª©ì 
ê³„ì¸µì  í‰ê°€ ì‹œìŠ¤í…œì€ ë³µì¡í•œ ë‹¤ê¸°ì¤€ ì˜ì‚¬ê²°ì • ë¬¸ì œë¥¼ ì²´ê³„ì ìœ¼ë¡œ êµ¬ì¡°í™”í•˜ê³ , í‰ê°€ìê°€ ê° ê³„ì¸µì—ì„œ ìŒëŒ€ë¹„êµë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆë„ë¡ ì§€ì›í•˜ëŠ” í•µì‹¬ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### 1.2 í•µì‹¬ ê¸°ëŠ¥
- ë‹¤ì¸µ ê³„ì¸µ êµ¬ì¡° ìƒì„± ë° ê´€ë¦¬
- ê³„ì¸µë³„ ìŒëŒ€ë¹„êµ ìˆ˜í–‰
- ë¡œì»¬ ë° ê¸€ë¡œë²Œ ê°€ì¤‘ì¹˜ ê³„ì‚°
- ì¼ê´€ì„± ê²€ì¦ ë° í”¼ë“œë°±
- ê·¸ë£¹ í‰ê°€ í†µí•©

### 1.3 ê¸°ìˆ  ìš”êµ¬ì‚¬í•­
- **í”„ë¡ íŠ¸ì—”ë“œ**: React 18+, TypeScript 4.9+
- **ë°±ì—”ë“œ**: Django 5.0+, PostgreSQL 17.0
- **ì‹¤ì‹œê°„ í†µì‹ **: WebSocket (Django Channels)
- **ê³„ì‚° ì—”ì§„**: NumPy, SciPy

---

## 2. ê³„ì¸µ êµ¬ì¡° ë°ì´í„° ëª¨ë¸

### 2.1 ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```sql
-- ê³„ì¸µ êµ¬ì¡° ì •ì˜
CREATE TABLE hierarchy_nodes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    parent_id UUID REFERENCES hierarchy_nodes(id) ON DELETE CASCADE,
    node_type VARCHAR(20) NOT NULL CHECK (node_type IN ('goal', 'criterion', 'subcriterion', 'alternative')),
    level INTEGER NOT NULL CHECK (level >= 0 AND level <= 5),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    code VARCHAR(50), -- ì˜ˆ: C1, C1.1, C1.1.1
    position INTEGER NOT NULL DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    local_weight DECIMAL(10,8),
    global_weight DECIMAL(10,8),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT unique_node_code UNIQUE(project_id, code),
    CONSTRAINT unique_position UNIQUE(parent_id, position),
    INDEX idx_hierarchy_project (project_id),
    INDEX idx_hierarchy_parent (parent_id),
    INDEX idx_hierarchy_level (level)
);

-- ê³„ì¸µ ê°„ ê´€ê³„ ë§¤í•‘
CREATE TABLE hierarchy_relationships (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    parent_node_id UUID NOT NULL REFERENCES hierarchy_nodes(id) ON DELETE CASCADE,
    child_node_id UUID NOT NULL REFERENCES hierarchy_nodes(id) ON DELETE CASCADE,
    relationship_type VARCHAR(20) DEFAULT 'parent_child',
    strength DECIMAL(5,4) DEFAULT 1.0,
    
    CONSTRAINT unique_relationship UNIQUE(parent_node_id, child_node_id),
    INDEX idx_relationship_parent (parent_node_id),
    INDEX idx_relationship_child (child_node_id)
);

-- í‰ê°€ ë§¤íŠ¸ë¦­ìŠ¤ ì €ì¥
CREATE TABLE evaluation_matrices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    evaluator_id UUID REFERENCES evaluators(id) ON DELETE SET NULL,
    parent_node_id UUID NOT NULL REFERENCES hierarchy_nodes(id) ON DELETE CASCADE,
    matrix_type VARCHAR(20) NOT NULL DEFAULT 'pairwise',
    matrix_data JSONB NOT NULL,
    consistency_ratio DECIMAL(5,4),
    is_consistent BOOLEAN,
    eigen_value DECIMAL(10,8),
    eigen_vector JSONB,
    iteration_count INTEGER,
    calculation_method VARCHAR(20) DEFAULT 'power_method',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_matrix_project (project_id),
    INDEX idx_matrix_evaluator (evaluator_id),
    INDEX idx_matrix_parent (parent_node_id)
);

-- ê³„ì¸µë³„ í‰ê°€ ì§„í–‰ ìƒíƒœ
CREATE TABLE hierarchy_evaluation_progress (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    evaluator_id UUID NOT NULL REFERENCES evaluators(id) ON DELETE CASCADE,
    node_id UUID NOT NULL REFERENCES hierarchy_nodes(id) ON DELETE CASCADE,
    total_comparisons INTEGER NOT NULL,
    completed_comparisons INTEGER DEFAULT 0,
    is_completed BOOLEAN DEFAULT false,
    is_consistent BOOLEAN,
    consistency_ratio DECIMAL(5,4),
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    time_spent_seconds INTEGER,
    
    CONSTRAINT unique_evaluator_node UNIQUE(evaluator_id, node_id),
    INDEX idx_progress_evaluator (evaluator_id),
    INDEX idx_progress_node (node_id)
);
```

### 2.2 TypeScript ì¸í„°í˜ì´ìŠ¤

```typescript
// ê³„ì¸µ ë…¸ë“œ ì¸í„°í˜ì´ìŠ¤
export interface HierarchyNode {
  id: string;
  projectId: string;
  parentId: string | null;
  nodeType: 'goal' | 'criterion' | 'subcriterion' | 'alternative';
  level: number;
  name: string;
  description?: string;
  code: string; // ì˜ˆ: "C1", "C1.1"
  position: number;
  isActive: boolean;
  localWeight?: number;
  globalWeight?: number;
  children?: HierarchyNode[];
  metadata?: Record<string, any>;
}

// í‰ê°€ ë§¤íŠ¸ë¦­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
export interface EvaluationMatrix {
  id: string;
  projectId: string;
  evaluatorId?: string;
  parentNodeId: string;
  matrixType: 'pairwise' | 'direct' | 'rating';
  matrixData: number[][];
  consistencyRatio?: number;
  isConsistent?: boolean;
  eigenValue?: number;
  eigenVector?: number[];
  calculationMethod: 'power_method' | 'eigenvalue_method';
}

// ê³„ì¸µ êµ¬ì¡° ì „ì²´ ì¸í„°í˜ì´ìŠ¤
export interface HierarchicalStructure {
  projectId: string;
  goal: HierarchyNode;
  criteria: HierarchyNode[];
  subcriteria?: HierarchyNode[][];
  alternatives: HierarchyNode[];
  totalLevels: number;
  nodeCount: number;
  isComplete: boolean;
}
```

---

## 3. ê³„ì¸µì  í‰ê°€ í”„ë¡œì„¸ìŠ¤

### 3.1 í‰ê°€ í”Œë¡œìš°

```typescript
export class HierarchicalEvaluationFlow {
  private structure: HierarchicalStructure;
  private evaluator: Evaluator;
  private matrices: Map<string, EvaluationMatrix>;
  
  constructor(structure: HierarchicalStructure, evaluator: Evaluator) {
    this.structure = structure;
    this.evaluator = evaluator;
    this.matrices = new Map();
  }
  
  /**
   * í‰ê°€ í”„ë¡œì„¸ìŠ¤ ì´ˆê¸°í™”
   */
  async initializeEvaluation(): Promise<EvaluationSession> {
    const session: EvaluationSession = {
      id: generateUUID(),
      projectId: this.structure.projectId,
      evaluatorId: this.evaluator.id,
      startTime: new Date(),
      totalComparisons: this.calculateTotalComparisons(),
      completedComparisons: 0,
      currentLevel: 1,
      currentNodeId: this.structure.goal.id
    };
    
    // ê° ë ˆë²¨ë³„ í‰ê°€ ë§¤íŠ¸ë¦­ìŠ¤ ì´ˆê¸°í™”
    this.initializeMatrices();
    
    return session;
  }
  
  /**
   * ì´ í•„ìš”í•œ ë¹„êµ íšŸìˆ˜ ê³„ì‚°
   */
  private calculateTotalComparisons(): number {
    let total = 0;
    
    // Level 1: ëª©í‘œ ëŒ€ë¹„ ì£¼ê¸°ì¤€
    const n1 = this.structure.criteria.length;
    total += n1 * (n1 - 1) / 2;
    
    // Level 2: ê° ì£¼ê¸°ì¤€ ëŒ€ë¹„ í•˜ìœ„ê¸°ì¤€
    if (this.structure.subcriteria) {
      for (const subcriteriaGroup of this.structure.subcriteria) {
        const n2 = subcriteriaGroup.length;
        total += n2 * (n2 - 1) / 2;
      }
    }
    
    // Level 3+: ê° ë§ë‹¨ ê¸°ì¤€ ëŒ€ë¹„ ëŒ€ì•ˆ
    const leafCriteria = this.getLeafCriteria();
    const nAlternatives = this.structure.alternatives.length;
    total += leafCriteria.length * (nAlternatives * (nAlternatives - 1) / 2);
    
    return total;
  }
  
  /**
   * ë‹¤ìŒ í‰ê°€í•  ë…¸ë“œ ê°€ì ¸ì˜¤ê¸°
   */
  getNextEvaluationNode(): HierarchyNode | null {
    // BFS ë°©ì‹ìœ¼ë¡œ ë ˆë²¨ë³„ ìˆœì°¨ í‰ê°€
    const queue: HierarchyNode[] = [this.structure.goal];
    
    while (queue.length > 0) {
      const node = queue.shift()!;
      
      if (node.children && node.children.length > 1) {
        const matrixKey = `${node.id}_children`;
        
        if (!this.matrices.has(matrixKey) || !this.matrices.get(matrixKey)!.isConsistent) {
          return node;
        }
        
        queue.push(...node.children);
      }
    }
    
    return null;
  }
  
  /**
   * ìŒëŒ€ë¹„êµ ìˆ˜í–‰
   */
  async performPairwiseComparison(
    parentNode: HierarchyNode,
    comparisons: PairwiseComparison[]
  ): Promise<EvaluationResult> {
    const children = parentNode.children || [];
    const n = children.length;
    
    // ë¹„êµ ë§¤íŠ¸ë¦­ìŠ¤ ìƒì„±
    const matrix = this.buildComparisonMatrix(n, comparisons);
    
    // ì¼ê´€ì„± ê²€ì¦
    const consistency = await this.checkConsistency(matrix);
    
    // ê°€ì¤‘ì¹˜ ê³„ì‚°
    const weights = await this.calculateWeights(matrix);
    
    // ê²°ê³¼ ì €ì¥
    const evaluationMatrix: EvaluationMatrix = {
      id: generateUUID(),
      projectId: this.structure.projectId,
      evaluatorId: this.evaluator.id,
      parentNodeId: parentNode.id,
      matrixType: 'pairwise',
      matrixData: matrix,
      consistencyRatio: consistency.ratio,
      isConsistent: consistency.isConsistent,
      eigenValue: consistency.eigenValue,
      eigenVector: weights,
      calculationMethod: 'power_method'
    };
    
    this.matrices.set(`${parentNode.id}_children`, evaluationMatrix);
    
    // ë¡œì»¬ ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸
    children.forEach((child, index) => {
      child.localWeight = weights[index];
    });
    
    return {
      success: true,
      consistency: consistency,
      weights: weights,
      nextNode: this.getNextEvaluationNode()
    };
  }
  
  /**
   * ë¹„êµ ë§¤íŠ¸ë¦­ìŠ¤ êµ¬ì„±
   */
  private buildComparisonMatrix(
    size: number, 
    comparisons: PairwiseComparison[]
  ): number[][] {
    const matrix: number[][] = Array(size).fill(null)
      .map(() => Array(size).fill(1));
    
    for (const comp of comparisons) {
      const { i, j, value } = comp;
      matrix[i][j] = value;
      matrix[j][i] = 1 / value;
    }
    
    return matrix;
  }
}
```

### 3.2 ì¼ê´€ì„± ê²€ì¦ ì‹œìŠ¤í…œ

```typescript
export class ConsistencyValidator {
  // Saaty's Random Index
  private static readonly RANDOM_INDEX = [
    0, 0, 0.58, 0.90, 1.12, 1.24, 1.32, 1.41, 1.45, 1.49,
    1.51, 1.53, 1.56, 1.57, 1.59
  ];
  
  private static readonly CONSISTENCY_THRESHOLD = 0.10;
  
  /**
   * ì¼ê´€ì„± ë¹„ìœ¨ ê³„ì‚° ë° ê²€ì¦
   */
  static async validateConsistency(
    matrix: number[][]
  ): Promise<ConsistencyResult> {
    const n = matrix.length;
    
    if (n <= 2) {
      return {
        isConsistent: true,
        ratio: 0,
        index: 0,
        eigenValue: n,
        message: 'Matrix size â‰¤ 2, always consistent'
      };
    }
    
    // Power Methodë¡œ ì£¼ê³ ìœ ë²¡í„° ê³„ì‚°
    const { eigenVector, eigenValue } = await this.powerMethod(matrix);
    
    // Consistency Index (CI) ê³„ì‚°
    const CI = (eigenValue - n) / (n - 1);
    
    // Random Index (RI) ê°€ì ¸ì˜¤ê¸°
    const RI = this.RANDOM_INDEX[n - 1] || this.RANDOM_INDEX[14];
    
    // Consistency Ratio (CR) ê³„ì‚°
    const CR = RI > 0 ? CI / RI : 0;
    
    // ì¼ê´€ì„± ê²€ì¦
    const isConsistent = CR <= this.CONSISTENCY_THRESHOLD;
    
    // ë¶ˆì¼ê´€í•œ ìš”ì†Œ ì°¾ê¸°
    let inconsistentPairs: InconsistentPair[] = [];
    if (!isConsistent) {
      inconsistentPairs = this.findInconsistentPairs(matrix, eigenVector);
    }
    
    return {
      isConsistent,
      ratio: CR,
      index: CI,
      eigenValue,
      eigenVector,
      message: isConsistent 
        ? 'Matrix is consistent' 
        : `Inconsistent: CR = ${CR.toFixed(4)} > 0.10`,
      inconsistentPairs,
      suggestedAdjustments: inconsistentPairs.length > 0 
        ? this.suggestAdjustments(inconsistentPairs, matrix) 
        : undefined
    };
  }
  
  /**
   * Power Methodë¥¼ ì‚¬ìš©í•œ ì£¼ê³ ìœ ë²¡í„° ê³„ì‚°
   */
  private static async powerMethod(
    matrix: number[][], 
    maxIterations: number = 100,
    tolerance: number = 1e-7
  ): Promise<{eigenVector: number[], eigenValue: number}> {
    const n = matrix.length;
    let vector = Array(n).fill(1 / n);
    let eigenValue = 0;
    
    for (let iter = 0; iter < maxIterations; iter++) {
      const newVector = Array(n).fill(0);
      
      // Matrix multiplication: Av
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          newVector[i] += matrix[i][j] * vector[j];
        }
      }
      
      // Normalize
      const sum = newVector.reduce((a, b) => a + b, 0);
      for (let i = 0; i < n; i++) {
        newVector[i] /= sum;
      }
      
      // Check convergence
      let maxDiff = 0;
      for (let i = 0; i < n; i++) {
        maxDiff = Math.max(maxDiff, Math.abs(newVector[i] - vector[i]));
      }
      
      vector = newVector;
      
      if (maxDiff < tolerance) {
        break;
      }
    }
    
    // Calculate eigenvalue (Î»max)
    const Av = Array(n).fill(0);
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        Av[i] += matrix[i][j] * vector[j];
      }
    }
    
    eigenValue = 0;
    for (let i = 0; i < n; i++) {
      if (vector[i] > 0) {
        eigenValue += Av[i] / vector[i];
      }
    }
    eigenValue /= n;
    
    return { eigenVector: vector, eigenValue };
  }
  
  /**
   * ë¶ˆì¼ê´€í•œ ìŒ ì°¾ê¸°
   */
  private static findInconsistentPairs(
    matrix: number[][], 
    weights: number[]
  ): InconsistentPair[] {
    const pairs: InconsistentPair[] = [];
    const n = matrix.length;
    
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const actualRatio = matrix[i][j];
        const expectedRatio = weights[i] / weights[j];
        const deviation = Math.abs(Math.log(actualRatio / expectedRatio));
        
        if (deviation > 0.5) { // ìœ ì˜ë¯¸í•œ í¸ì°¨
          pairs.push({
            i, j,
            actualValue: actualRatio,
            expectedValue: expectedRatio,
            deviation
          });
        }
      }
    }
    
    // í¸ì°¨ê°€ í° ìˆœìœ¼ë¡œ ì •ë ¬
    return pairs.sort((a, b) => b.deviation - a.deviation).slice(0, 3);
  }
  
  /**
   * ì¡°ì • ì œì•ˆ
   */
  private static suggestAdjustments(
    inconsistentPairs: InconsistentPair[],
    matrix: number[][]
  ): SuggestedAdjustment[] {
    return inconsistentPairs.map(pair => {
      const { i, j, expectedValue } = pair;
      
      // Saaty ì²™ë„ì— ë§ê²Œ ë°˜ì˜¬ë¦¼
      const suggestedValue = this.roundToSaatyScale(expectedValue);
      
      return {
        position: [i, j],
        currentValue: matrix[i][j],
        suggestedValue,
        impact: this.estimateImpact(matrix, i, j, suggestedValue)
      };
    });
  }
  
  /**
   * Saaty ì²™ë„ë¡œ ë°˜ì˜¬ë¦¼
   */
  private static roundToSaatyScale(value: number): number {
    const scales = [1/9, 1/8, 1/7, 1/6, 1/5, 1/4, 1/3, 1/2, 
                   1, 2, 3, 4, 5, 6, 7, 8, 9];
    
    let minDiff = Infinity;
    let closest = 1;
    
    for (const scale of scales) {
      const diff = Math.abs(Math.log(value / scale));
      if (diff < minDiff) {
        minDiff = diff;
        closest = scale;
      }
    }
    
    return closest;
  }
  
  /**
   * ì¡°ì •ì˜ ì˜í–¥ë„ ì¶”ì •
   */
  private static estimateImpact(
    matrix: number[][], 
    i: number, 
    j: number, 
    newValue: number
  ): number {
    const testMatrix = matrix.map(row => [...row]);
    testMatrix[i][j] = newValue;
    testMatrix[j][i] = 1 / newValue;
    
    // ê°„ë‹¨í•œ ì˜í–¥ë„ ê³„ì‚° (CR ë³€í™”ëŸ‰)
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë” ì •êµí•œ ê³„ì‚° í•„ìš”
    return 0.05; // placeholder
  }
}
```

---

## 4. ê¸€ë¡œë²Œ ê°€ì¤‘ì¹˜ ê³„ì‚°

### 4.1 ê³„ì¸µ í†µí•© ì•Œê³ ë¦¬ì¦˜

```typescript
export class GlobalWeightCalculator {
  private structure: HierarchicalStructure;
  private localWeights: Map<string, number[]>;
  
  constructor(structure: HierarchicalStructure) {
    this.structure = structure;
    this.localWeights = new Map();
  }
  
  /**
   * ì „ì²´ ê³„ì¸µì˜ ê¸€ë¡œë²Œ ê°€ì¤‘ì¹˜ ê³„ì‚°
   */
  async calculateGlobalWeights(): Promise<GlobalWeightResult> {
    const results: GlobalWeightResult = {
      criteria: {},
      subcriteria: {},
      alternatives: {},
      rankings: []
    };
    
    // Level 1: ì£¼ê¸°ì¤€ ê¸€ë¡œë²Œ ê°€ì¤‘ì¹˜ (= ë¡œì»¬ ê°€ì¤‘ì¹˜)
    for (const criterion of this.structure.criteria) {
      results.criteria[criterion.id] = {
        name: criterion.name,
        localWeight: criterion.localWeight || 0,
        globalWeight: criterion.localWeight || 0
      };
    }
    
    // Level 2: í•˜ìœ„ê¸°ì¤€ ê¸€ë¡œë²Œ ê°€ì¤‘ì¹˜
    if (this.structure.subcriteria) {
      for (const criterion of this.structure.criteria) {
        const subcriteriaGroup = this.structure.subcriteria
          .flat()
          .filter(sc => sc.parentId === criterion.id);
        
        for (const subcriterion of subcriteriaGroup) {
          const parentGlobalWeight = results.criteria[criterion.id].globalWeight;
          const globalWeight = (subcriterion.localWeight || 0) * parentGlobalWeight;
          
          results.subcriteria[subcriterion.id] = {
            name: subcriterion.name,
            parentId: criterion.id,
            localWeight: subcriterion.localWeight || 0,
            globalWeight
          };
        }
      }
    }
    
    // Level 3+: ëŒ€ì•ˆë³„ ìµœì¢… ì ìˆ˜
    const leafCriteria = this.getLeafCriteria();
    
    for (const alternative of this.structure.alternatives) {
      let totalScore = 0;
      const scoreBreakdown: ScoreComponent[] = [];
      
      for (const leafCriterion of leafCriteria) {
        const criterionGlobalWeight = this.getCriterionGlobalWeight(leafCriterion);
        const alternativeLocalWeight = await this.getAlternativeWeight(
          leafCriterion.id, 
          alternative.id
        );
        
        const contribution = criterionGlobalWeight * alternativeLocalWeight;
        totalScore += contribution;
        
        scoreBreakdown.push({
          criterionId: leafCriterion.id,
          criterionName: leafCriterion.name,
          criterionWeight: criterionGlobalWeight,
          alternativeWeight: alternativeLocalWeight,
          contribution
        });
      }
      
      results.alternatives[alternative.id] = {
        name: alternative.name,
        totalScore,
        scoreBreakdown,
        rank: 0 // ë‚˜ì¤‘ì— ì„¤ì •
      };
    }
    
    // ìˆœìœ„ ê³„ì‚°
    results.rankings = this.calculateRankings(results.alternatives);
    
    return results;
  }
  
  /**
   * ë§ë‹¨ ê¸°ì¤€ ì°¾ê¸°
   */
  private getLeafCriteria(): HierarchyNode[] {
    const leaves: HierarchyNode[] = [];
    
    const traverse = (node: HierarchyNode) => {
      if (!node.children || node.children.length === 0) {
        if (node.nodeType === 'criterion' || node.nodeType === 'subcriterion') {
          leaves.push(node);
        }
      } else {
        node.children.forEach(traverse);
      }
    };
    
    this.structure.criteria.forEach(traverse);
    return leaves;
  }
  
  /**
   * ê¸°ì¤€ì˜ ê¸€ë¡œë²Œ ê°€ì¤‘ì¹˜ ê°€ì ¸ì˜¤ê¸°
   */
  private getCriterionGlobalWeight(criterion: HierarchyNode): number {
    let weight = criterion.localWeight || 0;
    let current = criterion;
    
    // ë¶€ëª¨ë¥¼ ë”°ë¼ ì˜¬ë¼ê°€ë©° ê°€ì¤‘ì¹˜ ê³±í•˜ê¸°
    while (current.parentId) {
      const parent = this.findNodeById(current.parentId);
      if (parent && parent.localWeight) {
        weight *= parent.localWeight;
      }
      current = parent!;
    }
    
    return weight;
  }
  
  /**
   * ëŒ€ì•ˆì˜ íŠ¹ì • ê¸°ì¤€ì— ëŒ€í•œ ê°€ì¤‘ì¹˜
   */
  private async getAlternativeWeight(
    criterionId: string, 
    alternativeId: string
  ): Promise<number> {
    const key = `${criterionId}_alternatives`;
    
    if (!this.localWeights.has(key)) {
      // DBì—ì„œ ë¡œë“œí•˜ê±°ë‚˜ ê¸°ë³¸ê°’ ì‚¬ìš©
      return 1 / this.structure.alternatives.length;
    }
    
    const weights = this.localWeights.get(key)!;
    const alternativeIndex = this.structure.alternatives
      .findIndex(alt => alt.id === alternativeId);
    
    return weights[alternativeIndex] || 0;
  }
  
  /**
   * ìˆœìœ„ ê³„ì‚°
   */
  private calculateRankings(
    alternatives: Record<string, AlternativeScore>
  ): RankingResult[] {
    const sorted = Object.entries(alternatives)
      .sort(([, a], [, b]) => b.totalScore - a.totalScore)
      .map(([id, data], index) => {
        data.rank = index + 1;
        return {
          rank: index + 1,
          alternativeId: id,
          name: data.name,
          score: data.totalScore,
          percentage: (data.totalScore * 100).toFixed(2) + '%'
        };
      });
    
    return sorted;
  }
  
  /**
   * IDë¡œ ë…¸ë“œ ì°¾ê¸°
   */
  private findNodeById(id: string): HierarchyNode | null {
    const queue: HierarchyNode[] = [
      this.structure.goal,
      ...this.structure.criteria
    ];
    
    while (queue.length > 0) {
      const node = queue.shift()!;
      
      if (node.id === id) {
        return node;
      }
      
      if (node.children) {
        queue.push(...node.children);
      }
    }
    
    return null;
  }
}
```

---

## 5. ì‹¤ì‹œê°„ ì§„í–‰ë¥  ì¶”ì 

### 5.1 ì§„í–‰ë¥  ì¶”ì  ì‹œìŠ¤í…œ

```typescript
export class ProgressTracker {
  private projectId: string;
  private evaluatorId: string;
  private totalNodes: number;
  private completedNodes: Set<string>;
  private nodeProgress: Map<string, NodeProgress>;
  private websocket: WebSocket;
  
  constructor(projectId: string, evaluatorId: string, websocket: WebSocket) {
    this.projectId = projectId;
    this.evaluatorId = evaluatorId;
    this.completedNodes = new Set();
    this.nodeProgress = new Map();
    this.websocket = websocket;
    this.totalNodes = 0;
  }
  
  /**
   * ì§„í–‰ë¥  ì´ˆê¸°í™”
   */
  async initialize(structure: HierarchicalStructure): Promise<void> {
    // í‰ê°€ê°€ í•„ìš”í•œ ëª¨ë“  ë…¸ë“œ ê³„ì‚°
    const evaluationNodes = this.getEvaluationNodes(structure);
    this.totalNodes = evaluationNodes.length;
    
    // ê° ë…¸ë“œë³„ ì§„í–‰ë¥  ì´ˆê¸°í™”
    for (const node of evaluationNodes) {
      const childCount = node.children?.length || 0;
      const totalComparisons = childCount * (childCount - 1) / 2;
      
      this.nodeProgress.set(node.id, {
        nodeId: node.id,
        nodeName: node.name,
        level: node.level,
        totalComparisons,
        completedComparisons: 0,
        isCompleted: false,
        isConsistent: false,
        consistencyRatio: 0,
        startedAt: null,
        completedAt: null,
        timeSpent: 0
      });
    }
    
    // ì´ˆê¸° ìƒíƒœ ì „ì†¡
    await this.broadcastProgress();
  }
  
  /**
   * ìŒëŒ€ë¹„êµ ì™„ë£Œ ì—…ë°ì´íŠ¸
   */
  async updateComparison(
    nodeId: string, 
    comparisonIndex: number,
    isComplete: boolean = false
  ): Promise<void> {
    const progress = this.nodeProgress.get(nodeId);
    
    if (!progress) {
      throw new Error(`Node ${nodeId} not found in progress tracker`);
    }
    
    // ì‹œì‘ ì‹œê°„ ê¸°ë¡
    if (!progress.startedAt) {
      progress.startedAt = new Date();
    }
    
    // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
    progress.completedComparisons = Math.min(
      comparisonIndex + 1,
      progress.totalComparisons
    );
    
    // ì™„ë£Œ ì²˜ë¦¬
    if (isComplete || progress.completedComparisons >= progress.totalComparisons) {
      progress.isCompleted = true;
      progress.completedAt = new Date();
      progress.timeSpent = progress.completedAt.getTime() - progress.startedAt!.getTime();
      this.completedNodes.add(nodeId);
    }
    
    // ì‹¤ì‹œê°„ ë¸Œë¡œë“œìºìŠ¤íŠ¸
    await this.broadcastProgress();
  }
  
  /**
   * ì¼ê´€ì„± ê²€ì¦ ê²°ê³¼ ì—…ë°ì´íŠ¸
   */
  async updateConsistency(
    nodeId: string,
    consistencyResult: ConsistencyResult
  ): Promise<void> {
    const progress = this.nodeProgress.get(nodeId);
    
    if (progress) {
      progress.isConsistent = consistencyResult.isConsistent;
      progress.consistencyRatio = consistencyResult.ratio;
      
      // ë¶ˆì¼ê´€í•œ ê²½ìš° ì™„ë£Œ ìƒíƒœ ì·¨ì†Œ
      if (!consistencyResult.isConsistent) {
        progress.isCompleted = false;
        this.completedNodes.delete(nodeId);
      }
      
      await this.broadcastProgress();
    }
  }
  
  /**
   * ì „ì²´ ì§„í–‰ë¥  ê³„ì‚°
   */
  getOverallProgress(): OverallProgress {
    const completed = this.completedNodes.size;
    const percentage = this.totalNodes > 0 
      ? (completed / this.totalNodes) * 100 
      : 0;
    
    // ë ˆë²¨ë³„ ì§„í–‰ë¥ 
    const levelProgress: Map<number, LevelProgress> = new Map();
    
    for (const [, progress] of this.nodeProgress) {
      if (!levelProgress.has(progress.level)) {
        levelProgress.set(progress.level, {
          level: progress.level,
          totalNodes: 0,
          completedNodes: 0,
          percentage: 0
        });
      }
      
      const level = levelProgress.get(progress.level)!;
      level.totalNodes++;
      
      if (progress.isCompleted && progress.isConsistent) {
        level.completedNodes++;
      }
    }
    
    // ë ˆë²¨ë³„ í¼ì„¼íŠ¸ ê³„ì‚°
    for (const [, level] of levelProgress) {
      level.percentage = level.totalNodes > 0
        ? (level.completedNodes / level.totalNodes) * 100
        : 0;
    }
    
    // ì˜ˆìƒ ë‚¨ì€ ì‹œê°„ ê³„ì‚°
    const estimatedTimeRemaining = this.estimateTimeRemaining();
    
    return {
      totalNodes: this.totalNodes,
      completedNodes: completed,
      percentage,
      levelProgress: Array.from(levelProgress.values()),
      estimatedTimeRemaining,
      currentNode: this.getCurrentNode(),
      nextNode: this.getNextNode()
    };
  }
  
  /**
   * WebSocketìœ¼ë¡œ ì§„í–‰ë¥  ë¸Œë¡œë“œìºìŠ¤íŠ¸
   */
  private async broadcastProgress(): Promise<void> {
    const progress = this.getOverallProgress();
    
    const message: ProgressMessage = {
      type: 'PROGRESS_UPDATE',
      projectId: this.projectId,
      evaluatorId: this.evaluatorId,
      timestamp: new Date().toISOString(),
      data: progress
    };
    
    if (this.websocket.readyState === WebSocket.OPEN) {
      this.websocket.send(JSON.stringify(message));
    }
    
    // ë°ì´í„°ë² ì´ìŠ¤ì—ë„ ì €ì¥
    await this.saveProgressToDatabase();
  }
  
  /**
   * ë‚¨ì€ ì‹œê°„ ì¶”ì •
   */
  private estimateTimeRemaining(): number {
    const completedWithTime = Array.from(this.nodeProgress.values())
      .filter(p => p.isCompleted && p.timeSpent > 0);
    
    if (completedWithTime.length === 0) {
      return -1; // ì¶”ì • ë¶ˆê°€
    }
    
    // í‰ê·  ì‹œê°„ ê³„ì‚°
    const avgTimePerNode = completedWithTime
      .reduce((sum, p) => sum + p.timeSpent, 0) / completedWithTime.length;
    
    const remainingNodes = this.totalNodes - this.completedNodes.size;
    
    return Math.round(avgTimePerNode * remainingNodes / 1000); // ì´ˆ ë‹¨ìœ„
  }
  
  /**
   * í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ë…¸ë“œ
   */
  private getCurrentNode(): NodeInfo | null {
    for (const [id, progress] of this.nodeProgress) {
      if (progress.startedAt && !progress.isCompleted) {
        return {
          id,
          name: progress.nodeName,
          level: progress.level,
          progress: (progress.completedComparisons / progress.totalComparisons) * 100
        };
      }
    }
    return null;
  }
  
  /**
   * ë‹¤ìŒ í‰ê°€í•  ë…¸ë“œ
   */
  private getNextNode(): NodeInfo | null {
    for (const [id, progress] of this.nodeProgress) {
      if (!progress.startedAt) {
        return {
          id,
          name: progress.nodeName,
          level: progress.level,
          progress: 0
        };
      }
    }
    return null;
  }
  
  /**
   * í‰ê°€ê°€ í•„ìš”í•œ ë…¸ë“œ ëª©ë¡
   */
  private getEvaluationNodes(structure: HierarchicalStructure): HierarchyNode[] {
    const nodes: HierarchyNode[] = [];
    
    const traverse = (node: HierarchyNode) => {
      if (node.children && node.children.length > 1) {
        nodes.push(node);
        node.children.forEach(traverse);
      }
    };
    
    // ëª©í‘œ ë…¸ë“œë¶€í„° ì‹œì‘
    traverse(structure.goal);
    
    return nodes;
  }
  
  /**
   * ë°ì´í„°ë² ì´ìŠ¤ì— ì§„í–‰ë¥  ì €ì¥
   */
  private async saveProgressToDatabase(): Promise<void> {
    // PostgreSQLì— ì§„í–‰ë¥  ì €ì¥
    const query = `
      INSERT INTO hierarchy_evaluation_progress 
        (project_id, evaluator_id, node_id, total_comparisons, 
         completed_comparisons, is_completed, is_consistent, 
         consistency_ratio, started_at, completed_at, time_spent_seconds)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      ON CONFLICT (evaluator_id, node_id) 
      DO UPDATE SET
        completed_comparisons = EXCLUDED.completed_comparisons,
        is_completed = EXCLUDED.is_completed,
        is_consistent = EXCLUDED.is_consistent,
        consistency_ratio = EXCLUDED.consistency_ratio,
        completed_at = EXCLUDED.completed_at,
        time_spent_seconds = EXCLUDED.time_spent_seconds
    `;
    
    for (const [nodeId, progress] of this.nodeProgress) {
      await executeQuery(query, [
        this.projectId,
        this.evaluatorId,
        nodeId,
        progress.totalComparisons,
        progress.completedComparisons,
        progress.isCompleted,
        progress.isConsistent,
        progress.consistencyRatio,
        progress.startedAt,
        progress.completedAt,
        Math.round(progress.timeSpent / 1000)
      ]);
    }
  }
}
```

---

## 6. API ì—”ë“œí¬ì¸íŠ¸

### 6.1 REST API ì •ì˜

```typescript
// API ë¼ìš°íŠ¸ ì •ì˜
export const hierarchicalEvaluationRoutes = {
  // ê³„ì¸µ êµ¬ì¡° ê´€ë¦¬
  'POST /api/projects/:projectId/hierarchy': 'createHierarchy',
  'GET /api/projects/:projectId/hierarchy': 'getHierarchy',
  'PUT /api/projects/:projectId/hierarchy/nodes/:nodeId': 'updateNode',
  'DELETE /api/projects/:projectId/hierarchy/nodes/:nodeId': 'deleteNode',
  'POST /api/projects/:projectId/hierarchy/nodes/:nodeId/children': 'addChildren',
  
  // í‰ê°€ ì„¸ì…˜
  'POST /api/evaluations/:evaluatorId/start': 'startEvaluation',
  'GET /api/evaluations/:evaluatorId/current': 'getCurrentEvaluation',
  'POST /api/evaluations/:evaluatorId/nodes/:nodeId/compare': 'submitComparison',
  'GET /api/evaluations/:evaluatorId/progress': 'getProgress',
  'POST /api/evaluations/:evaluatorId/complete': 'completeEvaluation',
  
  // ê²°ê³¼ ì¡°íšŒ
  'GET /api/projects/:projectId/weights/local': 'getLocalWeights',
  'GET /api/projects/:projectId/weights/global': 'getGlobalWeights',
  'GET /api/projects/:projectId/rankings': 'getRankings',
  'GET /api/projects/:projectId/consistency': 'getConsistencyReport',
  
  // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
  'WS /ws/evaluation/:evaluatorId': 'websocketConnection'
};
```

### 6.2 API êµ¬í˜„ ì˜ˆì‹œ

```typescript
export class HierarchicalEvaluationAPI {
  /**
   * ê³„ì¸µ êµ¬ì¡° ìƒì„±
   */
  async createHierarchy(req: Request, res: Response): Promise<void> {
    try {
      const { projectId } = req.params;
      const { goal, criteria, alternatives } = req.body;
      
      // íŠ¸ëœì­ì…˜ ì‹œì‘
      await db.beginTransaction();
      
      // ëª©í‘œ ë…¸ë“œ ìƒì„±
      const goalNode = await this.createNode({
        projectId,
        nodeType: 'goal',
        level: 0,
        name: goal.name,
        description: goal.description,
        code: 'G',
        position: 0
      });
      
      // ê¸°ì¤€ ë…¸ë“œë“¤ ìƒì„±
      const criteriaNodes = await Promise.all(
        criteria.map((criterion: any, index: number) =>
          this.createNode({
            projectId,
            parentId: goalNode.id,
            nodeType: 'criterion',
            level: 1,
            name: criterion.name,
            description: criterion.description,
            code: `C${index + 1}`,
            position: index
          })
        )
      );
      
      // ëŒ€ì•ˆ ë…¸ë“œë“¤ ìƒì„±
      const alternativeNodes = await Promise.all(
        alternatives.map((alternative: any, index: number) =>
          this.createNode({
            projectId,
            nodeType: 'alternative',
            level: -1, // ëŒ€ì•ˆì€ íŠ¹ë³„í•œ ë ˆë²¨
            name: alternative.name,
            description: alternative.description,
            code: `A${index + 1}`,
            position: index
          })
        )
      );
      
      // ê´€ê³„ ì„¤ì •
      await this.createRelationships(goalNode, criteriaNodes, alternativeNodes);
      
      await db.commitTransaction();
      
      res.json({
        success: true,
        data: {
          goal: goalNode,
          criteria: criteriaNodes,
          alternatives: alternativeNodes
        }
      });
    } catch (error) {
      await db.rollbackTransaction();
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }
  
  /**
   * ìŒëŒ€ë¹„êµ ì œì¶œ
   */
  async submitComparison(req: Request, res: Response): Promise<void> {
    try {
      const { evaluatorId, nodeId } = req.params;
      const { comparisons } = req.body;
      
      // í‰ê°€ í”Œë¡œìš° ì¸ìŠ¤í„´ìŠ¤
      const evaluationFlow = await this.getEvaluationFlow(evaluatorId);
      
      // ë…¸ë“œ ê°€ì ¸ì˜¤ê¸°
      const node = await this.getNode(nodeId);
      
      // ìŒëŒ€ë¹„êµ ìˆ˜í–‰
      const result = await evaluationFlow.performPairwiseComparison(
        node,
        comparisons
      );
      
      // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
      const progressTracker = await this.getProgressTracker(evaluatorId);
      await progressTracker.updateComparison(nodeId, comparisons.length, true);
      
      // ì¼ê´€ì„± ì—…ë°ì´íŠ¸
      await progressTracker.updateConsistency(nodeId, result.consistency);
      
      res.json({
        success: true,
        data: {
          consistency: result.consistency,
          weights: result.weights,
          nextNode: result.nextNode,
          progress: progressTracker.getOverallProgress()
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }
  
  /**
   * ê¸€ë¡œë²Œ ê°€ì¤‘ì¹˜ ì¡°íšŒ
   */
  async getGlobalWeights(req: Request, res: Response): Promise<void> {
    try {
      const { projectId } = req.params;
      const { evaluatorId } = req.query;
      
      const structure = await this.getHierarchicalStructure(projectId);
      const calculator = new GlobalWeightCalculator(structure);
      
      // íŠ¹ì • í‰ê°€ì ë˜ëŠ” í†µí•© ê²°ê³¼
      if (evaluatorId) {
        await calculator.loadEvaluatorWeights(evaluatorId as string);
      } else {
        await calculator.loadAggregatedWeights();
      }
      
      const weights = await calculator.calculateGlobalWeights();
      
      res.json({
        success: true,
        data: weights
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }
}
```

---

## 7. ê·¸ë£¹ í‰ê°€ í†µí•©

### 7.1 ê·¸ë£¹ í†µí•© ì•Œê³ ë¦¬ì¦˜

```typescript
export class GroupEvaluationAggregator {
  private projectId: string;
  private evaluators: Evaluator[];
  private aggregationMethod: 'geometric' | 'arithmetic' | 'weighted';
  
  constructor(
    projectId: string,
    evaluators: Evaluator[],
    method: 'geometric' | 'arithmetic' | 'weighted' = 'geometric'
  ) {
    this.projectId = projectId;
    this.evaluators = evaluators;
    this.aggregationMethod = method;
  }
  
  /**
   * ê·¸ë£¹ í‰ê°€ í†µí•©
   */
  async aggregateGroupEvaluations(): Promise<AggregatedResult> {
    const structure = await this.getHierarchicalStructure();
    const evaluationNodes = this.getEvaluationNodes(structure);
    const aggregatedMatrices = new Map<string, number[][]>();
    
    for (const node of evaluationNodes) {
      const matrices = await this.getNodeMatrices(node.id);
      
      if (matrices.length === 0) continue;
      
      let aggregatedMatrix: number[][];
      
      switch (this.aggregationMethod) {
        case 'geometric':
          aggregatedMatrix = this.geometricMean(matrices);
          break;
        case 'arithmetic':
          aggregatedMatrix = this.arithmeticMean(matrices);
          break;
        case 'weighted':
          aggregatedMatrix = await this.weightedMean(matrices);
          break;
      }
      
      aggregatedMatrices.set(node.id, aggregatedMatrix);
      
      // ì¼ê´€ì„± ê²€ì¦
      const consistency = await ConsistencyValidator.validateConsistency(aggregatedMatrix);
      
      // ê°€ì¤‘ì¹˜ ê³„ì‚°
      const weights = consistency.eigenVector;
      
      // ìì‹ ë…¸ë“œì— ê°€ì¤‘ì¹˜ í• ë‹¹
      if (node.children) {
        node.children.forEach((child, index) => {
          child.localWeight = weights[index];
        });
      }
    }
    
    // ê¸€ë¡œë²Œ ê°€ì¤‘ì¹˜ ê³„ì‚°
    const calculator = new GlobalWeightCalculator(structure);
    const globalWeights = await calculator.calculateGlobalWeights();
    
    // í‰ê°€ì ê°„ í•©ì˜ë„ ê³„ì‚°
    const consensus = await this.calculateConsensus(aggregatedMatrices);
    
    return {
      aggregatedMatrices,
      globalWeights,
      consensus,
      method: this.aggregationMethod,
      evaluatorCount: this.evaluators.length
    };
  }
  
  /**
   * ê¸°í•˜í‰ê·  (AIJ: Aggregation of Individual Judgments)
   */
  private geometricMean(matrices: number[][][]): number[][] {
    const n = matrices[0].length;
    const result = Array(n).fill(null).map(() => Array(n).fill(1));
    const k = matrices.length;
    
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) continue;
        
        // ê¸°í•˜í‰ê· : (a1 * a2 * ... * ak)^(1/k)
        let product = 1;
        for (const matrix of matrices) {
          product *= matrix[i][j];
        }
        result[i][j] = Math.pow(product, 1 / k);
      }
    }
    
    return result;
  }
  
  /**
   * ì‚°ìˆ í‰ê·  (AIP: Aggregation of Individual Priorities)
   */
  private arithmeticMean(matrices: number[][][]): number[][] {
    const n = matrices[0].length;
    const result = Array(n).fill(null).map(() => Array(n).fill(0));
    const k = matrices.length;
    
    // ê° ë§¤íŠ¸ë¦­ìŠ¤ì˜ ê°€ì¤‘ì¹˜ ë²¡í„° ê³„ì‚°
    const weightVectors: number[][] = [];
    
    for (const matrix of matrices) {
      const { eigenVector } = await ConsistencyValidator.powerMethod(matrix);
      weightVectors.push(eigenVector);
    }
    
    // ê°€ì¤‘ì¹˜ ë²¡í„°ì˜ ì‚°ìˆ í‰ê· 
    const avgWeights = Array(n).fill(0);
    for (let i = 0; i < n; i++) {
      let sum = 0;
      for (const weights of weightVectors) {
        sum += weights[i];
      }
      avgWeights[i] = sum / k;
    }
    
    // í‰ê·  ê°€ì¤‘ì¹˜ë¡œë¶€í„° ë§¤íŠ¸ë¦­ìŠ¤ ì¬êµ¬ì„±
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) {
          result[i][j] = 1;
        } else {
          result[i][j] = avgWeights[i] / avgWeights[j];
        }
      }
    }
    
    return result;
  }
  
  /**
   * ê°€ì¤‘ í‰ê·  (í‰ê°€ì ì „ë¬¸ì„± ë°˜ì˜)
   */
  private async weightedMean(matrices: number[][][]): Promise<number[][]> {
    const n = matrices[0].length;
    const result = Array(n).fill(null).map(() => Array(n).fill(1));
    
    // í‰ê°€ìë³„ ê°€ì¤‘ì¹˜ ê°€ì ¸ì˜¤ê¸°
    const evaluatorWeights = await this.getEvaluatorWeights();
    const totalWeight = evaluatorWeights.reduce((sum, w) => sum + w, 0);
    
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) continue;
        
        let weightedSum = 0;
        for (let k = 0; k < matrices.length; k++) {
          const logValue = Math.log(matrices[k][i][j]);
          weightedSum += logValue * evaluatorWeights[k];
        }
        
        result[i][j] = Math.exp(weightedSum / totalWeight);
      }
    }
    
    return result;
  }
  
  /**
   * í‰ê°€ì ê°„ í•©ì˜ë„ ê³„ì‚°
   */
  private async calculateConsensus(
    aggregatedMatrices: Map<string, number[][]>
  ): Promise<ConsensusMetrics> {
    const nodeConsensus: NodeConsensus[] = [];
    let totalConsensus = 0;
    let nodeCount = 0;
    
    for (const [nodeId, aggregatedMatrix] of aggregatedMatrices) {
      const individualMatrices = await this.getNodeMatrices(nodeId);
      
      if (individualMatrices.length < 2) continue;
      
      // Shannon Entropy ê¸°ë°˜ í•©ì˜ë„
      const entropy = this.calculateEntropy(individualMatrices);
      const maxEntropy = Math.log(individualMatrices.length);
      const consensus = 1 - (entropy / maxEntropy); // 0~1 ì •ê·œí™”
      
      nodeConsensus.push({
        nodeId,
        consensus,
        entropy,
        evaluatorCount: individualMatrices.length
      });
      
      totalConsensus += consensus;
      nodeCount++;
    }
    
    return {
      overallConsensus: nodeCount > 0 ? totalConsensus / nodeCount : 0,
      nodeConsensus,
      method: 'Shannon Entropy',
      threshold: 0.7 // í•©ì˜ë„ ì„ê³„ê°’
    };
  }
  
  /**
   * Shannon Entropy ê³„ì‚°
   */
  private calculateEntropy(matrices: number[][][]): number {
    const n = matrices[0].length;
    let totalEntropy = 0;
    let pairCount = 0;
    
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const values = matrices.map(m => Math.log(m[i][j]));
        const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
        const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
        
        // ì—”íŠ¸ë¡œí”¼ ê·¼ì‚¬
        const entropy = 0.5 * Math.log(2 * Math.PI * Math.E * variance);
        totalEntropy += entropy;
        pairCount++;
      }
    }
    
    return pairCount > 0 ? totalEntropy / pairCount : 0;
  }
  
  /**
   * í‰ê°€ì ì „ë¬¸ì„± ê°€ì¤‘ì¹˜
   */
  private async getEvaluatorWeights(): Promise<number[]> {
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” í‰ê°€ìì˜ ì „ë¬¸ì„±, ê²½í—˜, ê³¼ê±° ì¼ê´€ì„± ë“±ì„ ê³ ë ¤
    // ì—¬ê¸°ì„œëŠ” ê· ë“± ê°€ì¤‘ì¹˜ ì‚¬ìš©
    return this.evaluators.map(() => 1 / this.evaluators.length);
  }
}
```

---

## 8. ì„±ëŠ¥ ìµœì í™”

### 8.1 ìºì‹± ì „ëµ

```typescript
export class HierarchicalEvaluationCache {
  private redis: RedisClient;
  private cachePrefix = 'ahp:hierarchy:';
  
  /**
   * ê³„ì‚° ê²°ê³¼ ìºì‹±
   */
  async cacheCalculation(
    key: string,
    data: any,
    ttl: number = 3600
  ): Promise<void> {
    const cacheKey = `${this.cachePrefix}${key}`;
    await this.redis.setex(
      cacheKey,
      ttl,
      JSON.stringify(data)
    );
  }
  
  /**
   * ìºì‹œ ì¡°íšŒ
   */
  async getCached<T>(key: string): Promise<T | null> {
    const cacheKey = `${this.cachePrefix}${key}`;
    const cached = await this.redis.get(cacheKey);
    return cached ? JSON.parse(cached) : null;
  }
  
  /**
   * ìºì‹œ ë¬´íš¨í™”
   */
  async invalidateCache(pattern: string): Promise<void> {
    const keys = await this.redis.keys(`${this.cachePrefix}${pattern}*`);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

### 8.2 ë³‘ë ¬ ì²˜ë¦¬

```typescript
export class ParallelProcessor {
  /**
   * ë³‘ë ¬ë¡œ ì—¬ëŸ¬ ë…¸ë“œ í‰ê°€
   */
  async processNodesInParallel(
    nodes: HierarchyNode[],
    processor: (node: HierarchyNode) => Promise<any>
  ): Promise<Map<string, any>> {
    const chunks = this.chunkArray(nodes, 5); // 5ê°œì”© ë¬¶ê¸°
    const results = new Map<string, any>();
    
    for (const chunk of chunks) {
      const chunkResults = await Promise.all(
        chunk.map(async node => ({
          id: node.id,
          result: await processor(node)
        }))
      );
      
      chunkResults.forEach(({ id, result }) => {
        results.set(id, result);
      });
    }
    
    return results;
  }
  
  private chunkArray<T>(array: T[], size: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
}
```

---

## 9. ì—ëŸ¬ ì²˜ë¦¬

### 9.1 ì—ëŸ¬ íƒ€ì… ì •ì˜

```typescript
export enum HierarchicalEvaluationError {
  INVALID_HIERARCHY = 'INVALID_HIERARCHY',
  INCOMPLETE_EVALUATION = 'INCOMPLETE_EVALUATION',
  INCONSISTENT_MATRIX = 'INCONSISTENT_MATRIX',
  CALCULATION_ERROR = 'CALCULATION_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR'
}

export class HierarchyError extends Error {
  constructor(
    public code: HierarchicalEvaluationError,
    message: string,
    public details?: any
  ) {
    super(message);
    this.name = 'HierarchyError';
  }
}
```

---

## 10. í…ŒìŠ¤íŠ¸ ì „ëµ

### 10.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì˜ˆì‹œ

```typescript
describe('HierarchicalEvaluation', () => {
  describe('ConsistencyValidator', () => {
    it('should validate consistent matrix', async () => {
      const matrix = [
        [1, 3, 5],
        [1/3, 1, 2],
        [1/5, 1/2, 1]
      ];
      
      const result = await ConsistencyValidator.validateConsistency(matrix);
      
      expect(result.isConsistent).toBe(true);
      expect(result.ratio).toBeLessThan(0.1);
    });
    
    it('should detect inconsistent matrix', async () => {
      const matrix = [
        [1, 9, 1/9],
        [1/9, 1, 9],
        [9, 1/9, 1]
      ];
      
      const result = await ConsistencyValidator.validateConsistency(matrix);
      
      expect(result.isConsistent).toBe(false);
      expect(result.ratio).toBeGreaterThan(0.1);
      expect(result.inconsistentPairs).toHaveLength(3);
    });
  });
  
  describe('GlobalWeightCalculator', () => {
    it('should calculate correct global weights', async () => {
      const structure = mockHierarchicalStructure();
      const calculator = new GlobalWeightCalculator(structure);
      
      const weights = await calculator.calculateGlobalWeights();
      
      expect(weights.rankings).toHaveLength(structure.alternatives.length);
      expect(weights.rankings[0].score).toBeGreaterThan(0);
      
      // í•©ì´ 1ì´ ë˜ëŠ”ì§€ í™•ì¸
      const totalWeight = Object.values(weights.alternatives)
        .reduce((sum, alt) => sum + alt.totalScore, 0);
      expect(Math.abs(totalWeight - 1)).toBeLessThan(0.001);
    });
  });
});
```

---

## 11. êµ¬í˜„ ê°€ì´ë“œë¼ì¸

### 11.1 Sonnet êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸

```markdown
## í”„ë¡ íŠ¸ì—”ë“œ êµ¬í˜„
- [ ] ê³„ì¸µ êµ¬ì¡° íŠ¸ë¦¬ ì»´í¬ë„ŒíŠ¸ (D3.js ë˜ëŠ” React Flow)
- [ ] ë“œë˜ê·¸&ë“œë¡­ ë…¸ë“œ ì¬ì •ë ¬
- [ ] ìŒëŒ€ë¹„êµ ìŠ¬ë¼ì´ë” UI
- [ ] ì‹¤ì‹œê°„ ì¼ê´€ì„± í”¼ë“œë°±
- [ ] ì§„í–‰ë¥  í‘œì‹œ ë°”
- [ ] ê°€ì¤‘ì¹˜ ì‹œê°í™” ì°¨íŠ¸

## ë°±ì—”ë“œ êµ¬í˜„
- [ ] Django ëª¨ë¸ ìƒì„±
- [ ] REST API ë·° êµ¬í˜„
- [ ] WebSocket í•¸ë“¤ëŸ¬
- [ ] Celery íƒœìŠ¤í¬
- [ ] ìºì‹± ë ˆì´ì–´

## í…ŒìŠ¤íŠ¸
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±
- [ ] í†µí•© í…ŒìŠ¤íŠ¸
- [ ] ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] E2E í…ŒìŠ¤íŠ¸
```

### 11.2 ì„±ëŠ¥ ëª©í‘œ

- 100ê°œ ë…¸ë“œ ê³„ì¸µ êµ¬ì¡°: < 2ì´ˆ ë¡œë”©
- ìŒëŒ€ë¹„êµ ì œì¶œ: < 500ms ì‘ë‹µ
- ê¸€ë¡œë²Œ ê°€ì¤‘ì¹˜ ê³„ì‚°: < 1ì´ˆ
- 10ëª… ë™ì‹œ í‰ê°€: ë¬´ì¤‘ë‹¨ ì²˜ë¦¬

---

## 12. ë§ˆë¬´ë¦¬

ì´ ì„¤ê³„ ë¬¸ì„œëŠ” ê³„ì¸µì  í‰ê°€ ì‹œìŠ¤í…œì˜ ì™„ì „í•œ êµ¬í˜„ì„ ìœ„í•œ ìƒì„¸ ê°€ì´ë“œì…ë‹ˆë‹¤.
Sonnetì´ ì´ ë¬¸ì„œë¥¼ ê¸°ë°˜ìœ¼ë¡œ êµ¬í˜„ì„ ì§„í–‰í•˜ë©´ MVP ëª©í‘œ ë‹¬ì„±ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

**ë¬¸ì„œ ì‘ì„± ì™„ë£Œ**: 2024-11-11 (ê³„ì† ì—…ë°ì´íŠ¸ ì˜ˆì •)
**ë‹¤ìŒ ë‹¨ê³„**: ê·¸ë£¹ í‰ê°€ í†µí•© ì‹œìŠ¤í…œ ì„¤ê³„