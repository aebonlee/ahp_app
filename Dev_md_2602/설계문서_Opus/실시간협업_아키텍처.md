# Phase 2b: 실시간 협업 WebSocket 아키텍처 설계 문서

**문서 버전**: v1.0
**작성일**: 2026-02-18
**작성자**: Claude Opus 4.6
**대상 구현자**: Claude Sonnet (백엔드 Django Channels), Claude Opus (프론트엔드 React)
**프로젝트**: Multi-Layer AHP Decision Support Platform

---

## 0. 현재 상태 분석

### 0.1 기존 구현 파악

현재 실시간 협업 시스템은 **SSE(Server-Sent Events) + REST API** 방식으로 설계되어 있으나, 실제 서버 연결 없이 **Mock 기반의 프론트엔드 전용 구현**에 머물러 있다.

| 구성 요소 | 파일 경로 | 구현율 | 상태 |
|-----------|-----------|--------|------|
| `RealTimeCollaboration` | `src/components/collaboration/RealTimeCollaboration.tsx` | 70% | UI 완성, 서버 연결 없음. Mock 데이터로만 동작 |
| `RealTimeSyncManager` | `src/utils/realTimeSync.ts` | 40% | SSE 기반 클래스 구조 존재. 실제 서버 URL은 상대경로(`/api/collaboration/...`), EventSource 초기화 시 즉시 실패하여 오프라인 모드로 전환 |
| `MockCollaborationServer` | `src/utils/realTimeSync.ts` | 100% | 개발용 Mock 서버 구현 완료 |
| `authService` | `src/services/authService.ts` | 95% | JWT 토큰 관리 완전 구현. `getAccessToken()` 메서드 사용 가능 |
| `useCollaboration` Hook | `src/hooks/useCollaboration.ts` | 0% | **파일 미존재** |
| Django Channels Consumer | 백엔드 | 0% | **미구현** |
| Redis Channel Layer | 백엔드 | 0% | **미설정** |
| WebSocket 연결 | 전체 | 0% | **미구현** |

### 0.2 전체 구현율: 약 25%

### 0.3 미구현 목록 (이번 Phase 2b에서 구현할 것)

1. **Django Channels WebSocket Consumer** (`AHPProjectConsumer`)
2. **JWT 인증 미들웨어** (WebSocket 핸드셰이크 시 토큰 검증)
3. **Redis Channel Layer 설정** (Render.com 배포용)
4. **이벤트 소싱 패턴** (이벤트 타입 체계, payload 스키마)
5. **충돌 해결 메커니즘** (Last-Write-Wins + 낙관적 업데이트)
6. **`useCollaboration` React Hook** (WebSocket 연결, 재연결, 상태 관리)
7. **`RealTimeSyncManager` 리팩토링** (SSE -> WebSocket 전환)
8. **프레즌스 시스템** (사용자 접속/이탈/커서 위치)

### 0.4 기존 코드에서 재사용할 것

- `CollaborationUser`, `CollaborationEvent`, `ChatMessage`, `ConflictResolution` 인터페이스 (확장하여 사용)
- `generateUserColor()`, `checkUserPermission()` 유틸리티 함수
- `RealTimeCollaboration.tsx`의 UI 컴포넌트 (내부 연결 로직만 교체)
- `authService.getAccessToken()` (WebSocket 인증에 재사용)

---

## 1. Django Channels WebSocket 설계

### 1.1 전체 아키텍처

```
[React Client]                    [Django Backend (Render.com)]
     |                                    |
     |  wss://ahp-django-backend          |
     |    .onrender.com/ws/project/       |
     |    {project_id}/?token={jwt}       |
     |  --------------------------------> |
     |                                    |  [TokenAuthMiddleware]
     |                                    |    -> JWT 검증
     |                                    |    -> scope["user"] 설정
     |                                    |
     |                                    |  [AHPProjectConsumer]
     |                                    |    -> connect()
     |                                    |    -> receive_json()
     |                                    |    -> disconnect()
     |                                    |
     |                                    |  [Redis Channel Layer]
     |  <--  broadcast to group  ------   |    -> group_send()
     |                                    |    -> group_add()
     |                                    |    -> group_discard()
```

### 1.2 ASGI 라우팅 설정

```python
# backend/config/asgi.py

import os
import django

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
django.setup()

from channels.routing import ProtocolTypeRouter, URLRouter
from channels.security.websocket import AllowedHostsOriginValidator
from collaboration.middleware import TokenAuthMiddlewareStack
from collaboration.routing import websocket_urlpatterns

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": AllowedHostsOriginValidator(
        TokenAuthMiddlewareStack(
            URLRouter(websocket_urlpatterns)
        )
    ),
})
```

### 1.3 URL 라우팅

```python
# backend/collaboration/routing.py

from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(
        r'ws/project/(?P<project_id>[0-9a-f-]+)/$',
        consumers.AHPProjectConsumer.as_asgi()
    ),
]
```

### 1.4 채널 그룹 네이밍 전략

```python
# 그룹 이름 규칙
GROUP_PREFIX = "ahp_project"

# 프로젝트 전체 채널 (모든 이벤트 수신)
f"ahp_project_{project_id}"

# 프레즌스 전용 채널 (커서/접속 상태만)
f"ahp_project_{project_id}_presence"

# 채팅 전용 채널
f"ahp_project_{project_id}_chat"

# 예시:
# ahp_project_550e8400-e29b-41d4-a716-446655440000
# ahp_project_550e8400-e29b-41d4-a716-446655440000_presence
# ahp_project_550e8400-e29b-41d4-a716-446655440000_chat
```

**설계 근거**: 채널을 기능별로 분리하면 프레즌스 업데이트(고빈도, 저중요도)가 모델 변경 이벤트(저빈도, 고중요도)를 방해하지 않는다. 클라이언트는 필요한 채널만 선택적으로 구독할 수 있다.

### 1.5 AHPProjectConsumer 클래스

```python
# backend/collaboration/consumers.py

import json
import logging
from datetime import datetime
from channels.generic.websocket import AsyncJsonWebsocketConsumer
from channels.db import database_sync_to_async
from django.contrib.auth import get_user_model

User = get_user_model()
logger = logging.getLogger(__name__)


class AHPProjectConsumer(AsyncJsonWebsocketConsumer):
    """
    AHP 프로젝트 실시간 협업 WebSocket Consumer

    역할:
    - 프로젝트별 그룹 관리 (참여/이탈)
    - 이벤트 브로드캐스트 (모델 변경, 평가 제출 등)
    - 프레즌스 관리 (접속 사용자 추적)
    - 충돌 감지 (동시 편집 시)
    """

    # ─── 연결 수명주기 ──────────────────────────────────

    async def connect(self):
        """WebSocket 연결 수립"""
        self.project_id = self.scope['url_route']['kwargs']['project_id']
        self.user = self.scope.get('user')

        # 인증 확인
        if not self.user or self.user.is_anonymous:
            logger.warning(
                f"WebSocket 인증 실패: project={self.project_id}"
            )
            await self.close(code=4001)
            return

        # 프로젝트 접근 권한 확인
        has_access = await self.check_project_access()
        if not has_access:
            logger.warning(
                f"프로젝트 접근 거부: user={self.user.id}, "
                f"project={self.project_id}"
            )
            await self.close(code=4003)
            return

        # 그룹 이름 설정
        self.project_group = f"ahp_project_{self.project_id}"
        self.presence_group = f"ahp_project_{self.project_id}_presence"
        self.chat_group = f"ahp_project_{self.project_id}_chat"

        # 그룹 참여
        await self.channel_layer.group_add(
            self.project_group, self.channel_name
        )
        await self.channel_layer.group_add(
            self.presence_group, self.channel_name
        )
        await self.channel_layer.group_add(
            self.chat_group, self.channel_name
        )

        # 연결 수락
        await self.accept()

        # 프레즌스 등록
        await self.register_presence()

        # 다른 사용자에게 참여 알림
        await self.channel_layer.group_send(
            self.project_group,
            {
                "type": "collaboration.event",
                "event_type": "user_join",
                "user_id": str(self.user.id),
                "user_name": self.user.get_full_name() or self.user.username,
                "user_email": self.user.email,
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "data": {
                    "role": await self.get_user_project_role(),
                },
            }
        )

        # 현재 접속 중인 사용자 목록 전송 (본인에게만)
        online_users = await self.get_online_users()
        await self.send_json({
            "type": "presence_sync",
            "users": online_users,
            "timestamp": datetime.utcnow().isoformat() + "Z",
        })

        logger.info(
            f"WebSocket 연결 성공: user={self.user.id}, "
            f"project={self.project_id}"
        )

    async def disconnect(self, close_code):
        """WebSocket 연결 해제"""
        if hasattr(self, 'project_group'):
            # 프레즌스 해제
            await self.unregister_presence()

            # 다른 사용자에게 이탈 알림
            await self.channel_layer.group_send(
                self.project_group,
                {
                    "type": "collaboration.event",
                    "event_type": "user_leave",
                    "user_id": str(self.user.id),
                    "user_name": (
                        self.user.get_full_name() or self.user.username
                    ),
                    "timestamp": datetime.utcnow().isoformat() + "Z",
                    "data": {},
                }
            )

            # 그룹에서 제거
            await self.channel_layer.group_discard(
                self.project_group, self.channel_name
            )
            await self.channel_layer.group_discard(
                self.presence_group, self.channel_name
            )
            await self.channel_layer.group_discard(
                self.chat_group, self.channel_name
            )

        logger.info(
            f"WebSocket 연결 해제: user={getattr(self, 'user', 'unknown')}, "
            f"project={getattr(self, 'project_id', 'unknown')}, "
            f"code={close_code}"
        )

    # ─── 메시지 수신 ────────────────────────────────────

    async def receive_json(self, content, **kwargs):
        """
        클라이언트로부터 JSON 메시지 수신

        메시지 형식:
        {
            "type": "criteria_update" | "alternative_update" | ...,
            "data": { ... },
            "version": 42,          // 낙관적 버전 번호
            "client_id": "abc-123"  // 중복 방지용 클라이언트 이벤트 ID
        }
        """
        event_type = content.get("type")
        data = content.get("data", {})
        version = content.get("version")
        client_id = content.get("client_id")

        if not event_type:
            await self.send_json({
                "type": "error",
                "message": "event type is required",
                "code": "MISSING_TYPE",
            })
            return

        # 이벤트 타입별 처리
        handler = self.EVENT_HANDLERS.get(event_type)
        if handler:
            await handler(self, data, version, client_id)
        else:
            await self.send_json({
                "type": "error",
                "message": f"unknown event type: {event_type}",
                "code": "UNKNOWN_TYPE",
            })

    # ─── 이벤트 핸들러 매핑 ─────────────────────────────

    async def handle_criteria_update(self, data, version, client_id):
        """기준(criteria) 변경 이벤트 처리"""
        # 1. 데이터 검증
        criteria_id = data.get("criteria_id")
        if not criteria_id:
            await self.send_json({
                "type": "error",
                "message": "criteria_id is required",
                "code": "VALIDATION_ERROR",
            })
            return

        # 2. DB 저장 (선택적 - 중요 변경만)
        if data.get("persist", False):
            await self.persist_criteria_change(data)

        # 3. 이벤트 로그 저장
        event_record = await self.save_event_log(
            "criteria_update", data, version, client_id
        )

        # 4. 그룹에 브로드캐스트
        await self.channel_layer.group_send(
            self.project_group,
            {
                "type": "collaboration.event",
                "event_type": "criteria_update",
                "user_id": str(self.user.id),
                "user_name": (
                    self.user.get_full_name() or self.user.username
                ),
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "data": data,
                "version": event_record.get("version", version),
                "client_id": client_id,
            }
        )

    async def handle_alternative_update(self, data, version, client_id):
        """대안(alternative) 변경 이벤트 처리"""
        alternative_id = data.get("alternative_id")
        if not alternative_id:
            await self.send_json({
                "type": "error",
                "message": "alternative_id is required",
                "code": "VALIDATION_ERROR",
            })
            return

        if data.get("persist", False):
            await self.persist_alternative_change(data)

        event_record = await self.save_event_log(
            "alternative_update", data, version, client_id
        )

        await self.channel_layer.group_send(
            self.project_group,
            {
                "type": "collaboration.event",
                "event_type": "alternative_update",
                "user_id": str(self.user.id),
                "user_name": (
                    self.user.get_full_name() or self.user.username
                ),
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "data": data,
                "version": event_record.get("version", version),
                "client_id": client_id,
            }
        )

    async def handle_evaluation_submit(self, data, version, client_id):
        """평가 제출 이벤트 처리"""
        # 평가 데이터는 반드시 DB에 저장
        await self.persist_evaluation(data)

        event_record = await self.save_event_log(
            "evaluation_submit", data, version, client_id
        )

        await self.channel_layer.group_send(
            self.project_group,
            {
                "type": "collaboration.event",
                "event_type": "evaluation_submit",
                "user_id": str(self.user.id),
                "user_name": (
                    self.user.get_full_name() or self.user.username
                ),
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "data": {
                    "evaluator_id": str(self.user.id),
                    "criteria_id": data.get("criteria_id"),
                    "progress": data.get("progress", 0),
                    # 상세 비교 값은 브로드캐스트하지 않음 (보안)
                },
                "version": event_record.get("version", version),
                "client_id": client_id,
            }
        )

    async def handle_cursor_move(self, data, version, client_id):
        """커서 이동 이벤트 (프레즌스 채널로만 전송)"""
        await self.channel_layer.group_send(
            self.presence_group,
            {
                "type": "collaboration.event",
                "event_type": "cursor_move",
                "user_id": str(self.user.id),
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "data": {
                    "x": data.get("x", 0),
                    "y": data.get("y", 0),
                    "node_id": data.get("node_id"),
                },
            }
        )

    async def handle_chat_message(self, data, version, client_id):
        """채팅 메시지 처리"""
        message_text = data.get("message", "").strip()
        if not message_text:
            return

        # 채팅 메시지 DB 저장
        saved_msg = await self.save_chat_message(message_text, data)

        await self.channel_layer.group_send(
            self.chat_group,
            {
                "type": "collaboration.event",
                "event_type": "chat_message",
                "user_id": str(self.user.id),
                "user_name": (
                    self.user.get_full_name() or self.user.username
                ),
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "data": {
                    "message_id": saved_msg.get("id"),
                    "message": message_text,
                    "mentions": data.get("mentions", []),
                },
                "client_id": client_id,
            }
        )

    async def handle_selection_change(self, data, version, client_id):
        """선택 노드 변경 이벤트"""
        await self.channel_layer.group_send(
            self.presence_group,
            {
                "type": "collaboration.event",
                "event_type": "selection_change",
                "user_id": str(self.user.id),
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "data": {
                    "node_id": data.get("node_id"),
                    "node_type": data.get("node_type"),
                },
            }
        )

    async def handle_heartbeat(self, data, version, client_id):
        """하트비트 처리"""
        await self.update_presence_timestamp()
        await self.send_json({
            "type": "heartbeat_ack",
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "server_version": await self.get_current_version(),
        })

    async def handle_model_lock(self, data, version, client_id):
        """모델 편집 잠금 요청"""
        node_id = data.get("node_id")
        lock_acquired = await self.try_acquire_lock(node_id)

        if lock_acquired:
            await self.channel_layer.group_send(
                self.project_group,
                {
                    "type": "collaboration.event",
                    "event_type": "model_lock",
                    "user_id": str(self.user.id),
                    "user_name": (
                        self.user.get_full_name() or self.user.username
                    ),
                    "timestamp": datetime.utcnow().isoformat() + "Z",
                    "data": {
                        "node_id": node_id,
                        "locked": True,
                    },
                }
            )
        else:
            await self.send_json({
                "type": "lock_denied",
                "data": {
                    "node_id": node_id,
                    "locked_by": await self.get_lock_owner(node_id),
                },
            })

    async def handle_model_unlock(self, data, version, client_id):
        """모델 편집 잠금 해제"""
        node_id = data.get("node_id")
        await self.release_lock(node_id)

        await self.channel_layer.group_send(
            self.project_group,
            {
                "type": "collaboration.event",
                "event_type": "model_unlock",
                "user_id": str(self.user.id),
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "data": {
                    "node_id": node_id,
                    "locked": False,
                },
            }
        )

    # 이벤트 핸들러 테이블
    EVENT_HANDLERS = {
        "criteria_update": handle_criteria_update,
        "alternative_update": handle_alternative_update,
        "evaluation_submit": handle_evaluation_submit,
        "cursor_move": handle_cursor_move,
        "chat_message": handle_chat_message,
        "selection_change": handle_selection_change,
        "heartbeat": handle_heartbeat,
        "model_lock": handle_model_lock,
        "model_unlock": handle_model_unlock,
    }

    # ─── 그룹 메시지 수신 핸들러 ────────────────────────

    async def collaboration_event(self, event):
        """
        채널 그룹에서 수신한 이벤트를 클라이언트로 전달

        channels의 group_send()에서 "type": "collaboration.event"로
        전송된 메시지가 이 메서드로 라우팅된다.
        (Django Channels는 점(.)을 언더스코어(_)로 변환)
        """
        # 자신이 보낸 이벤트는 건너뛰기 (클라이언트에서 이미 낙관적 적용)
        if event.get("user_id") == str(self.user.id):
            # 다만, 서버 확인(ACK)은 보내야 함
            client_id = event.get("client_id")
            if client_id:
                await self.send_json({
                    "type": "ack",
                    "client_id": client_id,
                    "version": event.get("version"),
                    "timestamp": event.get("timestamp"),
                })
            return

        # 다른 사용자의 이벤트를 클라이언트로 전달
        await self.send_json({
            "type": event["event_type"],
            "user_id": event.get("user_id"),
            "user_name": event.get("user_name"),
            "timestamp": event.get("timestamp"),
            "data": event.get("data", {}),
            "version": event.get("version"),
        })

    # ─── DB 연동 헬퍼 (database_sync_to_async) ──────────

    @database_sync_to_async
    def check_project_access(self):
        """사용자의 프로젝트 접근 권한 확인"""
        from projects.models import Project
        try:
            project = Project.objects.get(id=self.project_id)
            # 소유자이거나 평가자로 등록된 경우
            if project.owner_id == self.user.id:
                return True
            # 평가자 확인
            return project.evaluators.filter(
                user=self.user
            ).exists()
        except Project.DoesNotExist:
            return False

    @database_sync_to_async
    def get_user_project_role(self):
        """프로젝트 내 사용자 역할 반환"""
        from projects.models import Project
        try:
            project = Project.objects.get(id=self.project_id)
            if project.owner_id == self.user.id:
                return "owner"
            evaluator = project.evaluators.filter(
                user=self.user
            ).first()
            return evaluator.role if evaluator else "viewer"
        except Project.DoesNotExist:
            return "viewer"

    @database_sync_to_async
    def save_event_log(self, event_type, data, version, client_id):
        """이벤트 로그를 DB에 저장하고 서버 버전 번호 반환"""
        from collaboration.models import CollaborationEventLog
        event = CollaborationEventLog.objects.create(
            project_id=self.project_id,
            user=self.user,
            event_type=event_type,
            data=data,
            client_version=version,
            client_id=client_id,
        )
        return {
            "id": str(event.id),
            "version": event.server_version,
        }

    @database_sync_to_async
    def save_chat_message(self, message_text, data):
        """채팅 메시지 DB 저장"""
        from collaboration.models import CollaborationChatMessage
        msg = CollaborationChatMessage.objects.create(
            project_id=self.project_id,
            user=self.user,
            message=message_text,
            mentions=data.get("mentions", []),
        )
        return {"id": str(msg.id)}

    @database_sync_to_async
    def persist_criteria_change(self, data):
        """기준 변경사항을 DB에 반영"""
        from projects.models import Criteria
        criteria = Criteria.objects.get(id=data["criteria_id"])
        for field, value in data.get("changes", {}).items():
            if hasattr(criteria, field):
                setattr(criteria, field, value)
        criteria.save()

    @database_sync_to_async
    def persist_alternative_change(self, data):
        """대안 변경사항을 DB에 반영"""
        from projects.models import Alternative
        alt = Alternative.objects.get(id=data["alternative_id"])
        for field, value in data.get("changes", {}).items():
            if hasattr(alt, field):
                setattr(alt, field, value)
        alt.save()

    @database_sync_to_async
    def persist_evaluation(self, data):
        """평가 데이터를 DB에 저장"""
        from evaluations.models import Comparison
        Comparison.objects.update_or_create(
            project_id=self.project_id,
            evaluator=self.user,
            criteria_id=data["criteria_id"],
            item1_id=data["item1_id"],
            item2_id=data["item2_id"],
            defaults={"value": data["value"]},
        )

    @database_sync_to_async
    def get_online_users(self):
        """현재 프로젝트에 접속 중인 사용자 목록"""
        from collaboration.models import CollaborationPresence
        presences = CollaborationPresence.objects.filter(
            project_id=self.project_id,
            is_online=True,
        ).select_related('user')[:50]

        return [
            {
                "user_id": str(p.user.id),
                "user_name": p.user.get_full_name() or p.user.username,
                "user_email": p.user.email,
                "role": p.role,
                "connected_at": p.connected_at.isoformat() + "Z",
                "current_node": p.current_node,
            }
            for p in presences
        ]

    @database_sync_to_async
    def register_presence(self):
        """사용자 프레즌스 등록"""
        from collaboration.models import CollaborationPresence
        CollaborationPresence.objects.update_or_create(
            project_id=self.project_id,
            user=self.user,
            defaults={
                "is_online": True,
                "channel_name": self.channel_name,
                "connected_at": datetime.utcnow(),
                "role": "owner",  # 이후 실제 역할 조회로 대체
            },
        )

    @database_sync_to_async
    def unregister_presence(self):
        """사용자 프레즌스 해제"""
        from collaboration.models import CollaborationPresence
        CollaborationPresence.objects.filter(
            project_id=self.project_id,
            user=self.user,
        ).update(is_online=False)

    @database_sync_to_async
    def update_presence_timestamp(self):
        """프레즌스 타임스탬프 갱신"""
        from collaboration.models import CollaborationPresence
        CollaborationPresence.objects.filter(
            project_id=self.project_id,
            user=self.user,
        ).update(last_heartbeat=datetime.utcnow())

    @database_sync_to_async
    def get_current_version(self):
        """프로젝트의 현재 서버 버전 번호"""
        from collaboration.models import CollaborationEventLog
        last = CollaborationEventLog.objects.filter(
            project_id=self.project_id
        ).order_by('-server_version').first()
        return last.server_version if last else 0

    @database_sync_to_async
    def try_acquire_lock(self, node_id):
        """노드 편집 잠금 획득 시도"""
        from collaboration.models import CollaborationLock
        lock, created = CollaborationLock.objects.get_or_create(
            project_id=self.project_id,
            node_id=node_id,
            defaults={
                "locked_by": self.user,
                "locked_at": datetime.utcnow(),
            }
        )
        if created:
            return True
        # 잠금이 30초 이상 지났으면 갱신 가능 (데드락 방지)
        from datetime import timedelta
        if (datetime.utcnow() - lock.locked_at) > timedelta(seconds=30):
            lock.locked_by = self.user
            lock.locked_at = datetime.utcnow()
            lock.save()
            return True
        return lock.locked_by == self.user

    @database_sync_to_async
    def release_lock(self, node_id):
        """노드 편집 잠금 해제"""
        from collaboration.models import CollaborationLock
        CollaborationLock.objects.filter(
            project_id=self.project_id,
            node_id=node_id,
            locked_by=self.user,
        ).delete()

    @database_sync_to_async
    def get_lock_owner(self, node_id):
        """잠금 소유자 정보 반환"""
        from collaboration.models import CollaborationLock
        try:
            lock = CollaborationLock.objects.select_related(
                'locked_by'
            ).get(
                project_id=self.project_id,
                node_id=node_id,
            )
            return {
                "user_id": str(lock.locked_by.id),
                "user_name": (
                    lock.locked_by.get_full_name()
                    or lock.locked_by.username
                ),
            }
        except CollaborationLock.DoesNotExist:
            return None
```

### 1.6 JWT 인증 미들웨어

```python
# backend/collaboration/middleware.py

import jwt
import logging
from urllib.parse import parse_qs
from channels.middleware import BaseMiddleware
from channels.db import database_sync_to_async
from django.conf import settings
from django.contrib.auth import get_user_model
from django.contrib.auth.models import AnonymousUser

User = get_user_model()
logger = logging.getLogger(__name__)


class TokenAuthMiddleware(BaseMiddleware):
    """
    WebSocket 핸드셰이크 시 JWT 토큰을 검증하는 미들웨어

    클라이언트 연결 방식:
    wss://ahp-django-backend.onrender.com/ws/project/{id}/?token={jwt}

    기존 authService.ts의 getAccessToken()이 반환하는 JWT를
    쿼리 파라미터로 전달받아 검증한다.
    """

    async def __call__(self, scope, receive, send):
        # 쿼리 파라미터에서 토큰 추출
        query_string = scope.get("query_string", b"").decode("utf-8")
        query_params = parse_qs(query_string)
        token = query_params.get("token", [None])[0]

        if token:
            scope["user"] = await self.get_user_from_token(token)
        else:
            scope["user"] = AnonymousUser()

        return await super().__call__(scope, receive, send)

    @database_sync_to_async
    def get_user_from_token(self, token):
        """JWT 토큰으로부터 사용자 객체를 반환"""
        try:
            # Django REST Framework SimpleJWT와 동일한 시크릿 사용
            payload = jwt.decode(
                token,
                settings.SIMPLE_JWT['SIGNING_KEY'],
                algorithms=[settings.SIMPLE_JWT.get(
                    'ALGORITHM', 'HS256'
                )],
            )

            user_id = payload.get("user_id")
            if not user_id:
                logger.warning("JWT에 user_id 없음")
                return AnonymousUser()

            user = User.objects.get(id=user_id)
            return user

        except jwt.ExpiredSignatureError:
            logger.warning("JWT 토큰 만료")
            return AnonymousUser()
        except jwt.InvalidTokenError as e:
            logger.warning(f"JWT 토큰 무효: {e}")
            return AnonymousUser()
        except User.DoesNotExist:
            logger.warning(f"JWT user_id에 해당하는 사용자 없음")
            return AnonymousUser()
        except Exception as e:
            logger.error(f"JWT 검증 중 예외: {e}")
            return AnonymousUser()


def TokenAuthMiddlewareStack(inner):
    """미들웨어 스택 래퍼"""
    return TokenAuthMiddleware(inner)
```

### 1.7 Redis Channel Layer 설정

```python
# backend/config/settings.py (추가 설정)

# ─── Django Channels 설정 ───────────────────────────────

INSTALLED_APPS += [
    'channels',
    'collaboration',
]

# ASGI 앱 설정
ASGI_APPLICATION = 'config.asgi.application'

# Channel Layer - Redis 기반
# Render.com에서는 Redis 인스턴스를 별도로 프로비저닝하거나
# 외부 Redis 서비스(Upstash, Redis Cloud 등)를 사용
CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels_redis.core.RedisChannelLayer",
        "CONFIG": {
            "hosts": [os.environ.get("REDIS_URL", "redis://localhost:6379")],
            # 그룹 만료 시간 (초) - 비정상 종료 대비
            "group_expiry": 86400,
            # 메시지 만료 시간 (초)
            "expiry": 60,
            # 채널 용량 (메시지 버퍼)
            "capacity": 1500,
        },
    },
}

# 개발 환경에서 Redis가 없는 경우 In-Memory 채널 레이어 사용
if os.environ.get("USE_IN_MEMORY_CHANNEL_LAYER"):
    CHANNEL_LAYERS = {
        "default": {
            "BACKEND": "channels.layers.InMemoryChannelLayer",
        },
    }
```

### 1.8 Django 모델 (collaboration 앱)

```python
# backend/collaboration/models.py

import uuid
from django.db import models
from django.conf import settings


class CollaborationEventLog(models.Model):
    """협업 이벤트 로그 (이벤트 소싱)"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    project_id = models.CharField(max_length=255, db_index=True)
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE
    )
    event_type = models.CharField(max_length=50, db_index=True)
    data = models.JSONField(default=dict)
    client_version = models.IntegerField(null=True)
    server_version = models.PositiveIntegerField(editable=False)
    client_id = models.CharField(max_length=100, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)

    class Meta:
        ordering = ['server_version']
        indexes = [
            models.Index(
                fields=['project_id', 'server_version']
            ),
            models.Index(
                fields=['project_id', 'event_type', 'created_at']
            ),
        ]

    def save(self, *args, **kwargs):
        if not self.server_version:
            last = CollaborationEventLog.objects.filter(
                project_id=self.project_id
            ).order_by('-server_version').first()
            self.server_version = (last.server_version + 1) if last else 1
        super().save(*args, **kwargs)


class CollaborationPresence(models.Model):
    """사용자 프레즌스 (접속 상태)"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    project_id = models.CharField(max_length=255, db_index=True)
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE
    )
    is_online = models.BooleanField(default=False)
    channel_name = models.CharField(max_length=255, blank=True)
    role = models.CharField(max_length=20, default='viewer')
    current_node = models.CharField(max_length=255, null=True, blank=True)
    connected_at = models.DateTimeField(null=True)
    last_heartbeat = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ['project_id', 'user']


class CollaborationChatMessage(models.Model):
    """협업 채팅 메시지"""
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    project_id = models.CharField(max_length=255, db_index=True)
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE
    )
    message = models.TextField()
    mentions = models.JSONField(default=list)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['created_at']


class CollaborationLock(models.Model):
    """노드 편집 잠금"""
    project_id = models.CharField(max_length=255)
    node_id = models.CharField(max_length=255)
    locked_by = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE
    )
    locked_at = models.DateTimeField()

    class Meta:
        unique_together = ['project_id', 'node_id']
```

---

## 2. 이벤트 소싱 패턴

### 2.1 이벤트 타입 정의

AHP 플랫폼의 도메인에 맞춰 이벤트 타입을 다음과 같이 정의한다.

| 카테고리 | 이벤트 타입 | 방향 | 채널 그룹 | 설명 |
|---------|------------|------|----------|------|
| **모델 변경** | `criteria_update` | client -> server -> group | `project` | 기준 속성 변경 (이름, 가중치 등) |
| | `criteria_create` | client -> server -> group | `project` | 새 기준 추가 |
| | `criteria_delete` | client -> server -> group | `project` | 기준 삭제 |
| | `alternative_update` | client -> server -> group | `project` | 대안 속성 변경 |
| | `alternative_create` | client -> server -> group | `project` | 새 대안 추가 |
| | `alternative_delete` | client -> server -> group | `project` | 대안 삭제 |
| **평가** | `evaluation_submit` | client -> server -> group | `project` | 쌍대비교 값 제출 |
| | `evaluation_progress` | server -> group | `project` | 평가 진행률 업데이트 |
| **프레즌스** | `user_join` | server -> group | `project` | 사용자 프로젝트 참여 |
| | `user_leave` | server -> group | `project` | 사용자 프로젝트 이탈 |
| | `cursor_move` | client -> server -> group | `presence` | 커서 위치 변경 |
| | `selection_change` | client -> server -> group | `presence` | 선택 노드 변경 |
| **채팅** | `chat_message` | client -> server -> group | `chat` | 채팅 메시지 |
| **잠금** | `model_lock` | client -> server -> group | `project` | 노드 편집 잠금 획득 |
| | `model_unlock` | client -> server -> group | `project` | 노드 편집 잠금 해제 |
| | `lock_denied` | server -> client | 직접 전송 | 잠금 획득 실패 |
| **시스템** | `heartbeat` | client -> server | 직접 전송 | 연결 유지 확인 |
| | `heartbeat_ack` | server -> client | 직접 전송 | 하트비트 응답 |
| | `ack` | server -> client | 직접 전송 | 이벤트 수신 확인 |
| | `error` | server -> client | 직접 전송 | 오류 응답 |
| | `presence_sync` | server -> client | 직접 전송 | 접속 시 사용자 목록 |

### 2.2 이벤트 Payload 스키마 (TypeScript)

```typescript
// src/types/collaboration.ts

// ─── 기본 메시지 타입 ───────────────────────────────────

/** 클라이언트 -> 서버 메시지 */
export interface ClientMessage {
  type: CollaborationEventType;
  data: Record<string, unknown>;
  version?: number;          // 낙관적 버전 (클라이언트가 알고 있는 최신 버전)
  client_id: string;         // 클라이언트 측 이벤트 ID (UUID v4)
}

/** 서버 -> 클라이언트 메시지 */
export interface ServerMessage {
  type: CollaborationEventType | SystemEventType;
  user_id?: string;
  user_name?: string;
  timestamp: string;         // ISO 8601 형식
  data: Record<string, unknown>;
  version?: number;          // 서버 확정 버전 번호
}

// ─── 이벤트 타입 열거 ───────────────────────────────────

export type CollaborationEventType =
  // 모델 변경
  | 'criteria_update'
  | 'criteria_create'
  | 'criteria_delete'
  | 'alternative_update'
  | 'alternative_create'
  | 'alternative_delete'
  // 평가
  | 'evaluation_submit'
  | 'evaluation_progress'
  // 프레즌스
  | 'user_join'
  | 'user_leave'
  | 'cursor_move'
  | 'selection_change'
  // 채팅
  | 'chat_message'
  // 잠금
  | 'model_lock'
  | 'model_unlock'
  | 'lock_denied'
  // 시스템
  | 'heartbeat';

export type SystemEventType =
  | 'ack'
  | 'heartbeat_ack'
  | 'error'
  | 'presence_sync';

// ─── 이벤트별 Data Payload ──────────────────────────────

/** 기준 변경 이벤트 */
export interface CriteriaUpdatePayload {
  criteria_id: string;
  changes: {
    name?: string;
    description?: string;
    weight?: number;
    parent_id?: string | null;
    order_index?: number;
  };
  persist?: boolean;  // true이면 서버에서 즉시 DB 저장
}

/** 기준 생성 이벤트 */
export interface CriteriaCreatePayload {
  temp_id: string;           // 클라이언트 임시 ID (서버에서 실제 ID 할당)
  name: string;
  description?: string;
  parent_id?: string | null;
  level: number;
  order_index: number;
}

/** 기준 삭제 이벤트 */
export interface CriteriaDeletePayload {
  criteria_id: string;
  cascade: boolean;          // 하위 기준도 함께 삭제?
}

/** 대안 변경 이벤트 */
export interface AlternativeUpdatePayload {
  alternative_id: string;
  changes: {
    name?: string;
    description?: string;
    order_index?: number;
  };
  persist?: boolean;
}

/** 대안 생성/삭제 이벤트 */
export interface AlternativeCreatePayload {
  temp_id: string;
  name: string;
  description?: string;
  order_index: number;
}

export interface AlternativeDeletePayload {
  alternative_id: string;
}

/** 평가 제출 이벤트 */
export interface EvaluationSubmitPayload {
  criteria_id: string;
  item1_id: string;
  item2_id: string;
  value: number;             // 1-9 스케일 (또는 1/9 ~ 9)
  progress: number;          // 0-100 전체 진행률
}

/** 커서 이동 이벤트 */
export interface CursorMovePayload {
  x: number;
  y: number;
  node_id?: string;          // 현재 호버 중인 노드
}

/** 선택 변경 이벤트 */
export interface SelectionChangePayload {
  node_id: string | null;
  node_type?: 'criteria' | 'alternative' | 'goal';
}

/** 채팅 메시지 이벤트 */
export interface ChatMessagePayload {
  message: string;
  mentions?: string[];       // 멘션된 user_id 배열
}

/** 채팅 메시지 서버 응답 */
export interface ChatMessageServerPayload extends ChatMessagePayload {
  message_id: string;
}

/** 잠금 이벤트 */
export interface ModelLockPayload {
  node_id: string;
  locked?: boolean;
}

/** 잠금 거부 응답 */
export interface LockDeniedPayload {
  node_id: string;
  locked_by: {
    user_id: string;
    user_name: string;
  } | null;
}

/** 프레즌스 동기화 (연결 시 전송) */
export interface PresenceSyncPayload {
  users: OnlineUser[];
  timestamp: string;
}

export interface OnlineUser {
  user_id: string;
  user_name: string;
  user_email: string;
  role: 'owner' | 'editor' | 'viewer';
  connected_at: string;
  current_node?: string | null;
}

/** ACK 응답 */
export interface AckPayload {
  client_id: string;
  version: number;
  timestamp: string;
}

/** 하트비트 ACK 응답 */
export interface HeartbeatAckPayload {
  timestamp: string;
  server_version: number;
}

/** 에러 응답 */
export interface ErrorPayload {
  message: string;
  code: string;
}
```

### 2.3 서버-클라이언트 메시지 프로토콜

**클라이언트 -> 서버 (WebSocket send)**:

```json
{
  "type": "criteria_update",
  "data": {
    "criteria_id": "uuid-here",
    "changes": { "name": "비용 효율성" },
    "persist": true
  },
  "version": 42,
  "client_id": "cli-evt-abc-123"
}
```

**서버 -> 다른 클라이언트 (WebSocket receive)**:

```json
{
  "type": "criteria_update",
  "user_id": "user-uuid",
  "user_name": "김분석",
  "timestamp": "2026-02-18T10:30:00.000Z",
  "data": {
    "criteria_id": "uuid-here",
    "changes": { "name": "비용 효율성" },
    "persist": true
  },
  "version": 43
}
```

**서버 -> 원본 클라이언트 (ACK)**:

```json
{
  "type": "ack",
  "client_id": "cli-evt-abc-123",
  "version": 43,
  "timestamp": "2026-02-18T10:30:00.050Z"
}
```

---

## 3. 충돌 해결 메커니즘

### 3.1 전략 선택: Last-Write-Wins (LWW) + 노드 잠금

**선택 근거**: OT(Operational Transform)와 CRDT(Conflict-free Replicated Data Types) 중 어떤 것도 선택하지 않고, **LWW + 노드 잠금 하이브리드** 방식을 채택한다.

| 방식 | 장점 | 단점 | AHP 적합성 |
|------|------|------|-----------|
| OT | 정교한 동시 편집 | 구현 복잡도 매우 높음, 서버 부담 | 낮음 - AHP는 문서 편집이 아님 |
| CRDT | 분산 환경에 최적, 오프라인 강건 | 메모리 사용량 높음, 구현 난이도 높음 | 낮음 - 데이터 구조가 단순 |
| **LWW + Lock** | **구현 단순, 이해 쉬움** | 마지막 쓰기가 승리 | **높음 - AHP 노드는 독립적 편집 단위** |

**핵심 근거**: AHP 모델의 편집 단위는 개별 노드(기준, 대안)이다. 두 사용자가 정확히 같은 노드의 같은 필드를 동시에 편집하는 경우는 극히 드물다. 따라서 OT/CRDT의 복잡성은 불필요하고, 노드 단위 잠금으로 충분히 충돌을 예방할 수 있다.

### 3.2 동시 편집 시나리오별 처리

#### 시나리오 1: 서로 다른 노드를 편집

```
User A: criteria "비용" 이름 변경   -> 충돌 없음, 양쪽 모두 적용
User B: criteria "품질" 가중치 변경  -> 충돌 없음, 양쪽 모두 적용
```

처리: **그대로 브로드캐스트**. 각 이벤트가 독립적이므로 순서 무관.

#### 시나리오 2: 같은 노드, 다른 필드를 편집

```
User A: criteria "비용" name = "비용 효율성"
User B: criteria "비용" weight = 0.35
```

처리: **양쪽 모두 적용** (필드가 다르므로 병합 가능). 서버에서 두 변경을 순차적으로 저장한다.

#### 시나리오 3: 같은 노드, 같은 필드를 편집 (진정한 충돌)

```
User A: criteria "비용" name = "비용 효율성"  (version 42, timestamp T1)
User B: criteria "비용" name = "운영 비용"    (version 42, timestamp T2)
```

처리: **노드 잠금을 선행**. 편집 시작 시 `model_lock` 이벤트로 잠금을 획득해야 한다.

1. User A가 먼저 `model_lock`을 요청 -> 잠금 획득
2. User B가 `model_lock`을 요청 -> `lock_denied` 응답, UI에서 "김분석님이 편집 중입니다" 표시
3. User A가 편집 완료 후 `model_unlock` -> User B에게 잠금 해제 알림
4. User B가 다시 `model_lock`을 요청 -> 잠금 획득, 편집 시작

만약 잠금 없이 동시에 전송된 경우 (네트워크 지연 등):

1. 서버는 `server_version`이 더 높은(나중에 도착한) 이벤트를 최종 값으로 저장
2. 패배한 이벤트의 발신자에게 `conflict_resolved` 메시지를 보내 UI 갱신 유도

#### 시나리오 4: 삭제 충돌

```
User A: criteria "비용" 삭제
User B: criteria "비용" 이름 변경 (아직 삭제를 모름)
```

처리: **삭제가 우선**. User A의 삭제 이벤트가 전파되면 User B의 변경은 무효화된다. User B에게는 "해당 노드가 삭제되었습니다"라는 알림을 보낸다.

### 3.3 낙관적 업데이트(Optimistic Update) 전략

```typescript
// 낙관적 업데이트 흐름

// 1. 사용자가 기준 이름 변경
const handleCriteriaNameChange = (criteriaId: string, newName: string) => {
  // 1a. 클라이언트 ID 생성
  const clientId = crypto.randomUUID();

  // 1b. 로컬 상태를 즉시 업데이트 (낙관적)
  dispatch({
    type: 'OPTIMISTIC_UPDATE',
    payload: { criteriaId, changes: { name: newName }, clientId }
  });

  // 1c. 서버에 이벤트 전송
  ws.send(JSON.stringify({
    type: 'criteria_update',
    data: {
      criteria_id: criteriaId,
      changes: { name: newName },
      persist: true,
    },
    version: currentVersion,
    client_id: clientId,
  }));

  // 1d. 보류 목록에 추가
  pendingUpdates.set(clientId, {
    criteriaId,
    changes: { name: newName },
    timestamp: Date.now(),
  });
};

// 2. 서버 ACK 수신 시
const handleAck = (ack: AckPayload) => {
  // 2a. 보류 목록에서 제거 (성공 확정)
  pendingUpdates.delete(ack.client_id);
  // 2b. 서버 버전 업데이트
  setCurrentVersion(ack.version);
};

// 3. 5초 이내에 ACK가 오지 않으면
const handleAckTimeout = (clientId: string) => {
  const pending = pendingUpdates.get(clientId);
  if (pending) {
    // 3a. 롤백
    dispatch({
      type: 'ROLLBACK_UPDATE',
      payload: { clientId }
    });
    // 3b. 사용자에게 알림
    showNotification('warning', '저장 실패', '변경사항이 서버에 반영되지 않았습니다.');
    pendingUpdates.delete(clientId);
  }
};
```

### 3.4 버전 벡터

```
서버 버전 흐름:

  Client A     Server      Client B
    |            |            |
    | v:42       |            |
    | -------->  |            |
    |            | save(v=43) |
    |  ack(v=43) |            |
    | <--------  |            |
    |            | -------->  |  broadcast(v=43)
    |            |            |
    |            |   v:42     |
    |            | <--------  |  (Client B는 아직 v=42로 알고 있음)
    |            | save(v=44) |
    |            |            |
    |            | -------->  |  ack(v=44)
    |  broadcast |            |
    | <--------- |            |  broadcast(v=44)
```

서버의 `server_version`은 프로젝트당 단일 시퀀스로, 모든 이벤트에 순서를 부여한다. 클라이언트는 자신이 알고 있는 마지막 서버 버전을 `version` 필드에 포함해서 보내며, 서버는 이를 참고하여 순서를 결정한다.

---

## 4. React 클라이언트 설계

### 4.1 `useCollaboration` 훅 - 완전한 TypeScript 코드

```typescript
// src/hooks/useCollaboration.ts

import { useState, useEffect, useRef, useCallback } from 'react';
import authService from '../services/authService';
import { API_BASE_URL } from '../config/api';
import type {
  ClientMessage,
  ServerMessage,
  CollaborationEventType,
  SystemEventType,
  OnlineUser,
  AckPayload,
  HeartbeatAckPayload,
  ErrorPayload,
} from '../types/collaboration';

// ─── 연결 상태 타입 ────────────────────────────────────

export type ConnectionStatus =
  | 'connecting'
  | 'connected'
  | 'reconnecting'
  | 'disconnected';

// ─── 훅 옵션 ───────────────────────────────────────────

export interface UseCollaborationOptions {
  /** 프로젝트 ID */
  projectId: string;
  /** 자동 연결 활성화 (기본: true) */
  autoConnect?: boolean;
  /** 하트비트 간격 ms (기본: 30000) */
  heartbeatInterval?: number;
  /** 최대 재연결 시도 횟수 (기본: 10) */
  maxReconnectAttempts?: number;
  /** ACK 타임아웃 ms (기본: 5000) */
  ackTimeout?: number;
  /** 이벤트 핸들러 */
  onEvent?: (event: ServerMessage) => void;
  /** 연결 상태 변경 핸들러 */
  onStatusChange?: (status: ConnectionStatus) => void;
  /** 에러 핸들러 */
  onError?: (error: ErrorPayload) => void;
}

// ─── 훅 반환 타입 ───────────────────────────────────────

export interface UseCollaborationReturn {
  /** 현재 연결 상태 */
  status: ConnectionStatus;
  /** 온라인 사용자 목록 */
  onlineUsers: OnlineUser[];
  /** 현재 서버 버전 */
  serverVersion: number;
  /** 보류 중인 업데이트 수 */
  pendingCount: number;
  /** 이벤트 전송 */
  sendEvent: (
    type: CollaborationEventType,
    data: Record<string, unknown>,
    options?: { persist?: boolean }
  ) => string; // client_id 반환
  /** 수동 연결 */
  connect: () => void;
  /** 수동 연결 해제 */
  disconnect: () => void;
  /** 재연결 */
  reconnect: () => void;
}

// ─── WebSocket URL 생성 ────────────────────────────────

function buildWebSocketUrl(projectId: string, token: string): string {
  // HTTPS -> WSS, HTTP -> WS 변환
  const wsBase = API_BASE_URL
    .replace('https://', 'wss://')
    .replace('http://', 'ws://');
  return `${wsBase}/ws/project/${projectId}/?token=${encodeURIComponent(token)}`;
}

// ─── 훅 구현 ───────────────────────────────────────────

export function useCollaboration(
  options: UseCollaborationOptions
): UseCollaborationReturn {
  const {
    projectId,
    autoConnect = true,
    heartbeatInterval = 30000,
    maxReconnectAttempts = 10,
    ackTimeout = 5000,
    onEvent,
    onStatusChange,
    onError,
  } = options;

  // ── 상태 ──────────────────────────────────────────

  const [status, setStatus] = useState<ConnectionStatus>('disconnected');
  const [onlineUsers, setOnlineUsers] = useState<OnlineUser[]>([]);
  const [serverVersion, setServerVersion] = useState<number>(0);
  const [pendingCount, setPendingCount] = useState<number>(0);

  // ── Refs (렌더링 사이 유지) ────────────────────────

  const wsRef = useRef<WebSocket | null>(null);
  const heartbeatTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const reconnectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const reconnectAttemptsRef = useRef<number>(0);
  const pendingAcksRef = useRef<
    Map<string, { timer: ReturnType<typeof setTimeout>; resolve: () => void; reject: (err: Error) => void }>
  >(new Map());
  const isManualDisconnectRef = useRef<boolean>(false);
  const statusRef = useRef<ConnectionStatus>('disconnected');
  const onEventRef = useRef(onEvent);
  const onStatusChangeRef = useRef(onStatusChange);
  const onErrorRef = useRef(onError);

  // 콜백 refs를 최신 값으로 유지
  useEffect(() => { onEventRef.current = onEvent; }, [onEvent]);
  useEffect(() => { onStatusChangeRef.current = onStatusChange; }, [onStatusChange]);
  useEffect(() => { onErrorRef.current = onError; }, [onError]);

  // ── 상태 업데이트 헬퍼 ────────────────────────────

  const updateStatus = useCallback((newStatus: ConnectionStatus) => {
    statusRef.current = newStatus;
    setStatus(newStatus);
    onStatusChangeRef.current?.(newStatus);
  }, []);

  // ── 하트비트 관리 ─────────────────────────────────

  const startHeartbeat = useCallback(() => {
    stopHeartbeat();
    heartbeatTimerRef.current = setInterval(() => {
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({
          type: 'heartbeat',
          data: {},
          client_id: crypto.randomUUID(),
        }));
      }
    }, heartbeatInterval);
  }, [heartbeatInterval]);

  const stopHeartbeat = useCallback(() => {
    if (heartbeatTimerRef.current) {
      clearInterval(heartbeatTimerRef.current);
      heartbeatTimerRef.current = null;
    }
  }, []);

  // ── 보류 ACK 정리 ────────────────────────────────

  const clearPendingAcks = useCallback(() => {
    pendingAcksRef.current.forEach(({ timer, reject }) => {
      clearTimeout(timer);
      reject(new Error('Connection closed'));
    });
    pendingAcksRef.current.clear();
    setPendingCount(0);
  }, []);

  // ── 재연결 (Exponential Backoff) ──────────────────

  const scheduleReconnect = useCallback(() => {
    if (isManualDisconnectRef.current) return;
    if (reconnectAttemptsRef.current >= maxReconnectAttempts) {
      console.error(
        `[useCollaboration] 최대 재연결 시도 횟수(${maxReconnectAttempts}) 초과`
      );
      updateStatus('disconnected');
      return;
    }

    updateStatus('reconnecting');

    // Exponential backoff: 1s, 2s, 4s, 8s, ... (최대 30s)
    const baseDelay = 1000;
    const delay = Math.min(
      baseDelay * Math.pow(2, reconnectAttemptsRef.current),
      30000
    );
    // 약간의 지터(jitter) 추가 (0~500ms)
    const jitter = Math.random() * 500;

    console.log(
      `[useCollaboration] ${delay + jitter}ms 후 재연결 시도 ` +
      `(${reconnectAttemptsRef.current + 1}/${maxReconnectAttempts})`
    );

    reconnectTimerRef.current = setTimeout(() => {
      reconnectAttemptsRef.current += 1;
      connectWebSocket();
    }, delay + jitter);
  }, [maxReconnectAttempts, updateStatus]);

  // ── WebSocket 메시지 처리 ─────────────────────────

  const handleMessage = useCallback((rawData: string) => {
    let message: ServerMessage;
    try {
      message = JSON.parse(rawData);
    } catch {
      console.error('[useCollaboration] JSON 파싱 실패:', rawData);
      return;
    }

    const messageType = message.type as string;

    // ACK 처리
    if (messageType === 'ack') {
      const ack = message as unknown as { type: 'ack' } & AckPayload;
      const pending = pendingAcksRef.current.get(ack.client_id);
      if (pending) {
        clearTimeout(pending.timer);
        pending.resolve();
        pendingAcksRef.current.delete(ack.client_id);
        setPendingCount(pendingAcksRef.current.size);
      }
      if (ack.version) {
        setServerVersion(ack.version);
      }
      return;
    }

    // 하트비트 ACK 처리
    if (messageType === 'heartbeat_ack') {
      const hbAck = message.data as unknown as HeartbeatAckPayload;
      if (hbAck?.server_version) {
        setServerVersion(hbAck.server_version);
      }
      return;
    }

    // 프레즌스 동기화 (연결 직후 수신)
    if (messageType === 'presence_sync') {
      const syncData = message as unknown as {
        type: 'presence_sync';
        users: OnlineUser[];
      };
      setOnlineUsers(syncData.users);
      return;
    }

    // 에러 처리
    if (messageType === 'error') {
      const errorData = message.data as unknown as ErrorPayload;
      console.error('[useCollaboration] 서버 에러:', errorData);
      onErrorRef.current?.(errorData);
      return;
    }

    // 사용자 참여/이탈 -> 온라인 목록 업데이트
    if (messageType === 'user_join' && message.user_id) {
      setOnlineUsers(prev => {
        if (prev.some(u => u.user_id === message.user_id)) return prev;
        return [...prev, {
          user_id: message.user_id!,
          user_name: message.user_name || '',
          user_email: '',
          role: (message.data?.role as OnlineUser['role']) || 'viewer',
          connected_at: message.timestamp,
          current_node: null,
        }];
      });
    }

    if (messageType === 'user_leave' && message.user_id) {
      setOnlineUsers(prev =>
        prev.filter(u => u.user_id !== message.user_id)
      );
    }

    // 커서/선택 변경 -> 사용자 상태 업데이트
    if (messageType === 'selection_change' && message.user_id) {
      setOnlineUsers(prev =>
        prev.map(u =>
          u.user_id === message.user_id
            ? { ...u, current_node: message.data?.node_id as string }
            : u
        )
      );
    }

    // 서버 버전 업데이트
    if (message.version) {
      setServerVersion(message.version);
    }

    // 이벤트 콜백 호출
    onEventRef.current?.(message);
  }, []);

  // ── WebSocket 연결 ────────────────────────────────

  const connectWebSocket = useCallback(() => {
    // 기존 연결이 있으면 닫기
    if (wsRef.current) {
      wsRef.current.onclose = null; // 재연결 트리거 방지
      wsRef.current.close();
      wsRef.current = null;
    }

    const token = authService.getAccessToken();
    if (!token) {
      console.error('[useCollaboration] 인증 토큰 없음');
      updateStatus('disconnected');
      return;
    }

    const url = buildWebSocketUrl(projectId, token);
    updateStatus('connecting');

    try {
      const ws = new WebSocket(url);
      wsRef.current = ws;

      ws.onopen = () => {
        console.log('[useCollaboration] WebSocket 연결 성공');
        reconnectAttemptsRef.current = 0;
        updateStatus('connected');
        startHeartbeat();
      };

      ws.onmessage = (event) => {
        handleMessage(event.data);
      };

      ws.onclose = (event) => {
        console.log(
          `[useCollaboration] WebSocket 종료: ` +
          `code=${event.code}, reason=${event.reason}`
        );
        stopHeartbeat();
        clearPendingAcks();

        // 인증 실패 (4001) 또는 권한 없음 (4003)은 재연결하지 않음
        if (event.code === 4001 || event.code === 4003) {
          console.error(
            '[useCollaboration] 인증/권한 실패, 재연결 안 함'
          );
          updateStatus('disconnected');
          onErrorRef.current?.({
            message: event.code === 4001
              ? '인증에 실패했습니다. 다시 로그인해주세요.'
              : '프로젝트 접근 권한이 없습니다.',
            code: event.code === 4001
              ? 'AUTH_FAILED'
              : 'ACCESS_DENIED',
          });
          return;
        }

        // 수동 종료가 아니면 재연결
        if (!isManualDisconnectRef.current) {
          scheduleReconnect();
        } else {
          updateStatus('disconnected');
        }
      };

      ws.onerror = (event) => {
        console.error('[useCollaboration] WebSocket 에러:', event);
        // onclose에서 처리하므로 여기서는 로그만
      };

    } catch (error) {
      console.error(
        '[useCollaboration] WebSocket 생성 실패:', error
      );
      scheduleReconnect();
    }
  }, [
    projectId,
    updateStatus,
    startHeartbeat,
    stopHeartbeat,
    clearPendingAcks,
    handleMessage,
    scheduleReconnect,
  ]);

  // ── 이벤트 전송 ──────────────────────────────────

  const sendEvent = useCallback((
    type: CollaborationEventType,
    data: Record<string, unknown>,
    sendOptions?: { persist?: boolean }
  ): string => {
    const clientId = crypto.randomUUID();

    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
      console.warn(
        '[useCollaboration] WebSocket이 연결되지 않음, 이벤트 버퍼링'
      );
      // TODO: 오프라인 큐 구현
      return clientId;
    }

    const message: ClientMessage = {
      type,
      data: sendOptions?.persist
        ? { ...data, persist: true }
        : data,
      version: serverVersion,
      client_id: clientId,
    };

    wsRef.current.send(JSON.stringify(message));

    // ACK 대기 등록 (cursor_move, heartbeat 등 경량 이벤트 제외)
    const noAckEvents: string[] = [
      'cursor_move', 'selection_change', 'heartbeat'
    ];
    if (!noAckEvents.includes(type)) {
      const ackPromise = new Promise<void>((resolve, reject) => {
        const timer = setTimeout(() => {
          pendingAcksRef.current.delete(clientId);
          setPendingCount(pendingAcksRef.current.size);
          reject(new Error(`ACK timeout for ${clientId}`));
        }, ackTimeout);

        pendingAcksRef.current.set(clientId, {
          timer, resolve, reject
        });
        setPendingCount(pendingAcksRef.current.size);
      });

      // ACK 타임아웃 시 에러 핸들링 (비동기)
      ackPromise.catch((err) => {
        console.warn(
          `[useCollaboration] ACK 타임아웃: ${clientId}`, err
        );
        onErrorRef.current?.({
          message: '서버 응답 시간 초과',
          code: 'ACK_TIMEOUT',
        });
      });
    }

    return clientId;
  }, [serverVersion, ackTimeout]);

  // ── 공개 메서드 ───────────────────────────────────

  const connect = useCallback(() => {
    isManualDisconnectRef.current = false;
    reconnectAttemptsRef.current = 0;
    connectWebSocket();
  }, [connectWebSocket]);

  const disconnect = useCallback(() => {
    isManualDisconnectRef.current = true;
    if (reconnectTimerRef.current) {
      clearTimeout(reconnectTimerRef.current);
      reconnectTimerRef.current = null;
    }
    stopHeartbeat();
    clearPendingAcks();
    if (wsRef.current) {
      wsRef.current.close(1000, 'Manual disconnect');
      wsRef.current = null;
    }
    updateStatus('disconnected');
  }, [stopHeartbeat, clearPendingAcks, updateStatus]);

  const reconnect = useCallback(() => {
    isManualDisconnectRef.current = false;
    reconnectAttemptsRef.current = 0;
    if (wsRef.current) {
      wsRef.current.onclose = null;
      wsRef.current.close();
      wsRef.current = null;
    }
    connectWebSocket();
  }, [connectWebSocket]);

  // ── 수명주기 ─────────────────────────────────────

  useEffect(() => {
    if (autoConnect && projectId) {
      connect();
    }

    return () => {
      isManualDisconnectRef.current = true;
      stopHeartbeat();
      clearPendingAcks();
      if (reconnectTimerRef.current) {
        clearTimeout(reconnectTimerRef.current);
      }
      if (wsRef.current) {
        wsRef.current.onclose = null;
        wsRef.current.close(1000, 'Component unmount');
        wsRef.current = null;
      }
    };
  }, [projectId, autoConnect]);

  // ── 토큰 만료 감지 ───────────────────────────────

  useEffect(() => {
    const handleTokenExpired = () => {
      console.warn(
        '[useCollaboration] 토큰 만료 감지, 연결 종료'
      );
      disconnect();
    };

    window.addEventListener('auth:tokenExpired', handleTokenExpired);
    return () => {
      window.removeEventListener('auth:tokenExpired', handleTokenExpired);
    };
  }, [disconnect]);

  // ── 반환 ─────────────────────────────────────────

  return {
    status,
    onlineUsers,
    serverVersion,
    pendingCount,
    sendEvent,
    connect,
    disconnect,
    reconnect,
  };
}

export default useCollaboration;
```

### 4.2 재연결 전략 (Exponential Backoff) 상세

```
시도 1: 1000ms + jitter(0~500ms) 후 재연결
시도 2: 2000ms + jitter 후 재연결
시도 3: 4000ms + jitter 후 재연결
시도 4: 8000ms + jitter 후 재연결
시도 5: 16000ms + jitter 후 재연결
시도 6~10: 30000ms + jitter 후 재연결 (최대 30초)
시도 11: 포기 -> status = 'disconnected'
```

**재연결하지 않는 경우**:
- WebSocket close code `4001` (인증 실패)
- WebSocket close code `4003` (권한 없음)
- 사용자가 수동으로 `disconnect()` 호출
- 컴포넌트 언마운트

**재연결 시 토큰 갱신**: 재연결 시도 전에 `authService.getAccessToken()`을 다시 호출하므로, 토큰이 만료 전에 자동 갱신(`initTokenRefresh`)되어 있으면 새 토큰으로 연결한다.

### 4.3 연결 상태 관리

```
[disconnected] --connect()--> [connecting]
                               |
                     onopen    |    onerror/onclose
                       |       v        |
                  [connected] <---------+
                       |                |
                   onclose              |
                   (비정상)             |
                       |                |
                  [reconnecting] -------+
                       |        (재시도 성공)
                       |
                (최대 시도 초과)
                       |
                  [disconnected]
```

### 4.4 커서/프레즌스 표시 방법

프레즌스 정보는 `useCollaboration` 훅의 `onlineUsers` 상태로 관리된다. 커서 표시는 기존 `RealTimeCollaboration.tsx`의 `renderUserCursors()` 로직을 재사용하되, 데이터 소스를 WebSocket으로 교체한다.

```typescript
// RealTimeCollaboration.tsx에서의 사용 예시

const {
  status,
  onlineUsers,
  sendEvent,
} = useCollaboration({
  projectId: modelId,
  onEvent: (event) => {
    switch (event.type) {
      case 'cursor_move':
        // 다른 사용자 커서 위치 업데이트
        setCursorPositions(prev => ({
          ...prev,
          [event.user_id!]: {
            x: event.data.x as number,
            y: event.data.y as number,
          },
        }));
        break;

      case 'criteria_update':
      case 'alternative_update':
        // 모델 변경 반영
        onModelChange?.(/* 새로운 계층 구조 */);
        break;

      case 'chat_message':
        // 채팅 메시지 추가
        const msgData = event.data as ChatMessageServerPayload;
        setChatMessages(prev => [...prev, {
          id: msgData.message_id,
          userId: event.user_id!,
          userName: event.user_name!,
          message: msgData.message,
          timestamp: event.timestamp,
          type: 'text',
          mentions: msgData.mentions,
        }]);
        break;
    }
  },
});

// 커서 이동 전송 (스로틀링 적용)
const throttledCursorMove = useThrottle((x: number, y: number) => {
  sendEvent('cursor_move', { x, y });
}, 100);

// 노드 선택 전송
const handleNodeSelect = (nodeId: string) => {
  sendEvent('selection_change', {
    node_id: nodeId,
    node_type: 'criteria',
  });
};
```

**커서 렌더링**: 기존 `renderUserCursors()` 함수를 그대로 사용한다. `onlineUsers`의 각 사용자에 대해 `cursorPositions` 맵에서 좌표를 조회하여 화면에 표시한다. 색상은 기존 `generateUserColor()` 함수를 사용한다.

**프레즌스 인디케이터**: 노드 편집 중인 사용자를 표시하기 위해 `onlineUsers`의 `current_node` 필드를 사용한다. 트리 에디터에서 각 노드 옆에 편집 중인 사용자의 아바타를 표시한다.

---

## 5. 구현 우선순위 및 일정

### 5.1 단계별 구현 계획

#### Phase 2b-1: 최소 기능 (MVP) -- 예상 12시간

**목표**: WebSocket 연결이 성립하고, 한 사용자의 변경이 다른 사용자에게 전달되는 것을 확인

| 순서 | 작업 | 담당 | 예상 시간 |
|------|------|------|----------|
| 1 | `collaboration` Django 앱 생성, 모델 정의 (`CollaborationEventLog`, `CollaborationPresence`) | Sonnet | 1.5h |
| 2 | Django Channels 설치 및 ASGI 설정, Redis Channel Layer 연결 | Sonnet | 1.5h |
| 3 | `TokenAuthMiddleware` 구현 (JWT 쿼리 파라미터 검증) | Sonnet | 1h |
| 4 | `AHPProjectConsumer` 기본 구현 (`connect`, `disconnect`, `receive_json`, 기본 브로드캐스트) | Sonnet | 2h |
| 5 | `src/types/collaboration.ts` 타입 정의 | Opus | 0.5h |
| 6 | `useCollaboration` 훅 구현 (연결, 메시지 송수신, 재연결) | Opus | 2.5h |
| 7 | `RealTimeCollaboration.tsx` 리팩토링 (SSE -> WebSocket 교체) | Opus | 2h |
| 8 | 통합 테스트 (두 브라우저 탭에서 동시 편집 확인) | 공동 | 1h |

**MVP 완료 기준**:
- 두 사용자가 같은 프로젝트에 WebSocket으로 연결
- 한쪽에서 기준 이름을 변경하면 다른 쪽에 즉시 반영
- 사용자 참여/이탈 시 알림 표시
- 연결 끊김 시 자동 재연결

#### Phase 2b-2: 핵심 기능 -- 예상 8시간

**목표**: 채팅, 노드 잠금, 프레즌스, 오프라인 큐 구현

| 순서 | 작업 | 담당 | 예상 시간 |
|------|------|------|----------|
| 1 | `CollaborationChatMessage`, `CollaborationLock` 모델 추가 | Sonnet | 0.5h |
| 2 | Consumer에 채팅 메시지 핸들러 추가 | Sonnet | 1h |
| 3 | Consumer에 노드 잠금/해제 핸들러 추가 | Sonnet | 1.5h |
| 4 | 커서 이동/선택 변경 프레즌스 이벤트 처리 | Sonnet | 1h |
| 5 | 프론트엔드 채팅 UI WebSocket 연결 | Opus | 1h |
| 6 | 프론트엔드 노드 잠금 UI (편집 중 표시) | Opus | 1.5h |
| 7 | 오프라인 이벤트 큐 (`localStorage` 기반) | Opus | 1h |
| 8 | 통합 테스트 | 공동 | 0.5h |

**완료 기준**:
- 채팅 메시지가 실시간으로 전달
- 노드 편집 시 다른 사용자에게 잠금 표시
- 오프라인 시 변경사항이 큐에 저장, 재연결 시 자동 전송

#### Phase 2b-3: 완전 기능 -- 예상 6시간

**목표**: ACK 시스템, 낙관적 업데이트 롤백, 서버 버전 동기화, 성능 최적화

| 순서 | 작업 | 담당 | 예상 시간 |
|------|------|------|----------|
| 1 | 서버 측 ACK 시스템 구현 (`server_version` 부여) | Sonnet | 1.5h |
| 2 | 클라이언트 ACK 타임아웃 및 롤백 구현 | Opus | 1.5h |
| 3 | 커서 이동 스로틀링 (100ms) 적용 | Opus | 0.5h |
| 4 | 하트비트 기반 비활성 사용자 자동 정리 (서버) | Sonnet | 1h |
| 5 | 성능 테스트 (10명 동시 접속 시뮬레이션) | 공동 | 1h |
| 6 | 에러 핸들링 고도화 (UI 알림 통합) | Opus | 0.5h |

**완료 기준**:
- 서버 ACK가 5초 이내에 오지 않으면 낙관적 업데이트 롤백
- 비정상 종료된 사용자가 60초 후 자동으로 오프라인 처리
- 10명 동시 접속 시에도 100ms 이내 이벤트 전파

### 5.2 전체 일정 요약

```
Phase 2b-1 (MVP)      : 12시간  -- 필수
Phase 2b-2 (핵심 기능) :  8시간  -- 필수
Phase 2b-3 (완전 기능) :  6시간  -- 권장
────────────────────────────────
합계                   : 26시간
```

### 5.3 배포 고려사항

| 항목 | 세부 사항 |
|------|----------|
| **Render.com WebSocket 지원** | Render.com의 Web Service는 WebSocket을 네이티브로 지원함. 별도 설정 불필요 |
| **Redis 프로비저닝** | Render.com의 Redis 인스턴스 사용 또는 Upstash Redis (서버리스, 무료 티어 10,000 커맨드/일) |
| **CORS/Origin 허용** | Django settings의 `ALLOWED_HOSTS`에 `aebonlee.github.io` 추가 필요. Channels의 `AllowedHostsOriginValidator`가 Origin을 검증 |
| **Daphne vs Uvicorn** | ASGI 서버로 Daphne(Django Channels 공식) 또는 Uvicorn 사용. Render.com에서는 `daphne config.asgi:application --port $PORT --bind 0.0.0.0` |
| **SSL 종료** | Render.com이 SSL 종료를 처리하므로 백엔드에서는 `ws://`로 내부 통신, 클라이언트는 `wss://`로 연결 |

### 5.4 의존성 패키지

**백엔드 (pip)**:
```
channels==4.0.0
channels-redis==4.1.0
daphne==4.0.0
```

**프론트엔드**: WebSocket은 브라우저 내장 API를 사용하므로 추가 의존성 없음.

---

## 부록 A: 기존 코드와의 통합 전략

### RealTimeSyncManager 교체 방법

기존 `src/utils/realTimeSync.ts`의 `RealTimeSyncManager` 클래스는 SSE 기반이다. 이를 완전히 교체하는 대신, `useCollaboration` 훅이 WebSocket 연결을 전담하고, `RealTimeSyncManager`는 **오프라인 큐 관리 전용**으로 축소한다.

```
기존: RealTimeSyncManager (SSE + REST + 오프라인 큐 + 충돌 감지)
변경: useCollaboration 훅 (WebSocket + 재연결 + ACK)
     + RealTimeSyncManager (오프라인 큐만 담당, 선택적)
```

### RealTimeCollaboration.tsx 수정 포인트

1. `syncManager` 상태 제거 -> `useCollaboration` 훅으로 대체
2. `initializeRealTimeSync()` -> `useCollaboration`의 `autoConnect`
3. `sendEvent()` -> `useCollaboration`의 `sendEvent()`
4. `isConnected` -> `useCollaboration`의 `status === 'connected'`
5. Mock 사용자 생성 로직 제거 (서버에서 실제 사용자 제공)
6. `connectionQuality` -> `status` + `pendingCount`로 판단

---

## 부록 B: 보안 고려사항

1. **토큰 노출 최소화**: WebSocket URL의 쿼리 파라미터에 JWT가 포함되므로, 서버 로그에서 URL 파라미터를 마스킹해야 한다.

2. **프로젝트 접근 권한**: Consumer의 `connect()`에서 `check_project_access()`로 프로젝트 소유자 또는 등록된 평가자만 연결을 허용한다.

3. **이벤트 데이터 검증**: 클라이언트가 보낸 `data` 필드를 그대로 브로드캐스트하지 않고, 서버에서 검증 후 필요한 필드만 전달한다 (특히 `evaluation_submit`에서 다른 사용자의 비교 값은 전파하지 않음).

4. **Rate Limiting**: `cursor_move` 이벤트는 클라이언트에서 100ms 스로틀링을 적용하지만, 서버에서도 초당 10회 이상의 프레즌스 이벤트는 무시한다.

5. **잠금 데드락 방지**: `CollaborationLock`에 30초 TTL을 적용하여, 비정상 종료 시에도 잠금이 자동으로 해제된다.
