# ğŸ” AHP í‰ê°€ ì´ˆëŒ€ ì‹œìŠ¤í…œ ìƒì„¸ ì„¤ê³„
**ì‘ì„±ì¼**: 2024-11-29  
**ì‘ì„±ì**: Claude Opus 4.1  
**ë²„ì „**: 1.0

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ëª©ì 
AHP í‰ê°€ í”„ë¡œì„¸ìŠ¤ì— ì™¸ë¶€ ì „ë¬¸ê°€ ë° ì´í•´ê´€ê³„ìë¥¼ ì•ˆì „í•˜ê²Œ ì´ˆëŒ€í•˜ê³ , ì„¸ë¶„í™”ëœ ê¶Œí•œ ê´€ë¦¬ë¥¼ í†µí•´ í˜‘ì—…ì  ì˜ì‚¬ê²°ì •ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ì‹œìŠ¤í…œ

### 1.2 í•µì‹¬ ìš”êµ¬ì‚¬í•­
- ì´ë©”ì¼ ê¸°ë°˜ ì´ˆëŒ€ ë°œì†¡ ë° ê´€ë¦¬
- JWT í† í° ê¸°ë°˜ ë³´ì•ˆ ì¸ì¦
- ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´ (RBAC)
- ì´ˆëŒ€ ìƒíƒœ ì‹¤ì‹œê°„ ì¶”ì 
- ë§Œë£Œ ì‹œê°„ ìë™ ê´€ë¦¬
- ê¶Œí•œ ì„¸ë¶„í™” ë° ë™ì  í• ë‹¹

---

## 2. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 2.1 ì „ì²´ êµ¬ì¡°
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Frontend (React)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Invitation Management UI               â”‚
â”‚         â”œâ”€â”€ InviteModal Component                â”‚
â”‚         â”œâ”€â”€ ParticipantList Component            â”‚
â”‚         â””â”€â”€ PermissionMatrix Component           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                    WebSocket/REST
                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Backend (Django)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Invitation Service Layer                 â”‚
â”‚         â”œâ”€â”€ Token Generator                      â”‚
â”‚         â”œâ”€â”€ Permission Manager                   â”‚
â”‚         â””â”€â”€ Email Queue Manager                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Data Layer                          â”‚
â”‚         â”œâ”€â”€ PostgreSQL (Main DB)                 â”‚
â”‚         â”œâ”€â”€ Redis (Token Cache)                  â”‚
â”‚         â””â”€â”€ Celery (Task Queue)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ë°ì´í„° í”Œë¡œìš°
```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant B as Backend
    participant E as Email Service
    participant I as Invitee
    
    U->>F: ì´ˆëŒ€ ìš”ì²­
    F->>B: POST /api/invitations/send
    B->>B: í† í° ìƒì„± & ì €ì¥
    B->>E: ì´ë©”ì¼ í ì¶”ê°€
    B-->>F: ì´ˆëŒ€ ID ë°˜í™˜
    E->>I: ì´ˆëŒ€ ì´ë©”ì¼ ë°œì†¡
    I->>B: GET /api/invitations/validate?token=xxx
    B->>B: í† í° ê²€ì¦
    B-->>I: í”„ë¡œì íŠ¸ ì •ë³´ ë°˜í™˜
    I->>B: POST /api/invitations/accept
    B->>B: ê¶Œí•œ í• ë‹¹ & í™œì„±í™”
    B-->>I: ì•¡ì„¸ìŠ¤ í† í° ë°œê¸‰
```

---

## 3. ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„

### 3.1 í•µì‹¬ í…Œì´ë¸” ìŠ¤í‚¤ë§ˆ

```sql
-- ì´ˆëŒ€ í…Œì´ë¸”
CREATE TABLE evaluation_invitations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    inviter_id UUID NOT NULL REFERENCES users(id),
    invitee_email VARCHAR(255) NOT NULL,
    invitee_name VARCHAR(100),
    token VARCHAR(512) UNIQUE NOT NULL,
    token_hash VARCHAR(256) NOT NULL, -- ë³´ì•ˆì„ ìœ„í•œ í•´ì‹œê°’
    role VARCHAR(50) NOT NULL DEFAULT 'evaluator',
    custom_message TEXT,
    permissions JSONB NOT NULL DEFAULT '{}',
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    expires_at TIMESTAMP NOT NULL,
    reminder_count INT DEFAULT 0,
    last_reminder_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    accepted_at TIMESTAMP,
    rejected_at TIMESTAMP,
    revoked_at TIMESTAMP,
    
    -- ì¸ë±ìŠ¤
    INDEX idx_token_hash (token_hash),
    INDEX idx_project_status (project_id, status),
    INDEX idx_invitee_email (invitee_email),
    INDEX idx_expires_at (expires_at)
);

-- ì°¸ì—¬ì ê¶Œí•œ í…Œì´ë¸”
CREATE TABLE participant_permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    invitation_id UUID REFERENCES evaluation_invitations(id),
    
    -- ì—­í•  ì •ì˜
    role VARCHAR(50) NOT NULL,
    role_priority INT NOT NULL DEFAULT 100,
    
    -- ì„¸ë¶€ ê¶Œí•œ
    can_view_project BOOLEAN DEFAULT true,
    can_view_criteria BOOLEAN DEFAULT true,
    can_view_evaluations BOOLEAN DEFAULT true,
    can_view_results BOOLEAN DEFAULT false,
    can_create_evaluation BOOLEAN DEFAULT false,
    can_edit_own_evaluation BOOLEAN DEFAULT false,
    can_edit_all_evaluations BOOLEAN DEFAULT false,
    can_manage_criteria BOOLEAN DEFAULT false,
    can_invite_others BOOLEAN DEFAULT false,
    can_export_data BOOLEAN DEFAULT false,
    can_delete_project BOOLEAN DEFAULT false,
    
    -- ë©”íƒ€ë°ì´í„°
    assigned_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP,
    
    -- ë³µí•© ìœ ë‹ˆí¬ ì œì•½
    UNIQUE(user_id, project_id)
);

-- ì´ˆëŒ€ í™œë™ ë¡œê·¸
CREATE TABLE invitation_activities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    invitation_id UUID NOT NULL REFERENCES evaluation_invitations(id),
    action VARCHAR(50) NOT NULL,
    actor_id UUID REFERENCES users(id),
    actor_ip INET,
    user_agent TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT NOW(),
    
    INDEX idx_invitation_activities (invitation_id, created_at DESC)
);

-- ê¶Œí•œ í…œí”Œë¦¿ (ì‚¬ì „ ì •ì˜ëœ ì—­í• )
CREATE TABLE permission_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    permissions JSONB NOT NULL,
    is_system BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT NOW()
);
```

### 3.2 ì—­í•  ë° ê¶Œí•œ ë§¤íŠ¸ë¦­ìŠ¤

```python
ROLE_PERMISSIONS = {
    'owner': {
        'priority': 0,
        'permissions': {
            'can_view_project': True,
            'can_view_criteria': True,
            'can_view_evaluations': True,
            'can_view_results': True,
            'can_create_evaluation': True,
            'can_edit_own_evaluation': True,
            'can_edit_all_evaluations': True,
            'can_manage_criteria': True,
            'can_invite_others': True,
            'can_export_data': True,
            'can_delete_project': True
        }
    },
    'admin': {
        'priority': 10,
        'permissions': {
            'can_view_project': True,
            'can_view_criteria': True,
            'can_view_evaluations': True,
            'can_view_results': True,
            'can_create_evaluation': True,
            'can_edit_own_evaluation': True,
            'can_edit_all_evaluations': True,
            'can_manage_criteria': True,
            'can_invite_others': True,
            'can_export_data': True,
            'can_delete_project': False
        }
    },
    'evaluator': {
        'priority': 50,
        'permissions': {
            'can_view_project': True,
            'can_view_criteria': True,
            'can_view_evaluations': False,
            'can_view_results': False,
            'can_create_evaluation': True,
            'can_edit_own_evaluation': True,
            'can_edit_all_evaluations': False,
            'can_manage_criteria': False,
            'can_invite_others': False,
            'can_export_data': False,
            'can_delete_project': False
        }
    },
    'viewer': {
        'priority': 100,
        'permissions': {
            'can_view_project': True,
            'can_view_criteria': True,
            'can_view_evaluations': True,
            'can_view_results': True,
            'can_create_evaluation': False,
            'can_edit_own_evaluation': False,
            'can_edit_all_evaluations': False,
            'can_manage_criteria': False,
            'can_invite_others': False,
            'can_export_data': True,
            'can_delete_project': False
        }
    }
}
```

---

## 4. ë³´ì•ˆ í† í° ì‹œìŠ¤í…œ

### 4.1 JWT í† í° êµ¬ì¡°

```python
import jwt
import secrets
from datetime import datetime, timedelta
from typing import Dict, Any

class InvitationTokenManager:
    """ì´ˆëŒ€ í† í° ìƒì„± ë° ê²€ì¦ ê´€ë¦¬ì"""
    
    def __init__(self, secret_key: str, algorithm: str = 'HS256'):
        self.secret_key = secret_key
        self.algorithm = algorithm
        self.token_length = 32  # URL-safe token length
    
    def generate_invitation_token(
        self,
        invitation_id: str,
        project_id: str,
        invitee_email: str,
        role: str,
        expires_in_days: int = 7
    ) -> Dict[str, Any]:
        """ë³´ì•ˆ ì´ˆëŒ€ í† í° ìƒì„±"""
        
        # 1. ê³ ìœ  í† í° ìƒì„±
        url_token = secrets.token_urlsafe(self.token_length)
        
        # 2. JWT í˜ì´ë¡œë“œ êµ¬ì„±
        payload = {
            'invitation_id': invitation_id,
            'project_id': project_id,
            'email': invitee_email,
            'role': role,
            'token': url_token,
            'iat': datetime.utcnow(),
            'exp': datetime.utcnow() + timedelta(days=expires_in_days),
            'type': 'invitation'
        }
        
        # 3. JWT í† í° ìƒì„±
        jwt_token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
        
        # 4. í† í° í•´ì‹œ (DB ì €ì¥ìš©)
        import hashlib
        token_hash = hashlib.sha256(url_token.encode()).hexdigest()
        
        return {
            'url_token': url_token,
            'jwt_token': jwt_token,
            'token_hash': token_hash,
            'expires_at': payload['exp']
        }
    
    def verify_invitation_token(self, token: str) -> Dict[str, Any]:
        """í† í° ê²€ì¦ ë° ì •ë³´ ì¶”ì¶œ"""
        
        try:
            # JWT ë””ì½”ë”©
            payload = jwt.decode(
                token, 
                self.secret_key, 
                algorithms=[self.algorithm]
            )
            
            # í† í° íƒ€ì… í™•ì¸
            if payload.get('type') != 'invitation':
                raise ValueError("Invalid token type")
            
            # ë§Œë£Œ ì‹œê°„ í™•ì¸
            if datetime.utcnow() > datetime.fromtimestamp(payload['exp']):
                raise jwt.ExpiredSignatureError("Token has expired")
            
            return {
                'valid': True,
                'payload': payload
            }
            
        except jwt.ExpiredSignatureError:
            return {'valid': False, 'error': 'Token expired'}
        except jwt.InvalidTokenError:
            return {'valid': False, 'error': 'Invalid token'}
        except Exception as e:
            return {'valid': False, 'error': str(e)}
```

### 4.2 í† í° ìºì‹± ì „ëµ (Redis)

```python
import redis
import json
from typing import Optional

class TokenCache:
    """Redis ê¸°ë°˜ í† í° ìºì‹œ ê´€ë¦¬"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.prefix = "invitation:token:"
    
    def set_token(
        self, 
        token_hash: str, 
        invitation_data: dict, 
        ttl_seconds: int
    ):
        """í† í° ì •ë³´ ìºì‹±"""
        key = f"{self.prefix}{token_hash}"
        self.redis.setex(
            key,
            ttl_seconds,
            json.dumps(invitation_data)
        )
    
    def get_token(self, token_hash: str) -> Optional[dict]:
        """ìºì‹œëœ í† í° ì •ë³´ ì¡°íšŒ"""
        key = f"{self.prefix}{token_hash}"
        data = self.redis.get(key)
        return json.loads(data) if data else None
    
    def invalidate_token(self, token_hash: str):
        """í† í° ë¬´íš¨í™”"""
        key = f"{self.prefix}{token_hash}"
        self.redis.delete(key)
    
    def extend_token_ttl(self, token_hash: str, additional_seconds: int):
        """í† í° ë§Œë£Œ ì‹œê°„ ì—°ì¥"""
        key = f"{self.prefix}{token_hash}"
        current_ttl = self.redis.ttl(key)
        if current_ttl > 0:
            self.redis.expire(key, current_ttl + additional_seconds)
```

---

## 5. ì´ë©”ì¼ ë°œì†¡ ì‹œìŠ¤í…œ

### 5.1 Celery í ì„¤ê³„

```python
from celery import Celery, Task
from typing import Dict, List
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Celery ì„¤ì •
celery_app = Celery('ahp_platform')
celery_app.config_from_object('django.conf:settings', namespace='CELERY')

class EmailTask(Task):
    """ì´ë©”ì¼ ë°œì†¡ ê¸°ë³¸ íƒœìŠ¤í¬"""
    
    autoretry_for = (smtplib.SMTPException,)
    retry_kwargs = {'max_retries': 3}
    retry_backoff = True
    retry_backoff_max = 600
    retry_jitter = True

@celery_app.task(base=EmailTask, name='send_invitation_email')
def send_invitation_email(
    invitation_id: str,
    recipient_email: str,
    invitation_data: Dict
) -> bool:
    """ì´ˆëŒ€ ì´ë©”ì¼ ë¹„ë™ê¸° ë°œì†¡"""
    
    try:
        # ì´ë©”ì¼ í…œí”Œë¦¿ ë Œë”ë§
        email_content = render_invitation_template(invitation_data)
        
        # ì´ë©”ì¼ êµ¬ì„±
        message = MIMEMultipart('alternative')
        message['Subject'] = f"ì´ˆëŒ€: {invitation_data['project_name']} í‰ê°€ ì°¸ì—¬"
        message['From'] = settings.EMAIL_FROM
        message['To'] = recipient_email
        
        # HTML ë° í…ìŠ¤íŠ¸ ë²„ì „ ì¶”ê°€
        html_part = MIMEText(email_content['html'], 'html')
        text_part = MIMEText(email_content['text'], 'plain')
        
        message.attach(text_part)
        message.attach(html_part)
        
        # SMTP ë°œì†¡
        with smtplib.SMTP(settings.EMAIL_HOST, settings.EMAIL_PORT) as server:
            server.starttls()
            server.login(settings.EMAIL_HOST_USER, settings.EMAIL_HOST_PASSWORD)
            server.send_message(message)
        
        # ë°œì†¡ ë¡œê·¸ ê¸°ë¡
        log_email_sent(invitation_id, recipient_email, 'success')
        return True
        
    except Exception as e:
        log_email_sent(invitation_id, recipient_email, 'failed', str(e))
        raise

@celery_app.task(name='send_reminder_email')
def send_reminder_email(invitation_id: str) -> bool:
    """ë¯¸ìˆ˜ë½ ì´ˆëŒ€ ë¦¬ë§ˆì¸ë” ë°œì†¡"""
    
    invitation = get_invitation(invitation_id)
    
    if invitation.status != 'pending':
        return False
    
    if invitation.reminder_count >= 3:
        return False
    
    # ë¦¬ë§ˆì¸ë” ë°œì†¡
    send_invitation_email.delay(
        invitation_id,
        invitation.invitee_email,
        prepare_reminder_data(invitation)
    )
    
    # ë¦¬ë§ˆì¸ë” ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
    invitation.reminder_count += 1
    invitation.last_reminder_at = datetime.utcnow()
    invitation.save()
    
    return True
```

### 5.2 ì´ë©”ì¼ í…œí”Œë¦¿ ì‹œìŠ¤í…œ

```python
from jinja2 import Template

class InvitationEmailTemplate:
    """ì´ˆëŒ€ ì´ë©”ì¼ í…œí”Œë¦¿ ê´€ë¦¬"""
    
    HTML_TEMPLATE = """
    <!DOCTYPE html>
    <html>
    <head>
        <style>
            .container { max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }
            .header { background: #4CAF50; color: white; padding: 20px; text-align: center; }
            .content { padding: 30px; background: #f5f5f5; }
            .button { 
                display: inline-block; 
                padding: 12px 30px; 
                background: #4CAF50; 
                color: white; 
                text-decoration: none; 
                border-radius: 5px;
                margin: 20px 0;
            }
            .footer { padding: 20px; text-align: center; color: #666; font-size: 12px; }
            .permissions { background: white; padding: 15px; margin: 20px 0; border-radius: 5px; }
            .permission-item { padding: 5px 0; }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>AHP í‰ê°€ ì´ˆëŒ€</h1>
            </div>
            <div class="content">
                <h2>ì•ˆë…•í•˜ì„¸ìš”, {{ invitee_name }}ë‹˜</h2>
                <p>{{ inviter_name }}ë‹˜ì´ '{{ project_name }}' í”„ë¡œì íŠ¸ì˜ í‰ê°€ì— ì°¸ì—¬í•˜ë„ë¡ ì´ˆëŒ€í–ˆìŠµë‹ˆë‹¤.</p>
                
                {% if custom_message %}
                <div style="background: white; padding: 15px; margin: 20px 0; border-left: 4px solid #4CAF50;">
                    <strong>ì´ˆëŒ€ ë©”ì‹œì§€:</strong><br>
                    {{ custom_message }}
                </div>
                {% endif %}
                
                <div class="permissions">
                    <h3>ê·€í•˜ì˜ ì—­í• : {{ role }}</h3>
                    <div class="permission-item">âœ“ í”„ë¡œì íŠ¸ ë° í‰ê°€ ê¸°ì¤€ ì—´ëŒ</div>
                    {% if can_evaluate %}
                    <div class="permission-item">âœ“ í‰ê°€ ì°¸ì—¬ ë° ì˜ê²¬ ì œì‹œ</div>
                    {% endif %}
                    {% if can_view_results %}
                    <div class="permission-item">âœ“ í‰ê°€ ê²°ê³¼ í™•ì¸</div>
                    {% endif %}
                </div>
                
                <div style="text-align: center;">
                    <a href="{{ accept_url }}" class="button">ì´ˆëŒ€ ìˆ˜ë½í•˜ê¸°</a>
                </div>
                
                <p style="color: #666; font-size: 14px;">
                    ì´ ì´ˆëŒ€ëŠ” {{ expires_at }}ê¹Œì§€ ìœ íš¨í•©ë‹ˆë‹¤.<br>
                    ì´ˆëŒ€ë¥¼ ìˆ˜ë½í•˜ì§€ ì•Šìœ¼ë ¤ë©´ ì´ ì´ë©”ì¼ì„ ë¬´ì‹œí•˜ì…”ë„ ë©ë‹ˆë‹¤.
                </p>
            </div>
            <div class="footer">
                <p>ì´ ì´ë©”ì¼ì€ AHP ì˜ì‚¬ê²°ì • í”Œë«í¼ì—ì„œ ìë™ìœ¼ë¡œ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
                <p>ë¬¸ì˜ì‚¬í•­ì´ ìˆìœ¼ì‹œë©´ {{ support_email }}ë¡œ ì—°ë½ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤.</p>
            </div>
        </div>
    </body>
    </html>
    """
    
    @classmethod
    def render(cls, context: dict) -> str:
        """í…œí”Œë¦¿ ë Œë”ë§"""
        template = Template(cls.HTML_TEMPLATE)
        return template.render(**context)
```

---

## 6. API ì—”ë“œí¬ì¸íŠ¸ ì„¤ê³„

### 6.1 REST API ëª…ì„¸

```python
from rest_framework import serializers, viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response

class InvitationSerializer(serializers.ModelSerializer):
    """ì´ˆëŒ€ ì‹œë¦¬ì–¼ë¼ì´ì €"""
    
    class Meta:
        model = EvaluationInvitation
        fields = [
            'id', 'project_id', 'invitee_email', 'invitee_name',
            'role', 'custom_message', 'permissions', 'status',
            'expires_at', 'created_at', 'accepted_at'
        ]
        read_only_fields = ['id', 'status', 'created_at', 'accepted_at']
    
    def validate_permissions(self, value):
        """ê¶Œí•œ ìœ íš¨ì„± ê²€ì¦"""
        allowed_permissions = set(ROLE_PERMISSIONS['viewer']['permissions'].keys())
        provided_permissions = set(value.keys())
        
        if not provided_permissions.issubset(allowed_permissions):
            raise serializers.ValidationError("Invalid permissions provided")
        
        return value

class InvitationViewSet(viewsets.ModelViewSet):
    """ì´ˆëŒ€ ê´€ë¦¬ ViewSet"""
    
    serializer_class = InvitationSerializer
    permission_classes = [IsAuthenticated, HasProjectPermission]
    
    def get_queryset(self):
        """í”„ë¡œì íŠ¸ë³„ ì´ˆëŒ€ ëª©ë¡ ì¡°íšŒ"""
        user = self.request.user
        project_id = self.request.query_params.get('project_id')
        
        queryset = EvaluationInvitation.objects.filter(
            project_id=project_id
        ).select_related('project', 'inviter')
        
        # ê¶Œí•œì— ë”°ë¥¸ í•„í„°ë§
        if not user.has_perm('can_invite_others', project_id):
            queryset = queryset.filter(inviter=user)
        
        return queryset
    
    @action(detail=False, methods=['post'])
    def send(self, request):
        """ì´ˆëŒ€ ë°œì†¡ API"""
        
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # ì´ˆëŒ€ ìƒì„±
        invitation = serializer.save(inviter=request.user)
        
        # í† í° ìƒì„±
        token_manager = InvitationTokenManager(settings.SECRET_KEY)
        token_data = token_manager.generate_invitation_token(
            str(invitation.id),
            str(invitation.project_id),
            invitation.invitee_email,
            invitation.role
        )
        
        # DB ì €ì¥
        invitation.token = token_data['url_token']
        invitation.token_hash = token_data['token_hash']
        invitation.save()
        
        # ì´ë©”ì¼ ë°œì†¡ (ë¹„ë™ê¸°)
        send_invitation_email.delay(
            str(invitation.id),
            invitation.invitee_email,
            self.prepare_email_context(invitation, token_data['url_token'])
        )
        
        return Response(
            {'id': invitation.id, 'status': 'sent'},
            status=status.HTTP_201_CREATED
        )
    
    @action(detail=False, methods=['get'])
    def validate(self, request):
        """í† í° ê²€ì¦ API"""
        
        token = request.query_params.get('token')
        
        if not token:
            return Response(
                {'error': 'Token required'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # í† í° í•´ì‹œ ê³„ì‚°
        import hashlib
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        
        # ìºì‹œ í™•ì¸
        cache = TokenCache(redis_client)
        cached_data = cache.get_token(token_hash)
        
        if cached_data:
            return Response(cached_data)
        
        # DB ì¡°íšŒ
        try:
            invitation = EvaluationInvitation.objects.get(
                token_hash=token_hash,
                status='pending'
            )
            
            # ë§Œë£Œ í™•ì¸
            if invitation.expires_at < timezone.now():
                invitation.status = 'expired'
                invitation.save()
                return Response(
                    {'error': 'Invitation expired'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # ìºì‹œ ì €ì¥
            response_data = {
                'invitation_id': str(invitation.id),
                'project_id': str(invitation.project_id),
                'project_name': invitation.project.name,
                'role': invitation.role,
                'permissions': invitation.permissions
            }
            
            ttl = int((invitation.expires_at - timezone.now()).total_seconds())
            cache.set_token(token_hash, response_data, ttl)
            
            return Response(response_data)
            
        except EvaluationInvitation.DoesNotExist:
            return Response(
                {'error': 'Invalid token'},
                status=status.HTTP_404_NOT_FOUND
            )
    
    @action(detail=False, methods=['post'])
    def accept(self, request):
        """ì´ˆëŒ€ ìˆ˜ë½ API"""
        
        token = request.data.get('token')
        user_data = request.data.get('user_data', {})
        
        # í† í° ê²€ì¦
        validation_result = self.validate_token(token)
        
        if not validation_result['valid']:
            return Response(
                {'error': validation_result['error']},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        invitation = validation_result['invitation']
        
        # ì‚¬ìš©ì ìƒì„± ë˜ëŠ” ì¡°íšŒ
        user = self.get_or_create_user(invitation.invitee_email, user_data)
        
        # ê¶Œí•œ í• ë‹¹
        ParticipantPermission.objects.create(
            user=user,
            project_id=invitation.project_id,
            invitation=invitation,
            role=invitation.role,
            **invitation.permissions
        )
        
        # ì´ˆëŒ€ ìƒíƒœ ì—…ë°ì´íŠ¸
        invitation.status = 'accepted'
        invitation.accepted_at = timezone.now()
        invitation.save()
        
        # ì•¡ì„¸ìŠ¤ í† í° ë°œê¸‰
        access_token = self.generate_access_token(user, invitation.project_id)
        
        # í™œë™ ë¡œê·¸
        InvitationActivity.objects.create(
            invitation=invitation,
            action='accepted',
            actor=user,
            actor_ip=self.get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        return Response({
            'access_token': access_token,
            'project_id': str(invitation.project_id),
            'redirect_url': f'/projects/{invitation.project_id}/evaluation'
        })
    
    @action(detail=True, methods=['post'])
    def revoke(self, request, pk=None):
        """ì´ˆëŒ€ ì² íšŒ API"""
        
        invitation = self.get_object()
        
        if invitation.status == 'accepted':
            return Response(
                {'error': 'Cannot revoke accepted invitation'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        invitation.status = 'revoked'
        invitation.revoked_at = timezone.now()
        invitation.save()
        
        # ìºì‹œ ë¬´íš¨í™”
        cache = TokenCache(redis_client)
        cache.invalidate_token(invitation.token_hash)
        
        return Response({'status': 'revoked'})
    
    @action(detail=False, methods=['get'])
    def statistics(self, request):
        """ì´ˆëŒ€ í†µê³„ API"""
        
        project_id = request.query_params.get('project_id')
        
        stats = EvaluationInvitation.objects.filter(
            project_id=project_id
        ).aggregate(
            total=Count('id'),
            pending=Count('id', filter=Q(status='pending')),
            accepted=Count('id', filter=Q(status='accepted')),
            expired=Count('id', filter=Q(status='expired')),
            revoked=Count('id', filter=Q(status='revoked'))
        )
        
        return Response(stats)
```

---

## 7. ì‹¤ì‹œê°„ ì•Œë¦¼ ì‹œìŠ¤í…œ

### 7.1 WebSocket êµ¬í˜„

```python
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async

class InvitationNotificationConsumer(AsyncWebsocketConsumer):
    """ì´ˆëŒ€ ì‹¤ì‹œê°„ ì•Œë¦¼ WebSocket ì»¨ìŠˆë¨¸"""
    
    async def connect(self):
        self.project_id = self.scope['url_route']['kwargs']['project_id']
        self.project_group_name = f'invitations_{self.project_id}'
        self.user = self.scope['user']
        
        # ê¶Œí•œ í™•ì¸
        if not await self.has_project_access():
            await self.close()
            return
        
        # ê·¸ë£¹ ì¶”ê°€
        await self.channel_layer.group_add(
            self.project_group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # ì´ˆê¸° ë°ì´í„° ì „ì†¡
        await self.send_initial_data()
    
    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(
            self.project_group_name,
            self.channel_name
        )
    
    async def receive(self, text_data):
        """í´ë¼ì´ì–¸íŠ¸ ë©”ì‹œì§€ ì²˜ë¦¬"""
        data = json.loads(text_data)
        action = data.get('action')
        
        if action == 'refresh_invitations':
            await self.send_invitation_list()
        elif action == 'get_participant_status':
            await self.send_participant_status()
    
    async def invitation_sent(self, event):
        """ìƒˆ ì´ˆëŒ€ ë°œì†¡ ì•Œë¦¼"""
        await self.send(text_data=json.dumps({
            'type': 'invitation_sent',
            'invitation': event['invitation'],
            'timestamp': event['timestamp']
        }))
    
    async def invitation_accepted(self, event):
        """ì´ˆëŒ€ ìˆ˜ë½ ì•Œë¦¼"""
        await self.send(text_data=json.dumps({
            'type': 'invitation_accepted',
            'invitation': event['invitation'],
            'user': event['user'],
            'timestamp': event['timestamp']
        }))
    
    async def invitation_revoked(self, event):
        """ì´ˆëŒ€ ì² íšŒ ì•Œë¦¼"""
        await self.send(text_data=json.dumps({
            'type': 'invitation_revoked',
            'invitation_id': event['invitation_id'],
            'timestamp': event['timestamp']
        }))
    
    @database_sync_to_async
    def has_project_access(self):
        """í”„ë¡œì íŠ¸ ì ‘ê·¼ ê¶Œí•œ í™•ì¸"""
        return ParticipantPermission.objects.filter(
            user=self.user,
            project_id=self.project_id
        ).exists()
    
    @database_sync_to_async
    def get_invitation_list(self):
        """ì´ˆëŒ€ ëª©ë¡ ì¡°íšŒ"""
        invitations = EvaluationInvitation.objects.filter(
            project_id=self.project_id
        ).values(
            'id', 'invitee_email', 'invitee_name',
            'role', 'status', 'created_at', 'accepted_at'
        )
        return list(invitations)
    
    async def send_initial_data(self):
        """ì—°ê²° ì‹œ ì´ˆê¸° ë°ì´í„° ì „ì†¡"""
        invitations = await self.get_invitation_list()
        await self.send(text_data=json.dumps({
            'type': 'initial_data',
            'invitations': invitations
        }))
```

---

## 8. ì°¸ì—¬ì ì¶”ì  ì‹œìŠ¤í…œ

### 8.1 í™œë™ ì¶”ì  ì•Œê³ ë¦¬ì¦˜

```python
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import pandas as pd

class ParticipantTracker:
    """ì°¸ì—¬ì í™œë™ ì¶”ì  ë° ë¶„ì„"""
    
    def __init__(self, project_id: str):
        self.project_id = project_id
    
    def track_participant_journey(self, user_id: str) -> Dict:
        """ì°¸ì—¬ì ì—¬ì • ì¶”ì """
        
        journey = {
            'user_id': user_id,
            'invitation_phase': self.get_invitation_phase(user_id),
            'evaluation_progress': self.get_evaluation_progress(user_id),
            'engagement_score': self.calculate_engagement_score(user_id),
            'contribution_metrics': self.get_contribution_metrics(user_id)
        }
        
        return journey
    
    def get_invitation_phase(self, user_id: str) -> Dict:
        """ì´ˆëŒ€ ë‹¨ê³„ ì •ë³´"""
        
        permission = ParticipantPermission.objects.filter(
            user_id=user_id,
            project_id=self.project_id
        ).first()
        
        if not permission or not permission.invitation:
            return {'status': 'direct_member'}
        
        invitation = permission.invitation
        
        phase = {
            'invitation_id': str(invitation.id),
            'invited_at': invitation.created_at,
            'accepted_at': invitation.accepted_at,
            'time_to_accept': None,
            'reminder_count': invitation.reminder_count
        }
        
        if invitation.accepted_at:
            delta = invitation.accepted_at - invitation.created_at
            phase['time_to_accept'] = delta.total_seconds() / 3600  # hours
        
        return phase
    
    def get_evaluation_progress(self, user_id: str) -> Dict:
        """í‰ê°€ ì§„í–‰ ìƒí™©"""
        
        evaluations = Evaluation.objects.filter(
            project_id=self.project_id,
            evaluator_id=user_id
        )
        
        total_criteria = Criteria.objects.filter(
            project_id=self.project_id
        ).count()
        
        completed_evaluations = evaluations.filter(
            status='completed'
        ).count()
        
        progress = {
            'total_criteria': total_criteria,
            'evaluated_criteria': completed_evaluations,
            'completion_rate': (completed_evaluations / total_criteria * 100) if total_criteria > 0 else 0,
            'last_evaluation_at': evaluations.order_by('-updated_at').first().updated_at if evaluations.exists() else None
        }
        
        return progress
    
    def calculate_engagement_score(self, user_id: str) -> float:
        """ì°¸ì—¬ë„ ì ìˆ˜ ê³„ì‚° (0-100)"""
        
        score = 0.0
        weights = {
            'acceptance_speed': 20,
            'evaluation_completion': 30,
            'consistency_ratio': 20,
            'activity_frequency': 20,
            'collaboration': 10
        }
        
        # 1. ìˆ˜ë½ ì†ë„ (ë¹ ë¥¼ìˆ˜ë¡ ë†’ì€ ì ìˆ˜)
        permission = ParticipantPermission.objects.filter(
            user_id=user_id,
            project_id=self.project_id
        ).first()
        
        if permission and permission.invitation:
            inv = permission.invitation
            if inv.accepted_at:
                hours_to_accept = (inv.accepted_at - inv.created_at).total_seconds() / 3600
                if hours_to_accept <= 24:
                    score += weights['acceptance_speed']
                elif hours_to_accept <= 72:
                    score += weights['acceptance_speed'] * 0.7
                elif hours_to_accept <= 168:
                    score += weights['acceptance_speed'] * 0.4
        
        # 2. í‰ê°€ ì™„ë£Œìœ¨
        progress = self.get_evaluation_progress(user_id)
        score += weights['evaluation_completion'] * (progress['completion_rate'] / 100)
        
        # 3. ì¼ê´€ì„± ë¹„ìœ¨
        avg_consistency = self.get_average_consistency_ratio(user_id)
        if avg_consistency <= 0.1:
            score += weights['consistency_ratio']
        elif avg_consistency <= 0.15:
            score += weights['consistency_ratio'] * 0.7
        elif avg_consistency <= 0.2:
            score += weights['consistency_ratio'] * 0.4
        
        # 4. í™œë™ ë¹ˆë„
        activity_score = self.calculate_activity_frequency(user_id)
        score += weights['activity_frequency'] * activity_score
        
        # 5. í˜‘ì—… ì ìˆ˜
        collaboration_score = self.calculate_collaboration_score(user_id)
        score += weights['collaboration'] * collaboration_score
        
        return min(100, max(0, score))
    
    def get_contribution_metrics(self, user_id: str) -> Dict:
        """ê¸°ì—¬ë„ ì¸¡ì •"""
        
        metrics = {
            'evaluations_count': 0,
            'comments_count': 0,
            'average_consistency_ratio': 0.0,
            'evaluation_quality_score': 0.0,
            'time_spent_minutes': 0,
            'influence_score': 0.0
        }
        
        # í‰ê°€ ìˆ˜
        evaluations = Evaluation.objects.filter(
            project_id=self.project_id,
            evaluator_id=user_id
        )
        metrics['evaluations_count'] = evaluations.count()
        
        # ì½”ë©˜íŠ¸ ìˆ˜
        comments = EvaluationComment.objects.filter(
            evaluation__project_id=self.project_id,
            author_id=user_id
        )
        metrics['comments_count'] = comments.count()
        
        # í‰ê·  ì¼ê´€ì„± ë¹„ìœ¨
        metrics['average_consistency_ratio'] = self.get_average_consistency_ratio(user_id)
        
        # í‰ê°€ í’ˆì§ˆ ì ìˆ˜
        metrics['evaluation_quality_score'] = self.calculate_evaluation_quality(user_id)
        
        # ì†Œìš” ì‹œê°„
        metrics['time_spent_minutes'] = self.calculate_time_spent(user_id)
        
        # ì˜í–¥ë ¥ ì ìˆ˜ (ë‹¤ë¥¸ í‰ê°€ìë“¤ê³¼ì˜ ìƒê´€ê´€ê³„)
        metrics['influence_score'] = self.calculate_influence_score(user_id)
        
        return metrics
    
    def generate_participation_report(self) -> pd.DataFrame:
        """ì „ì²´ ì°¸ì—¬ì ë¦¬í¬íŠ¸ ìƒì„±"""
        
        participants = ParticipantPermission.objects.filter(
            project_id=self.project_id
        ).select_related('user', 'invitation')
        
        report_data = []
        
        for participant in participants:
            user_id = str(participant.user_id)
            journey = self.track_participant_journey(user_id)
            
            report_data.append({
                'user_email': participant.user.email,
                'role': participant.role,
                'invited_via': 'invitation' if participant.invitation else 'direct',
                'engagement_score': journey['engagement_score'],
                'completion_rate': journey['evaluation_progress']['completion_rate'],
                'evaluations_count': journey['contribution_metrics']['evaluations_count'],
                'avg_consistency': journey['contribution_metrics']['average_consistency_ratio'],
                'quality_score': journey['contribution_metrics']['evaluation_quality_score']
            })
        
        df = pd.DataFrame(report_data)
        return df.sort_values('engagement_score', ascending=False)
```

---

## 9. ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 9.1 ë³´ì•ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸

```python
class InvitationSecurityManager:
    """ì´ˆëŒ€ ì‹œìŠ¤í…œ ë³´ì•ˆ ê´€ë¦¬"""
    
    @staticmethod
    def validate_email_domain(email: str) -> bool:
        """ì´ë©”ì¼ ë„ë©”ì¸ ê²€ì¦"""
        blocked_domains = ['tempmail.com', 'guerrillamail.com']
        domain = email.split('@')[1].lower()
        return domain not in blocked_domains
    
    @staticmethod
    def check_rate_limit(user_id: str, action: str) -> bool:
        """Rate limiting í™•ì¸"""
        key = f"rate_limit:{user_id}:{action}"
        current_count = cache.get(key, 0)
        
        limits = {
            'send_invitation': (10, 3600),  # 10 per hour
            'accept_invitation': (5, 3600),  # 5 per hour
            'validate_token': (20, 60)       # 20 per minute
        }
        
        limit, window = limits.get(action, (100, 3600))
        
        if current_count >= limit:
            return False
        
        cache.set(key, current_count + 1, window)
        return True
    
    @staticmethod
    def sanitize_custom_message(message: str) -> str:
        """ì‚¬ìš©ì ë©”ì‹œì§€ ì‚´ê· """
        import bleach
        
        allowed_tags = ['p', 'br', 'strong', 'em', 'u']
        cleaned = bleach.clean(message, tags=allowed_tags)
        return cleaned[:1000]  # ìµœëŒ€ 1000ì
    
    @staticmethod
    def log_security_event(event_type: str, details: dict):
        """ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê¹…"""
        SecurityLog.objects.create(
            event_type=event_type,
            details=details,
            timestamp=datetime.utcnow()
        )
```

---

## 10. ì„±ëŠ¥ ìµœì í™” ì „ëµ

### 10.1 ì¿¼ë¦¬ ìµœì í™”

```python
# ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_invitation_lookup ON evaluation_invitations(token_hash, status, expires_at);
CREATE INDEX idx_permission_lookup ON participant_permissions(user_id, project_id);
CREATE INDEX idx_activity_timeline ON invitation_activities(invitation_id, created_at DESC);

# ì¿¼ë¦¬ ìµœì í™” ì˜ˆì‹œ
def get_project_participants_optimized(project_id: str):
    """ìµœì í™”ëœ ì°¸ì—¬ì ì¡°íšŒ"""
    
    participants = ParticipantPermission.objects.filter(
        project_id=project_id
    ).select_related(
        'user',
        'invitation__inviter'
    ).prefetch_related(
        Prefetch(
            'user__evaluations',
            queryset=Evaluation.objects.filter(project_id=project_id)
        )
    ).annotate(
        evaluation_count=Count('user__evaluations'),
        last_activity=Max('user__evaluations__updated_at')
    )
    
    return participants
```

### 10.2 ìºì‹± ì „ëµ

```python
CACHE_KEYS = {
    'invitation_stats': 'invitation:stats:{project_id}',
    'participant_list': 'participants:{project_id}',
    'permission_matrix': 'permissions:{user_id}:{project_id}'
}

CACHE_TTL = {
    'invitation_stats': 300,      # 5 minutes
    'participant_list': 600,      # 10 minutes  
    'permission_matrix': 1800     # 30 minutes
}
```

---

## 11. í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤

### 11.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```python
import pytest
from django.test import TestCase

class InvitationSystemTests(TestCase):
    """ì´ˆëŒ€ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸"""
    
    def test_token_generation_uniqueness(self):
        """í† í° ê³ ìœ ì„± í…ŒìŠ¤íŠ¸"""
        tokens = set()
        for _ in range(1000):
            token = InvitationTokenManager().generate_invitation_token(
                'test_id', 'project_id', 'test@email.com', 'evaluator'
            )
            self.assertNotIn(token['url_token'], tokens)
            tokens.add(token['url_token'])
    
    def test_permission_inheritance(self):
        """ê¶Œí•œ ìƒì† í…ŒìŠ¤íŠ¸"""
        # ì—­í• ë³„ ê¶Œí•œ í™•ì¸
        for role, perms in ROLE_PERMISSIONS.items():
            permission = create_permission_from_role(role)
            for perm_key, perm_value in perms['permissions'].items():
                self.assertEqual(
                    getattr(permission, perm_key),
                    perm_value
                )
    
    def test_invitation_expiry(self):
        """ì´ˆëŒ€ ë§Œë£Œ í…ŒìŠ¤íŠ¸"""
        invitation = create_test_invitation(expires_in_days=-1)
        result = validate_invitation(invitation.token)
        self.assertFalse(result['valid'])
        self.assertEqual(result['error'], 'Token expired')
    
    def test_rate_limiting(self):
        """Rate limiting í…ŒìŠ¤íŠ¸"""
        user_id = 'test_user'
        
        # ì œí•œ ë‚´ì—ì„œëŠ” ì„±ê³µ
        for _ in range(10):
            self.assertTrue(
                InvitationSecurityManager.check_rate_limit(
                    user_id, 'send_invitation'
                )
            )
        
        # ì œí•œ ì´ˆê³¼ ì‹œ ì‹¤íŒ¨
        self.assertFalse(
            InvitationSecurityManager.check_rate_limit(
                user_id, 'send_invitation'
            )
        )
```

---

## 12. êµ¬í˜„ ë¡œë“œë§µ

### Phase 1: ê¸°ë³¸ êµ¬í˜„ (Week 1)
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ êµ¬í˜„
- [ ] Django ëª¨ë¸ ìƒì„±
- [ ] ê¸°ë³¸ CRUD API êµ¬í˜„
- [ ] í† í° ìƒì„±/ê²€ì¦ ë¡œì§

### Phase 2: ì´ë©”ì¼ ì‹œìŠ¤í…œ (Week 2)
- [ ] Celery ì„¤ì •
- [ ] ì´ë©”ì¼ í…œí”Œë¦¿ êµ¬í˜„
- [ ] ë¹„ë™ê¸° ë°œì†¡ í
- [ ] ë¦¬ë§ˆì¸ë” ì‹œìŠ¤í…œ

### Phase 3: ê¶Œí•œ ê´€ë¦¬ (Week 3)
- [ ] RBAC êµ¬í˜„
- [ ] ê¶Œí•œ ë§¤íŠ¸ë¦­ìŠ¤ UI
- [ ] ê¶Œí•œ ê²€ì¦ ë¯¸ë“¤ì›¨ì–´
- [ ] ê°ì‚¬ ë¡œê·¸

### Phase 4: ì‹¤ì‹œê°„ ê¸°ëŠ¥ (Week 4)
- [ ] WebSocket ì„¤ì •
- [ ] ì‹¤ì‹œê°„ ì•Œë¦¼
- [ ] ì°¸ì—¬ì ìƒíƒœ ì¶”ì 
- [ ] ëŒ€ì‹œë³´ë“œ í†µí•©

---

**ë¬¸ì„œ ë²„ì „**: 1.0  
**ìµœì¢… ìˆ˜ì •ì¼**: 2024-11-29  
**ì‘ì„±ì**: Claude Opus 4.1  
**ê²€í†  ìƒíƒœ**: ì´ˆì•ˆ ì™„ì„±