# ğŸ‘¥ ê·¸ë£¹ í‰ê°€ í†µí•© ì‹œìŠ¤í…œ ì„¤ê³„
## ì‘ì„±ì¼: 2024-11-11
## ì‘ì„±ì: Claude Opus 4.1
## ë²„ì „: 1.0.0

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ëª©ì 
ê·¸ë£¹ í‰ê°€ í†µí•© ì‹œìŠ¤í…œì€ ì—¬ëŸ¬ í‰ê°€ìì˜ ê°œë³„ íŒë‹¨ì„ ìˆ˜í•™ì ìœ¼ë¡œ í†µí•©í•˜ì—¬ ì§‘ë‹¨ì˜ í•©ì˜ëœ ì˜ì‚¬ê²°ì •ì„ ë„ì¶œí•˜ëŠ” í•µì‹¬ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### 1.2 í•µì‹¬ ê¸°ëŠ¥
- ë‹¤ì–‘í•œ í†µí•© ë°©ë²•ë¡  ì§€ì› (AIJ, AIP, ê°€ì¤‘í‰ê· )
- í‰ê°€ì ê°„ í•©ì˜ë„ ì¸¡ì •
- ì´ê²¬ ë¶„ì„ ë° ì‹œê°í™”
- ì „ë¬¸ê°€ ê°€ì¤‘ì¹˜ ì ìš©
- ì‹¤ì‹œê°„ ê·¸ë£¹ í‰ê°€ ëª¨ë‹ˆí„°ë§

### 1.3 í†µí•© ë°©ë²•ë¡ 
1. **AIJ (Aggregation of Individual Judgments)**: ê¸°í•˜í‰ê·  ê¸°ë°˜
2. **AIP (Aggregation of Individual Priorities)**: ìš°ì„ ìˆœìœ„ í‰ê·  ê¸°ë°˜
3. **Weighted Aggregation**: ì „ë¬¸ì„± ê°€ì¤‘ì¹˜ ì ìš©
4. **Fuzzy Aggregation**: ë¶ˆí™•ì‹¤ì„± ë°˜ì˜

---

## 2. ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„

### 2.1 ê·¸ë£¹ í‰ê°€ ìŠ¤í‚¤ë§ˆ

```sql
-- í‰ê°€ ê·¸ë£¹ ì •ì˜
CREATE TABLE evaluation_groups (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    aggregation_method VARCHAR(50) DEFAULT 'geometric_mean',
    consensus_threshold DECIMAL(3,2) DEFAULT 0.70,
    min_evaluators INTEGER DEFAULT 2,
    max_evaluators INTEGER DEFAULT 50,
    status VARCHAR(20) DEFAULT 'pending',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    
    INDEX idx_group_project (project_id),
    INDEX idx_group_status (status)
);

-- ê·¸ë£¹ ë©¤ë²„ (í‰ê°€ì)
CREATE TABLE group_members (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    group_id UUID NOT NULL REFERENCES evaluation_groups(id) ON DELETE CASCADE,
    evaluator_id UUID NOT NULL REFERENCES evaluators(id) ON DELETE CASCADE,
    role VARCHAR(50) DEFAULT 'member', -- 'leader', 'member', 'observer'
    expertise_level INTEGER CHECK (expertise_level >= 1 AND expertise_level <= 10),
    weight DECIMAL(5,4) DEFAULT 1.0,
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    evaluation_started_at TIMESTAMP WITH TIME ZONE,
    evaluation_completed_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT true,
    
    CONSTRAINT unique_group_member UNIQUE(group_id, evaluator_id),
    INDEX idx_member_group (group_id),
    INDEX idx_member_evaluator (evaluator_id)
);

-- ê·¸ë£¹ í†µí•© ë§¤íŠ¸ë¦­ìŠ¤
CREATE TABLE group_aggregated_matrices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    group_id UUID NOT NULL REFERENCES evaluation_groups(id) ON DELETE CASCADE,
    node_id UUID NOT NULL REFERENCES hierarchy_nodes(id) ON DELETE CASCADE,
    aggregation_method VARCHAR(50) NOT NULL,
    matrix_data JSONB NOT NULL,
    consistency_ratio DECIMAL(5,4),
    is_consistent BOOLEAN,
    eigen_value DECIMAL(10,8),
    eigen_vector JSONB,
    consensus_index DECIMAL(5,4), -- 0 to 1
    participant_count INTEGER,
    calculation_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT unique_group_node UNIQUE(group_id, node_id),
    INDEX idx_aggregated_group (group_id),
    INDEX idx_aggregated_node (node_id)
);

-- í‰ê°€ì ê°„ ì´ê²¬ ë¶„ì„
CREATE TABLE disagreement_analysis (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    group_id UUID NOT NULL REFERENCES evaluation_groups(id) ON DELETE CASCADE,
    node_id UUID NOT NULL REFERENCES hierarchy_nodes(id) ON DELETE CASCADE,
    evaluator1_id UUID NOT NULL REFERENCES evaluators(id),
    evaluator2_id UUID NOT NULL REFERENCES evaluators(id),
    element_i INTEGER NOT NULL,
    element_j INTEGER NOT NULL,
    value1 DECIMAL(10,4),
    value2 DECIMAL(10,4),
    disagreement_score DECIMAL(5,4), -- ì´ê²¬ ì •ë„
    
    INDEX idx_disagreement_group (group_id),
    INDEX idx_disagreement_score (disagreement_score DESC)
);

-- í•©ì˜ í˜•ì„± ì´ë ¥
CREATE TABLE consensus_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    group_id UUID NOT NULL REFERENCES evaluation_groups(id) ON DELETE CASCADE,
    iteration INTEGER NOT NULL,
    consensus_level DECIMAL(5,4),
    method_used VARCHAR(50),
    changes_made JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_consensus_group (group_id),
    INDEX idx_consensus_iteration (iteration)
);
```

### 2.2 TypeScript ì¸í„°í˜ì´ìŠ¤

```typescript
// í‰ê°€ ê·¸ë£¹
export interface EvaluationGroup {
  id: string;
  projectId: string;
  name: string;
  description?: string;
  aggregationMethod: AggregationMethod;
  consensusThreshold: number;
  minEvaluators: number;
  maxEvaluators: number;
  status: GroupStatus;
  members: GroupMember[];
  createdAt: Date;
  startedAt?: Date;
  completedAt?: Date;
}

// ê·¸ë£¹ ë©¤ë²„
export interface GroupMember {
  id: string;
  groupId: string;
  evaluatorId: string;
  evaluator: Evaluator;
  role: 'leader' | 'member' | 'observer';
  expertiseLevel: number; // 1-10
  weight: number; // 0-1
  joinedAt: Date;
  evaluationStartedAt?: Date;
  evaluationCompletedAt?: Date;
  isActive: boolean;
}

// í†µí•© ë°©ë²•
export type AggregationMethod = 
  | 'geometric_mean'  // AIJ
  | 'arithmetic_mean' // AIP
  | 'weighted_mean'
  | 'fuzzy_mean'
  | 'median'
  | 'trimmed_mean';

// ê·¸ë£¹ ìƒíƒœ
export type GroupStatus = 
  | 'pending'
  | 'in_progress'
  | 'waiting_consensus'
  | 'completed'
  | 'cancelled';

// í†µí•© ê²°ê³¼
export interface AggregatedResult {
  groupId: string;
  nodeId: string;
  method: AggregationMethod;
  matrix: number[][];
  weights: number[];
  consistencyRatio: number;
  isConsistent: boolean;
  consensusIndex: number;
  participantCount: number;
  timestamp: Date;
}
```

---

## 3. í†µí•© ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„

### 3.1 ê¸°í•˜í‰ê·  (AIJ) êµ¬í˜„

```typescript
export class GeometricMeanAggregator implements IAggregator {
  /**
   * Aggregation of Individual Judgments (AIJ)
   * ê°œë³„ íŒë‹¨ì˜ ê¸°í•˜í‰ê· 
   */
  aggregate(matrices: number[][][]): AggregationResult {
    if (matrices.length === 0) {
      throw new Error('No matrices to aggregate');
    }
    
    const n = matrices[0].length;
    const k = matrices.length;
    const result = this.initializeMatrix(n);
    
    // ê° ìš”ì†Œë³„ ê¸°í•˜í‰ê·  ê³„ì‚°
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) {
          result[i][j] = 1;
          continue;
        }
        
        // ê³±ì…ˆ ëˆ„ì 
        let product = 1;
        let validCount = 0;
        
        for (const matrix of matrices) {
          if (matrix[i][j] > 0) {
            product *= matrix[i][j];
            validCount++;
          }
        }
        
        // ê¸°í•˜í‰ê· : kì œê³±ê·¼
        if (validCount > 0) {
          result[i][j] = Math.pow(product, 1 / validCount);
        }
      }
    }
    
    // ì¼ê´€ì„± ê²€ì¦
    const consistency = this.checkConsistency(result);
    
    // ê°€ì¤‘ì¹˜ ê³„ì‚°
    const weights = this.calculateWeights(result);
    
    return {
      matrix: result,
      weights,
      consistency,
      method: 'geometric_mean'
    };
  }
  
  /**
   * ê°€ì¤‘ ê¸°í•˜í‰ê· 
   */
  weightedAggregate(
    matrices: number[][][], 
    weights: number[]
  ): AggregationResult {
    if (matrices.length !== weights.length) {
      throw new Error('Matrices and weights count mismatch');
    }
    
    const n = matrices[0].length;
    const result = this.initializeMatrix(n);
    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
    
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) {
          result[i][j] = 1;
          continue;
        }
        
        // ê°€ì¤‘ ê¸°í•˜í‰ê· : product(aij^wi)
        let weightedProduct = 1;
        
        for (let k = 0; k < matrices.length; k++) {
          const normalizedWeight = weights[k] / totalWeight;
          weightedProduct *= Math.pow(matrices[k][i][j], normalizedWeight);
        }
        
        result[i][j] = weightedProduct;
      }
    }
    
    const consistency = this.checkConsistency(result);
    const resultWeights = this.calculateWeights(result);
    
    return {
      matrix: result,
      weights: resultWeights,
      consistency,
      method: 'weighted_geometric_mean'
    };
  }
  
  private initializeMatrix(size: number): number[][] {
    return Array(size).fill(null).map(() => Array(size).fill(1));
  }
  
  private checkConsistency(matrix: number[][]): ConsistencyInfo {
    // ConsistencyValidator ì‚¬ìš©
    const result = ConsistencyValidator.validateConsistency(matrix);
    return {
      ratio: result.ratio,
      isConsistent: result.isConsistent,
      eigenValue: result.eigenValue
    };
  }
  
  private calculateWeights(matrix: number[][]): number[] {
    // Power Method ì‚¬ìš©
    const { eigenVector } = ConsistencyValidator.powerMethod(matrix);
    return eigenVector;
  }
}
```

### 3.2 ì‚°ìˆ í‰ê·  (AIP) êµ¬í˜„

```typescript
export class ArithmeticMeanAggregator implements IAggregator {
  /**
   * Aggregation of Individual Priorities (AIP)
   * ê°œë³„ ìš°ì„ ìˆœìœ„ì˜ ì‚°ìˆ í‰ê· 
   */
  async aggregate(matrices: number[][][]): Promise<AggregationResult> {
    const n = matrices[0].length;
    const k = matrices.length;
    
    // ê° ë§¤íŠ¸ë¦­ìŠ¤ì—ì„œ ìš°ì„ ìˆœìœ„ ë²¡í„° ì¶”ì¶œ
    const priorityVectors: number[][] = [];
    
    for (const matrix of matrices) {
      const { eigenVector } = await this.powerMethod(matrix);
      priorityVectors.push(eigenVector);
    }
    
    // ìš°ì„ ìˆœìœ„ ë²¡í„°ì˜ ì‚°ìˆ í‰ê· 
    const averagePriorities = Array(n).fill(0);
    
    for (let i = 0; i < n; i++) {
      let sum = 0;
      for (const priorities of priorityVectors) {
        sum += priorities[i];
      }
      averagePriorities[i] = sum / k;
    }
    
    // í‰ê·  ìš°ì„ ìˆœìœ„ë¡œë¶€í„° ì¼ê´€ëœ ë§¤íŠ¸ë¦­ìŠ¤ ì¬êµ¬ì„±
    const reconstructedMatrix = this.reconstructMatrix(averagePriorities);
    
    return {
      matrix: reconstructedMatrix,
      weights: averagePriorities,
      consistency: {
        ratio: 0, // ì¬êµ¬ì„±ëœ ë§¤íŠ¸ë¦­ìŠ¤ëŠ” ì™„ë²½íˆ ì¼ê´€ë¨
        isConsistent: true,
        eigenValue: n
      },
      method: 'arithmetic_mean'
    };
  }
  
  /**
   * ìš°ì„ ìˆœìœ„ ë²¡í„°ë¡œë¶€í„° ì¼ê´€ëœ ë§¤íŠ¸ë¦­ìŠ¤ ì¬êµ¬ì„±
   */
  private reconstructMatrix(priorities: number[]): number[][] {
    const n = priorities.length;
    const matrix = Array(n).fill(null).map(() => Array(n).fill(0));
    
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (priorities[j] > 0) {
          matrix[i][j] = priorities[i] / priorities[j];
        } else {
          matrix[i][j] = 1;
        }
      }
    }
    
    return matrix;
  }
  
  /**
   * ê°€ì¤‘ ì‚°ìˆ í‰ê· 
   */
  async weightedAggregate(
    matrices: number[][][],
    weights: number[]
  ): Promise<AggregationResult> {
    const n = matrices[0].length;
    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
    
    // ê°€ì¤‘ ìš°ì„ ìˆœìœ„ ê³„ì‚°
    const weightedPriorities = Array(n).fill(0);
    
    for (let k = 0; k < matrices.length; k++) {
      const { eigenVector } = await this.powerMethod(matrices[k]);
      const normalizedWeight = weights[k] / totalWeight;
      
      for (let i = 0; i < n; i++) {
        weightedPriorities[i] += eigenVector[i] * normalizedWeight;
      }
    }
    
    const reconstructedMatrix = this.reconstructMatrix(weightedPriorities);
    
    return {
      matrix: reconstructedMatrix,
      weights: weightedPriorities,
      consistency: {
        ratio: 0,
        isConsistent: true,
        eigenValue: n
      },
      method: 'weighted_arithmetic_mean'
    };
  }
  
  private async powerMethod(matrix: number[][]): Promise<{eigenVector: number[]}> {
    // ConsistencyValidatorì˜ powerMethod í™œìš©
    return ConsistencyValidator.powerMethod(matrix);
  }
}
```

### 3.3 í¼ì§€ í†µí•© (Fuzzy Aggregation)

```typescript
export class FuzzyAggregator implements IAggregator {
  /**
   * ì‚¼ê° í¼ì§€ ìˆ˜ë¥¼ ì‚¬ìš©í•œ í†µí•©
   */
  async aggregateFuzzy(
    fuzzyMatrices: FuzzyMatrix[]
  ): Promise<FuzzyAggregationResult> {
    const n = fuzzyMatrices[0].size;
    const k = fuzzyMatrices.length;
    
    // í¼ì§€ í†µí•© ë§¤íŠ¸ë¦­ìŠ¤ ì´ˆê¸°í™”
    const aggregatedFuzzy: TriangularFuzzyNumber[][] = 
      Array(n).fill(null).map(() => 
        Array(n).fill(null).map(() => ({ l: 0, m: 0, u: 0 }))
      );
    
    // ê° ìš”ì†Œë³„ í¼ì§€ ìˆ˜ í†µí•©
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) {
          aggregatedFuzzy[i][j] = { l: 1, m: 1, u: 1 };
          continue;
        }
        
        // ê° í‰ê°€ìì˜ í¼ì§€ íŒë‹¨ ìˆ˜ì§‘
        const fuzzyJudgments: TriangularFuzzyNumber[] = [];
        
        for (const matrix of fuzzyMatrices) {
          fuzzyJudgments.push(matrix.getFuzzyElement(i, j));
        }
        
        // í¼ì§€ ê¸°í•˜í‰ê· 
        aggregatedFuzzy[i][j] = this.fuzzyGeometricMean(fuzzyJudgments);
      }
    }
    
    // ë””í¼ì§€í™” (Defuzzification)
    const crispMatrix = this.defuzzify(aggregatedFuzzy);
    
    // ì¼ê´€ì„± ê²€ì¦
    const consistency = await this.checkConsistency(crispMatrix);
    
    // í¼ì§€ ê°€ì¤‘ì¹˜ ê³„ì‚°
    const fuzzyWeights = this.calculateFuzzyWeights(aggregatedFuzzy);
    const crispWeights = this.defuzzifyWeights(fuzzyWeights);
    
    return {
      fuzzyMatrix: aggregatedFuzzy,
      crispMatrix,
      fuzzyWeights,
      crispWeights,
      consistency,
      method: 'fuzzy_aggregation',
      confidenceInterval: this.calculateConfidenceInterval(fuzzyWeights)
    };
  }
  
  /**
   * ì‚¼ê° í¼ì§€ ìˆ˜ì˜ ê¸°í•˜í‰ê· 
   */
  private fuzzyGeometricMean(
    fuzzyNumbers: TriangularFuzzyNumber[]
  ): TriangularFuzzyNumber {
    const k = fuzzyNumbers.length;
    
    let productL = 1, productM = 1, productU = 1;
    
    for (const fuzzy of fuzzyNumbers) {
      productL *= fuzzy.l;
      productM *= fuzzy.m;
      productU *= fuzzy.u;
    }
    
    return {
      l: Math.pow(productL, 1/k),
      m: Math.pow(productM, 1/k),
      u: Math.pow(productU, 1/k)
    };
  }
  
  /**
   * ë””í¼ì§€í™” - ì¤‘ì‹¬ê°’ ë°©ë²•
   */
  private defuzzify(fuzzyMatrix: TriangularFuzzyNumber[][]): number[][] {
    const n = fuzzyMatrix.length;
    const crisp = Array(n).fill(null).map(() => Array(n).fill(0));
    
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        const fuzzy = fuzzyMatrix[i][j];
        // ì¤‘ì‹¬ê°’: (l + 4m + u) / 6
        crisp[i][j] = (fuzzy.l + 4 * fuzzy.m + fuzzy.u) / 6;
      }
    }
    
    return crisp;
  }
  
  /**
   * í¼ì§€ ê°€ì¤‘ì¹˜ ê³„ì‚° (Extent Analysis)
   */
  private calculateFuzzyWeights(
    fuzzyMatrix: TriangularFuzzyNumber[][]
  ): TriangularFuzzyNumber[] {
    const n = fuzzyMatrix.length;
    const weights: TriangularFuzzyNumber[] = [];
    
    // í–‰ í•©ê³„ ê³„ì‚°
    const rowSums: TriangularFuzzyNumber[] = [];
    
    for (let i = 0; i < n; i++) {
      let sumL = 0, sumM = 0, sumU = 0;
      
      for (let j = 0; j < n; j++) {
        sumL += fuzzyMatrix[i][j].l;
        sumM += fuzzyMatrix[i][j].m;
        sumU += fuzzyMatrix[i][j].u;
      }
      
      rowSums.push({ l: sumL, m: sumM, u: sumU });
    }
    
    // ì „ì²´ í•©ê³„
    let totalL = 0, totalM = 0, totalU = 0;
    
    for (const sum of rowSums) {
      totalL += sum.l;
      totalM += sum.m;
      totalU += sum.u;
    }
    
    // ì •ê·œí™”ëœ í¼ì§€ ê°€ì¤‘ì¹˜
    for (const sum of rowSums) {
      weights.push({
        l: sum.l / totalU, // ì£¼ì˜: ì—­ìˆœ
        m: sum.m / totalM,
        u: sum.u / totalL
      });
    }
    
    return weights;
  }
  
  /**
   * í¼ì§€ ê°€ì¤‘ì¹˜ ë””í¼ì§€í™”
   */
  private defuzzifyWeights(fuzzyWeights: TriangularFuzzyNumber[]): number[] {
    return fuzzyWeights.map(fw => (fw.l + 4 * fw.m + fw.u) / 6);
  }
  
  /**
   * ì‹ ë¢°êµ¬ê°„ ê³„ì‚°
   */
  private calculateConfidenceInterval(
    fuzzyWeights: TriangularFuzzyNumber[]
  ): ConfidenceInterval[] {
    return fuzzyWeights.map(fw => ({
      lower: fw.l,
      upper: fw.u,
      confidence: 0.95,
      width: fw.u - fw.l
    }));
  }
}

// íƒ€ì… ì •ì˜
interface TriangularFuzzyNumber {
  l: number; // Lower
  m: number; // Middle
  u: number; // Upper
}

interface FuzzyMatrix {
  size: number;
  getFuzzyElement(i: number, j: number): TriangularFuzzyNumber;
}

interface FuzzyAggregationResult {
  fuzzyMatrix: TriangularFuzzyNumber[][];
  crispMatrix: number[][];
  fuzzyWeights: TriangularFuzzyNumber[];
  crispWeights: number[];
  consistency: ConsistencyInfo;
  method: string;
  confidenceInterval: ConfidenceInterval[];
}
```

---

## 4. í•©ì˜ë„ ì¸¡ì • ì‹œìŠ¤í…œ

### 4.1 í•©ì˜ë„ ì§€í‘œ

```typescript
export class ConsensusAnalyzer {
  /**
   * Shannon Entropy ê¸°ë°˜ í•©ì˜ë„
   */
  calculateShannonConsensus(matrices: number[][][]): ConsensusMetrics {
    const n = matrices[0].length;
    const k = matrices.length;
    let totalEntropy = 0;
    let pairCount = 0;
    
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        // ê° í‰ê°€ìì˜ íŒë‹¨ì„ ë¡œê·¸ ìŠ¤ì¼€ì¼ë¡œ ë³€í™˜
        const logValues = matrices.map(m => Math.log(m[i][j]));
        
        // í‰ê· ê³¼ ë¶„ì‚° ê³„ì‚°
        const mean = logValues.reduce((sum, v) => sum + v, 0) / k;
        const variance = logValues.reduce(
          (sum, v) => sum + Math.pow(v - mean, 2), 0
        ) / k;
        
        // Shannon Entropy
        const entropy = variance > 0 
          ? 0.5 * Math.log(2 * Math.PI * Math.E * variance)
          : 0;
        
        totalEntropy += entropy;
        pairCount++;
      }
    }
    
    // ì •ê·œí™”ëœ í•©ì˜ë„ (0-1)
    const maxEntropy = Math.log(k); // ìµœëŒ€ ì—”íŠ¸ë¡œí”¼
    const avgEntropy = pairCount > 0 ? totalEntropy / pairCount : 0;
    const consensus = 1 - Math.min(avgEntropy / maxEntropy, 1);
    
    return {
      consensus,
      entropy: avgEntropy,
      interpretation: this.interpretConsensus(consensus),
      pairwiseConsensus: this.calculatePairwiseConsensus(matrices)
    };
  }
  
  /**
   * Compatibility Index ê¸°ë°˜ í•©ì˜ë„
   */
  calculateCompatibilityConsensus(
    matrices: number[][][]
  ): CompatibilityMetrics {
    const k = matrices.length;
    let totalCompatibility = 0;
    let pairCount = 0;
    
    // ëª¨ë“  í‰ê°€ì ìŒì— ëŒ€í•œ í˜¸í™˜ì„± ê³„ì‚°
    for (let e1 = 0; e1 < k; e1++) {
      for (let e2 = e1 + 1; e2 < k; e2++) {
        const compatibility = this.calculateMatrixCompatibility(
          matrices[e1],
          matrices[e2]
        );
        totalCompatibility += compatibility;
        pairCount++;
      }
    }
    
    const avgCompatibility = pairCount > 0 
      ? totalCompatibility / pairCount 
      : 0;
    
    return {
      compatibility: avgCompatibility,
      threshold: 0.7,
      isAcceptable: avgCompatibility >= 0.7,
      evaluatorPairs: this.getEvaluatorCompatibilities(matrices)
    };
  }
  
  /**
   * ë‘ ë§¤íŠ¸ë¦­ìŠ¤ ê°„ í˜¸í™˜ì„±
   */
  private calculateMatrixCompatibility(
    matrix1: number[][],
    matrix2: number[][]
  ): number {
    const n = matrix1.length;
    let sumDiff = 0;
    let pairCount = 0;
    
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const ratio = matrix1[i][j] / matrix2[i][j];
        const logDiff = Math.abs(Math.log(ratio));
        
        // Saaty's compatibility: e^(-logDiff)
        sumDiff += Math.exp(-logDiff);
        pairCount++;
      }
    }
    
    return pairCount > 0 ? sumDiff / pairCount : 0;
  }
  
  /**
   * Kendall's W (ì¼ì¹˜ ê³„ìˆ˜)
   */
  calculateKendallW(priorityVectors: number[][]): KendallMetrics {
    const k = priorityVectors.length; // í‰ê°€ì ìˆ˜
    const n = priorityVectors[0].length; // ëŒ€ì•ˆ ìˆ˜
    
    // ìˆœìœ„ ë³€í™˜
    const rankings: number[][] = priorityVectors.map(pv => 
      this.convertToRanks(pv)
    );
    
    // ê° ëŒ€ì•ˆì˜ ìˆœìœ„ í•©ê³„
    const rankSums: number[] = Array(n).fill(0);
    
    for (let j = 0; j < n; j++) {
      for (let i = 0; i < k; i++) {
        rankSums[j] += rankings[i][j];
      }
    }
    
    // í‰ê·  ìˆœìœ„
    const meanRank = (k * (n + 1)) / 2;
    
    // Sum of Squares
    let SS = 0;
    for (const sum of rankSums) {
      SS += Math.pow(sum - meanRank * k, 2);
    }
    
    // Kendall's W
    const W = (12 * SS) / (k * k * (n * n * n - n));
    
    // Chi-square test
    const chiSquare = k * (n - 1) * W;
    const df = n - 1;
    const pValue = this.chiSquarePValue(chiSquare, df);
    
    return {
      W,
      chiSquare,
      df,
      pValue,
      interpretation: W > 0.7 ? 'Strong Agreement' : 
                     W > 0.5 ? 'Moderate Agreement' : 
                     W > 0.3 ? 'Weak Agreement' : 'No Agreement'
    };
  }
  
  /**
   * ìš°ì„ ìˆœìœ„ë¥¼ ìˆœìœ„ë¡œ ë³€í™˜
   */
  private convertToRanks(priorities: number[]): number[] {
    const indexed = priorities.map((p, i) => ({ value: p, index: i }));
    indexed.sort((a, b) => b.value - a.value);
    
    const ranks = Array(priorities.length);
    indexed.forEach((item, rank) => {
      ranks[item.index] = rank + 1;
    });
    
    return ranks;
  }
  
  /**
   * í•©ì˜ë„ í•´ì„
   */
  private interpretConsensus(consensus: number): string {
    if (consensus >= 0.9) return 'Very High Consensus';
    if (consensus >= 0.7) return 'High Consensus';
    if (consensus >= 0.5) return 'Moderate Consensus';
    if (consensus >= 0.3) return 'Low Consensus';
    return 'Very Low Consensus';
  }
  
  /**
   * ìŒë³„ í•©ì˜ë„ ê³„ì‚°
   */
  private calculatePairwiseConsensus(
    matrices: number[][][]
  ): PairwiseConsensus[] {
    const n = matrices[0].length;
    const results: PairwiseConsensus[] = [];
    
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const values = matrices.map(m => m[i][j]);
        const logValues = values.map(v => Math.log(v));
        
        const mean = logValues.reduce((sum, v) => sum + v, 0) / logValues.length;
        const std = Math.sqrt(
          logValues.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / logValues.length
        );
        
        results.push({
          i, j,
          mean: Math.exp(mean),
          std,
          cv: std / Math.abs(mean), // Coefficient of Variation
          consensus: Math.exp(-std)
        });
      }
    }
    
    return results.sort((a, b) => a.consensus - b.consensus);
  }
}
```

### 4.2 ì´ê²¬ ë¶„ì„ ë° í•´ê²°

```typescript
export class DisagreementResolver {
  private consensusThreshold: number = 0.7;
  
  /**
   * ì´ê²¬ ì‹ë³„ ë° ë¶„ì„
   */
  async analyzeDisagreements(
    group: EvaluationGroup,
    matrices: Map<string, number[][]>
  ): Promise<DisagreementAnalysis> {
    const disagreements: Disagreement[] = [];
    const evaluatorIds = Array.from(matrices.keys());
    
    // ëª¨ë“  í‰ê°€ì ìŒì— ëŒ€í•´ ì´ê²¬ ë¶„ì„
    for (let e1 = 0; e1 < evaluatorIds.length; e1++) {
      for (let e2 = e1 + 1; e2 < evaluatorIds.length; e2++) {
        const matrix1 = matrices.get(evaluatorIds[e1])!;
        const matrix2 = matrices.get(evaluatorIds[e2])!;
        
        const pairDisagreements = this.findDisagreements(
          matrix1, matrix2,
          evaluatorIds[e1], evaluatorIds[e2]
        );
        
        disagreements.push(...pairDisagreements);
      }
    }
    
    // ì´ê²¬ì´ í° ìˆœìœ¼ë¡œ ì •ë ¬
    disagreements.sort((a, b) => b.score - a.score);
    
    // í´ëŸ¬ìŠ¤í„°ë§ìœ¼ë¡œ í‰ê°€ì ê·¸ë£¹ ì‹ë³„
    const clusters = await this.clusterEvaluators(matrices);
    
    return {
      totalDisagreements: disagreements.length,
      criticalDisagreements: disagreements.filter(d => d.score > 2),
      clusters,
      recommendations: this.generateRecommendations(disagreements, clusters),
      heatmap: this.generateDisagreementHeatmap(matrices)
    };
  }
  
  /**
   * ë‘ ë§¤íŠ¸ë¦­ìŠ¤ ê°„ ì´ê²¬ ì°¾ê¸°
   */
  private findDisagreements(
    matrix1: number[][],
    matrix2: number[][],
    evaluator1: string,
    evaluator2: string
  ): Disagreement[] {
    const disagreements: Disagreement[] = [];
    const n = matrix1.length;
    
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const value1 = matrix1[i][j];
        const value2 = matrix2[i][j];
        
        // ë¡œê·¸ ìŠ¤ì¼€ì¼ì—ì„œì˜ ì°¨ì´
        const logDiff = Math.abs(Math.log(value1 / value2));
        
        if (logDiff > Math.log(3)) { // 3ë°° ì´ìƒ ì°¨ì´
          disagreements.push({
            evaluator1,
            evaluator2,
            position: [i, j],
            value1,
            value2,
            score: logDiff,
            type: this.classifyDisagreement(value1, value2)
          });
        }
      }
    }
    
    return disagreements;
  }
  
  /**
   * ì´ê²¬ ìœ í˜• ë¶„ë¥˜
   */
  private classifyDisagreement(value1: number, value2: number): DisagreementType {
    const ratio = value1 / value2;
    
    if (ratio > 1 && value2 < 1) return 'opposite'; // ë°˜ëŒ€ íŒë‹¨
    if (ratio < 1 && value2 > 1) return 'opposite';
    if (Math.abs(Math.log(ratio)) > Math.log(5)) return 'extreme'; // ê·¹ë‹¨ì  ì°¨ì´
    return 'moderate'; // ë³´í†µ ì°¨ì´
  }
  
  /**
   * í‰ê°€ì í´ëŸ¬ìŠ¤í„°ë§
   */
  private async clusterEvaluators(
    matrices: Map<string, number[][]>
  ): Promise<EvaluatorCluster[]> {
    const evaluatorIds = Array.from(matrices.keys());
    const distanceMatrix = this.calculateDistanceMatrix(matrices);
    
    // Hierarchical clustering
    const clusters = this.hierarchicalClustering(distanceMatrix, evaluatorIds);
    
    return clusters.map(cluster => ({
      id: generateUUID(),
      members: cluster,
      centroid: this.calculateClusterCentroid(cluster, matrices),
      cohesion: this.calculateClusterCohesion(cluster, matrices),
      size: cluster.length
    }));
  }
  
  /**
   * í‰ê°€ì ê°„ ê±°ë¦¬ ë§¤íŠ¸ë¦­ìŠ¤
   */
  private calculateDistanceMatrix(
    matrices: Map<string, number[][]>
  ): number[][] {
    const evaluatorIds = Array.from(matrices.keys());
    const k = evaluatorIds.length;
    const distances = Array(k).fill(null).map(() => Array(k).fill(0));
    
    for (let i = 0; i < k; i++) {
      for (let j = i + 1; j < k; j++) {
        const matrix1 = matrices.get(evaluatorIds[i])!;
        const matrix2 = matrices.get(evaluatorIds[j])!;
        
        distances[i][j] = distances[j][i] = 
          this.calculateMatrixDistance(matrix1, matrix2);
      }
    }
    
    return distances;
  }
  
  /**
   * ë§¤íŠ¸ë¦­ìŠ¤ ê°„ ê±°ë¦¬ (Frobenius norm)
   */
  private calculateMatrixDistance(
    matrix1: number[][],
    matrix2: number[][]
  ): number {
    const n = matrix1.length;
    let sumSquaredDiff = 0;
    
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        const logDiff = Math.log(matrix1[i][j]) - Math.log(matrix2[i][j]);
        sumSquaredDiff += logDiff * logDiff;
      }
    }
    
    return Math.sqrt(sumSquaredDiff);
  }
  
  /**
   * ê³„ì¸µì  í´ëŸ¬ìŠ¤í„°ë§
   */
  private hierarchicalClustering(
    distances: number[][],
    evaluatorIds: string[]
  ): string[][] {
    // Simple implementation - can be replaced with more sophisticated algorithm
    const threshold = this.calculateClusteringThreshold(distances);
    const clusters: string[][] = [];
    const assigned = new Set<number>();
    
    for (let i = 0; i < evaluatorIds.length; i++) {
      if (assigned.has(i)) continue;
      
      const cluster = [evaluatorIds[i]];
      assigned.add(i);
      
      for (let j = i + 1; j < evaluatorIds.length; j++) {
        if (!assigned.has(j) && distances[i][j] < threshold) {
          cluster.push(evaluatorIds[j]);
          assigned.add(j);
        }
      }
      
      clusters.push(cluster);
    }
    
    return clusters;
  }
  
  /**
   * í´ëŸ¬ìŠ¤í„°ë§ ì„ê³„ê°’ ê³„ì‚°
   */
  private calculateClusteringThreshold(distances: number[][]): number {
    const flatDistances: number[] = [];
    
    for (let i = 0; i < distances.length; i++) {
      for (let j = i + 1; j < distances.length; j++) {
        flatDistances.push(distances[i][j]);
      }
    }
    
    flatDistances.sort((a, b) => a - b);
    
    // ì¤‘ì•™ê°’ ì‚¬ìš©
    const median = flatDistances[Math.floor(flatDistances.length / 2)];
    return median * 1.5;
  }
  
  /**
   * ì´ê²¬ í•´ê²° ê¶Œê³ ì‚¬í•­ ìƒì„±
   */
  private generateRecommendations(
    disagreements: Disagreement[],
    clusters: EvaluatorCluster[]
  ): Recommendation[] {
    const recommendations: Recommendation[] = [];
    
    // 1. ê·¹ë‹¨ì  ì´ê²¬ì— ëŒ€í•œ ì¬í‰ê°€ ê¶Œê³ 
    const extremeDisagreements = disagreements.filter(d => d.type === 'extreme');
    if (extremeDisagreements.length > 0) {
      recommendations.push({
        type: 'reevaluation',
        priority: 'high',
        message: `${extremeDisagreements.length} extreme disagreements found. Consider group discussion.`,
        affectedPairs: extremeDisagreements.map(d => d.position)
      });
    }
    
    // 2. í´ëŸ¬ìŠ¤í„° ê¸°ë°˜ í•©ì˜ í˜•ì„±
    if (clusters.length > 1) {
      recommendations.push({
        type: 'consensus_building',
        priority: 'medium',
        message: `${clusters.length} distinct opinion groups identified. Facilitate inter-group dialogue.`,
        clusters: clusters.map(c => c.members)
      });
    }
    
    // 3. Delphi ë°©ë²• ì ìš© ê¶Œê³ 
    if (disagreements.length > 10) {
      recommendations.push({
        type: 'delphi_method',
        priority: 'medium',
        message: 'Consider applying Delphi method for structured consensus building.',
        rounds: 2
      });
    }
    
    return recommendations;
  }
  
  /**
   * ì´ê²¬ íˆíŠ¸ë§µ ìƒì„±
   */
  private generateDisagreementHeatmap(
    matrices: Map<string, number[][]>
  ): HeatmapData {
    const evaluatorIds = Array.from(matrices.keys());
    const n = matrices.values().next().value.length;
    
    const heatmap: number[][] = Array(n).fill(null)
      .map(() => Array(n).fill(0));
    
    // ê° ì…€ë³„ í‘œì¤€í¸ì°¨ ê³„ì‚°
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) continue;
        
        const values: number[] = [];
        for (const matrix of matrices.values()) {
          values.push(Math.log(matrix[i][j]));
        }
        
        const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
        const variance = values.reduce(
          (sum, v) => sum + Math.pow(v - mean, 2), 0
        ) / values.length;
        
        heatmap[i][j] = Math.sqrt(variance);
      }
    }
    
    return {
      data: heatmap,
      maxDisagreement: Math.max(...heatmap.flat()),
      criticalCells: this.findCriticalCells(heatmap)
    };
  }
  
  private findCriticalCells(heatmap: number[][]): [number, number][] {
    const threshold = Math.max(...heatmap.flat()) * 0.7;
    const critical: [number, number][] = [];
    
    for (let i = 0; i < heatmap.length; i++) {
      for (let j = 0; j < heatmap[i].length; j++) {
        if (heatmap[i][j] > threshold) {
          critical.push([i, j]);
        }
      }
    }
    
    return critical;
  }
}
```

---

## 5. ì‹¤ì‹œê°„ ê·¸ë£¹ ëª¨ë‹ˆí„°ë§

### 5.1 WebSocket ê¸°ë°˜ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸

```typescript
export class GroupEvaluationMonitor {
  private io: SocketIO.Server;
  private groupSessions: Map<string, GroupSession>;
  private redis: RedisClient;
  
  constructor(io: SocketIO.Server, redis: RedisClient) {
    this.io = io;
    this.redis = redis;
    this.groupSessions = new Map();
    this.setupSocketHandlers();
  }
  
  /**
   * Socket í•¸ë“¤ëŸ¬ ì„¤ì •
   */
  private setupSocketHandlers(): void {
    this.io.on('connection', (socket: SocketIO.Socket) => {
      socket.on('join_group', (data: JoinGroupData) => {
        this.handleJoinGroup(socket, data);
      });
      
      socket.on('evaluation_update', (data: EvaluationUpdate) => {
        this.handleEvaluationUpdate(socket, data);
      });
      
      socket.on('request_consensus', (data: ConsensusRequest) => {
        this.handleConsensusRequest(socket, data);
      });
      
      socket.on('disconnect', () => {
        this.handleDisconnect(socket);
      });
    });
  }
  
  /**
   * ê·¸ë£¹ ì°¸ì—¬ ì²˜ë¦¬
   */
  private async handleJoinGroup(
    socket: SocketIO.Socket,
    data: JoinGroupData
  ): Promise<void> {
    const { groupId, evaluatorId } = data;
    
    // ê·¸ë£¹ ë£¸ ì°¸ì—¬
    socket.join(`group_${groupId}`);
    socket.data.groupId = groupId;
    socket.data.evaluatorId = evaluatorId;
    
    // ì„¸ì…˜ ì´ˆê¸°í™” ë˜ëŠ” ì—…ë°ì´íŠ¸
    if (!this.groupSessions.has(groupId)) {
      await this.initializeGroupSession(groupId);
    }
    
    const session = this.groupSessions.get(groupId)!;
    session.activeEvaluators.add(evaluatorId);
    
    // í˜„ì¬ ìƒíƒœ ì „ì†¡
    socket.emit('group_state', {
      session,
      activeCount: session.activeEvaluators.size,
      progress: await this.getGroupProgress(groupId)
    });
    
    // ë‹¤ë¥¸ ë©¤ë²„ë“¤ì—ê²Œ ì•Œë¦¼
    socket.to(`group_${groupId}`).emit('member_joined', {
      evaluatorId,
      timestamp: new Date()
    });
  }
  
  /**
   * í‰ê°€ ì—…ë°ì´íŠ¸ ì²˜ë¦¬
   */
  private async handleEvaluationUpdate(
    socket: SocketIO.Socket,
    data: EvaluationUpdate
  ): Promise<void> {
    const { groupId, evaluatorId, nodeId, matrix } = data;
    
    // Redisì— ì €ì¥
    await this.saveEvaluationToCache(groupId, evaluatorId, nodeId, matrix);
    
    // ì‹¤ì‹œê°„ í†µí•© ê³„ì‚°
    const aggregatedResult = await this.calculateRealTimeAggregation(
      groupId, 
      nodeId
    );
    
    // í•©ì˜ë„ ê³„ì‚°
    const consensus = await this.calculateRealTimeConsensus(groupId, nodeId);
    
    // ëª¨ë“  ê·¸ë£¹ ë©¤ë²„ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
    this.io.to(`group_${groupId}`).emit('aggregation_update', {
      nodeId,
      aggregatedMatrix: aggregatedResult.matrix,
      weights: aggregatedResult.weights,
      consensus,
      lastUpdate: new Date(),
      contributorCount: aggregatedResult.contributorCount
    });
    
    // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
    await this.updateGroupProgress(groupId, evaluatorId, nodeId);
  }
  
  /**
   * ì‹¤ì‹œê°„ í†µí•© ê³„ì‚°
   */
  private async calculateRealTimeAggregation(
    groupId: string,
    nodeId: string
  ): Promise<RealTimeAggregation> {
    // Redisì—ì„œ ëª¨ë“  í‰ê°€ ê°€ì ¸ì˜¤ê¸°
    const evaluations = await this.getEvaluationsFromCache(groupId, nodeId);
    
    if (evaluations.length === 0) {
      throw new Error('No evaluations available');
    }
    
    // ê¸°í•˜í‰ê·  í†µí•©
    const aggregator = new GeometricMeanAggregator();
    const result = aggregator.aggregate(evaluations);
    
    return {
      ...result,
      contributorCount: evaluations.length,
      timestamp: new Date()
    };
  }
  
  /**
   * ì‹¤ì‹œê°„ í•©ì˜ë„ ê³„ì‚°
   */
  private async calculateRealTimeConsensus(
    groupId: string,
    nodeId: string
  ): Promise<RealTimeConsensus> {
    const evaluations = await this.getEvaluationsFromCache(groupId, nodeId);
    
    if (evaluations.length < 2) {
      return {
        level: 1,
        status: 'insufficient_data',
        message: 'Need at least 2 evaluators'
      };
    }
    
    const analyzer = new ConsensusAnalyzer();
    const metrics = analyzer.calculateShannonConsensus(evaluations);
    
    return {
      level: metrics.consensus,
      status: metrics.consensus >= 0.7 ? 'acceptable' : 
              metrics.consensus >= 0.5 ? 'moderate' : 'low',
      message: metrics.interpretation,
      details: metrics
    };
  }
  
  /**
   * ê·¸ë£¹ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
   */
  private async updateGroupProgress(
    groupId: string,
    evaluatorId: string,
    nodeId: string
  ): Promise<void> {
    const session = this.groupSessions.get(groupId);
    if (!session) return;
    
    // ê°œì¸ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
    if (!session.individualProgress.has(evaluatorId)) {
      session.individualProgress.set(evaluatorId, new Set());
    }
    session.individualProgress.get(evaluatorId)!.add(nodeId);
    
    // ì „ì²´ ì§„í–‰ë¥  ê³„ì‚°
    const totalNodes = session.totalNodes;
    const completedByAll = this.getNodesCompletedByAll(session);
    const overallProgress = (completedByAll.size / totalNodes) * 100;
    
    // ì§„í–‰ë¥  ë¸Œë¡œë“œìºìŠ¤íŠ¸
    this.io.to(`group_${groupId}`).emit('progress_update', {
      overallProgress,
      individualProgress: Array.from(session.individualProgress.entries())
        .map(([evalId, nodes]) => ({
          evaluatorId: evalId,
          completedNodes: nodes.size,
          percentage: (nodes.size / totalNodes) * 100
        })),
      completedByAll: Array.from(completedByAll),
      timestamp: new Date()
    });
  }
  
  /**
   * ëª¨ë“  í‰ê°€ìê°€ ì™„ë£Œí•œ ë…¸ë“œ ì°¾ê¸°
   */
  private getNodesCompletedByAll(session: GroupSession): Set<string> {
    const allEvaluators = Array.from(session.activeEvaluators);
    const firstEvaluatorNodes = session.individualProgress.get(allEvaluators[0]);
    
    if (!firstEvaluatorNodes) return new Set();
    
    const completedByAll = new Set<string>();
    
    for (const nodeId of firstEvaluatorNodes) {
      let allCompleted = true;
      
      for (const evaluatorId of allEvaluators) {
        const nodes = session.individualProgress.get(evaluatorId);
        if (!nodes || !nodes.has(nodeId)) {
          allCompleted = false;
          break;
        }
      }
      
      if (allCompleted) {
        completedByAll.add(nodeId);
      }
    }
    
    return completedByAll;
  }
  
  /**
   * í•©ì˜ ìš”ì²­ ì²˜ë¦¬
   */
  private async handleConsensusRequest(
    socket: SocketIO.Socket,
    data: ConsensusRequest
  ): Promise<void> {
    const { groupId, nodeId, method } = data;
    
    // Delphi ë°©ë²• ì‹œì‘
    if (method === 'delphi') {
      await this.startDelphiProcess(groupId, nodeId);
    }
    
    // í† ë¡  ì„¸ì…˜ ì‹œì‘
    else if (method === 'discussion') {
      await this.startDiscussionSession(groupId, nodeId);
    }
    
    // ìë™ ì¡°ì •
    else if (method === 'auto_adjust') {
      await this.performAutoAdjustment(groupId, nodeId);
    }
  }
  
  /**
   * Delphi í”„ë¡œì„¸ìŠ¤ ì‹œì‘
   */
  private async startDelphiProcess(
    groupId: string,
    nodeId: string
  ): Promise<void> {
    const session = this.groupSessions.get(groupId);
    if (!session) return;
    
    // í˜„ì¬ í‰ê°€ ìˆ˜ì§‘
    const currentEvaluations = await this.getEvaluationsFromCache(groupId, nodeId);
    
    // í†µê³„ ë¶„ì„
    const statistics = this.calculateDelphiStatistics(currentEvaluations);
    
    // ê° í‰ê°€ìì—ê²Œ í”¼ë“œë°± ì „ì†¡
    for (const evaluatorId of session.activeEvaluators) {
      const socket = this.getEvaluatorSocket(evaluatorId);
      if (socket) {
        socket.emit('delphi_feedback', {
          nodeId,
          statistics,
          yourEvaluation: await this.getEvaluatorMatrix(groupId, evaluatorId, nodeId),
          round: session.delphiRound || 1,
          recommendation: this.generateDelphiRecommendation(statistics)
        });
      }
    }
    
    // Delphi ë¼ìš´ë“œ ì¦ê°€
    session.delphiRound = (session.delphiRound || 0) + 1;
  }
  
  /**
   * Delphi í†µê³„ ê³„ì‚°
   */
  private calculateDelphiStatistics(
    matrices: number[][][]
  ): DelphiStatistics {
    const n = matrices[0].length;
    const statistics: DelphiStatistics = {
      median: Array(n).fill(null).map(() => Array(n).fill(0)),
      quartiles: [],
      outliers: []
    };
    
    // ê° ì…€ë³„ í†µê³„
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        const values = matrices.map(m => m[i][j]);
        values.sort((a, b) => a - b);
        
        // ì¤‘ì•™ê°’
        const mid = Math.floor(values.length / 2);
        statistics.median[i][j] = values.length % 2 === 0
          ? (values[mid - 1] + values[mid]) / 2
          : values[mid];
        
        // ì‚¬ë¶„ìœ„ìˆ˜
        const q1 = values[Math.floor(values.length * 0.25)];
        const q3 = values[Math.floor(values.length * 0.75)];
        
        statistics.quartiles.push({ i, j, q1, q3 });
        
        // ì´ìƒì¹˜ íƒì§€ (IQR ë°©ë²•)
        const iqr = q3 - q1;
        const lowerBound = q1 - 1.5 * iqr;
        const upperBound = q3 + 1.5 * iqr;
        
        values.forEach((value, idx) => {
          if (value < lowerBound || value > upperBound) {
            statistics.outliers.push({
              evaluatorIndex: idx,
              position: [i, j],
              value,
              deviation: value < lowerBound 
                ? lowerBound - value 
                : value - upperBound
            });
          }
        });
      }
    }
    
    return statistics;
  }
}
```

---

## 6. API ì—”ë“œí¬ì¸íŠ¸

### 6.1 REST API ì •ì˜

```typescript
export const groupEvaluationRoutes = {
  // ê·¸ë£¹ ê´€ë¦¬
  'POST /api/groups': 'createGroup',
  'GET /api/groups/:groupId': 'getGroup',
  'PUT /api/groups/:groupId': 'updateGroup',
  'DELETE /api/groups/:groupId': 'deleteGroup',
  
  // ë©¤ë²„ ê´€ë¦¬
  'POST /api/groups/:groupId/members': 'addMember',
  'DELETE /api/groups/:groupId/members/:memberId': 'removeMember',
  'PUT /api/groups/:groupId/members/:memberId/weight': 'updateMemberWeight',
  
  // í†µí•© ê²°ê³¼
  'GET /api/groups/:groupId/aggregation': 'getAggregatedResults',
  'POST /api/groups/:groupId/aggregate': 'performAggregation',
  'GET /api/groups/:groupId/consensus': 'getConsensusMetrics',
  
  // ì´ê²¬ ë¶„ì„
  'GET /api/groups/:groupId/disagreements': 'getDisagreements',
  'POST /api/groups/:groupId/resolve': 'resolveDisagreements',
  
  // ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
  'WS /ws/group/:groupId': 'groupWebSocket'
};
```

---

## 7. ì„±ëŠ¥ ìµœì í™”

### 7.1 ë³‘ë ¬ ì²˜ë¦¬ ë° ìºì‹±

```typescript
export class GroupEvaluationOptimizer {
  private cache: NodeCache;
  private workerPool: WorkerPool;
  
  /**
   * ë³‘ë ¬ í†µí•© ì²˜ë¦¬
   */
  async parallelAggregation(
    groupId: string,
    nodeIds: string[]
  ): Promise<Map<string, AggregatedResult>> {
    const tasks = nodeIds.map(nodeId => ({
      nodeId,
      task: () => this.aggregateNode(groupId, nodeId)
    }));
    
    const results = await this.workerPool.executeParallel(tasks);
    
    return new Map(results.map((r, i) => [nodeIds[i], r]));
  }
  
  /**
   * ì¦ë¶„ ì—…ë°ì´íŠ¸
   */
  async incrementalUpdate(
    groupId: string,
    nodeId: string,
    newEvaluation: number[][]
  ): Promise<AggregatedResult> {
    const cacheKey = `${groupId}_${nodeId}_aggregated`;
    const cached = this.cache.get<CachedAggregation>(cacheKey);
    
    if (cached && cached.evaluatorCount > 0) {
      // ì¦ë¶„ ì—…ë°ì´íŠ¸ ê³µì‹ ì ìš©
      return this.updateAggregation(cached, newEvaluation);
    } else {
      // ì „ì²´ ì¬ê³„ì‚°
      return this.fullAggregation(groupId, nodeId);
    }
  }
}
```

---

## 8. í…ŒìŠ¤íŠ¸ ì „ëµ

### 8.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```typescript
describe('GroupEvaluationAggregator', () => {
  describe('Geometric Mean', () => {
    it('should correctly aggregate 3 matrices', () => {
      const matrices = [
        [[1, 3, 5], [1/3, 1, 2], [1/5, 1/2, 1]],
        [[1, 2, 4], [1/2, 1, 3], [1/4, 1/3, 1]],
        [[1, 4, 6], [1/4, 1, 2], [1/6, 1/2, 1]]
      ];
      
      const aggregator = new GeometricMeanAggregator();
      const result = aggregator.aggregate(matrices);
      
      expect(result.matrix[0][1]).toBeCloseTo(2.88, 2);
      expect(result.consistency.isConsistent).toBe(true);
    });
  });
  
  describe('Consensus Analysis', () => {
    it('should detect low consensus', () => {
      const matrices = [
        [[1, 9, 3], [1/9, 1, 1/5], [1/3, 5, 1]],
        [[1, 1/9, 1/3], [9, 1, 5], [3, 1/5, 1]]
      ];
      
      const analyzer = new ConsensusAnalyzer();
      const metrics = analyzer.calculateShannonConsensus(matrices);
      
      expect(metrics.consensus).toBeLessThan(0.5);
      expect(metrics.interpretation).toContain('Low');
    });
  });
});
```

---

## 9. êµ¬í˜„ ê°€ì´ë“œë¼ì¸

### 9.1 Sonnet êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸

```markdown
## í”„ë¡ íŠ¸ì—”ë“œ
- [ ] ê·¸ë£¹ ìƒì„±/ê´€ë¦¬ UI
- [ ] ì‹¤ì‹œê°„ ì§„í–‰ë¥  ëŒ€ì‹œë³´ë“œ
- [ ] í•©ì˜ë„ ì‹œê°í™” (ê²Œì´ì§€, ì°¨íŠ¸)
- [ ] ì´ê²¬ íˆíŠ¸ë§µ
- [ ] Delphi í”¼ë“œë°± ì¸í„°í˜ì´ìŠ¤

## ë°±ì—”ë“œ
- [ ] Django ëª¨ë¸ êµ¬í˜„
- [ ] WebSocket í•¸ë“¤ëŸ¬
- [ ] Redis ìºì‹± ë ˆì´ì–´
- [ ] ë³‘ë ¬ ì²˜ë¦¬ ì›Œì»¤

## í…ŒìŠ¤íŠ¸
- [ ] í†µí•© ì•Œê³ ë¦¬ì¦˜ í…ŒìŠ¤íŠ¸
- [ ] ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í…ŒìŠ¤íŠ¸
- [ ] ë¶€í•˜ í…ŒìŠ¤íŠ¸ (50ëª… ë™ì‹œ)
```

---

## 10. ë§ˆë¬´ë¦¬

ì´ ì„¤ê³„ ë¬¸ì„œëŠ” ê·¸ë£¹ í‰ê°€ í†µí•© ì‹œìŠ¤í…œì˜ ì™„ì „í•œ êµ¬í˜„ ê°€ì´ë“œì…ë‹ˆë‹¤.
ë‹¤ì–‘í•œ í†µí•© ë°©ë²•ë¡ , í•©ì˜ë„ ì¸¡ì •, ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ë“± 
ê³ ê¸‰ ê¸°ëŠ¥ì„ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤.

**ë¬¸ì„œ ì‘ì„± ì™„ë£Œ**: 2024-11-11
**ë‹¤ìŒ ì‘ì—…**: ì‹¤ì‹œê°„ í‰ê°€ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì„¤ê³„