# ğŸ“Š ê³ ê¸‰ ë¶„ì„ ì‹œìŠ¤í…œ ì„¤ê³„ ë¬¸ì„œ
## ì‘ì„±ì¼: 2024-11-12
## ì‘ì„±ì: Claude Opus 4.1
## í”„ë¡œì íŠ¸: AHP Decision Support Platform

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ëª©ì 
AHP ì˜ì‚¬ê²°ì • ê²°ê³¼ì— ëŒ€í•œ ì‹¬ì¸µ ë¶„ì„ ë° ì‹œê°í™”ë¥¼ ì œê³µí•˜ëŠ” ê³ ê¸‰ ë¶„ì„ ì—”ì§„

### 1.2 í•µì‹¬ ê¸°ëŠ¥
- ë¯¼ê°ë„ ë¶„ì„ (Sensitivity Analysis)
- ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ (Monte Carlo Simulation)
- What-if ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„
- ë¡œë²„ìŠ¤íŠ¸ì„± ë¶„ì„ (Robustness Analysis)
- ë™ì  ìš°ì„ ìˆœìœ„ ì¶”ì 
- ê³ ê¸‰ ì‹œê°í™” ë° ë¦¬í¬íŠ¸ ìƒì„±

### 1.3 ì„±ëŠ¥ ëª©í‘œ
- ë¯¼ê°ë„ ë¶„ì„: < 500ms (100ê°œ ê¸°ì¤€)
- ëª¬í…Œì¹´ë¥¼ë¡œ: 10,000íšŒ ì‹œë®¬ë ˆì´ì…˜ < 5ì´ˆ
- ë¦¬í¬íŠ¸ ìƒì„±: < 3ì´ˆ

---

## 2. ë¯¼ê°ë„ ë¶„ì„ ì—”ì§„

### 2.1 ë‹¨ì¼ ê¸°ì¤€ ë¯¼ê°ë„ ë¶„ì„

```typescript
/**
 * ë¯¼ê°ë„ ë¶„ì„ ì—”ì§„
 * ê° ê¸°ì¤€ì˜ ê°€ì¤‘ì¹˜ ë³€í™”ê°€ ìµœì¢… ìˆœìœ„ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ ë¶„ì„
 */
export class SensitivityAnalyzer {
  private baseWeights: Map<string, number>;
  private alternativeScores: Map<string, number>;
  private criteria: CriterionNode[];
  
  constructor(ahpResults: AHPResults) {
    this.baseWeights = ahpResults.criteriaWeights;
    this.alternativeScores = ahpResults.alternativeScores;
    this.criteria = ahpResults.criteria;
  }

  /**
   * ë‹¨ì¼ ê¸°ì¤€ ë¯¼ê°ë„ ë¶„ì„
   * í•œ ê¸°ì¤€ì˜ ê°€ì¤‘ì¹˜ë¥¼ 0~1 ë²”ìœ„ì—ì„œ ë³€í™”ì‹œí‚¤ë©° ìˆœìœ„ ë³€í™” ê´€ì°°
   */
  performSingleCriterionAnalysis(
    criterionId: string,
    steps: number = 100
  ): SingleCriterionSensitivity {
    const results: SensitivityPoint[] = [];
    const originalWeight = this.baseWeights.get(criterionId) || 0;
    const otherWeights = this.getOtherCriteriaWeights(criterionId);
    
    // 0ì—ì„œ 1ê¹Œì§€ ë³€í™”ì‹œí‚¤ë©° ë¶„ì„
    for (let i = 0; i <= steps; i++) {
      const newWeight = i / steps;
      const scaleFactor = (1 - newWeight) / (1 - originalWeight);
      
      // ë‹¤ë¥¸ ê¸°ì¤€ë“¤ì˜ ê°€ì¤‘ì¹˜ ì¬ì¡°ì •
      const adjustedWeights = new Map<string, number>();
      adjustedWeights.set(criterionId, newWeight);
      
      otherWeights.forEach((weight, id) => {
        adjustedWeights.set(id, weight * scaleFactor);
      });
      
      // ìƒˆë¡œìš´ ëŒ€ì•ˆ ì ìˆ˜ ê³„ì‚°
      const newScores = this.recalculateAlternativeScores(adjustedWeights);
      const ranking = this.getRanking(newScores);
      
      results.push({
        weight: newWeight,
        ranking,
        scores: newScores,
        rankChanges: this.detectRankChanges(ranking)
      });
    }
    
    return {
      criterionId,
      originalWeight,
      sensitivityPoints: results,
      criticalPoints: this.findCriticalPoints(results),
      stabilityRange: this.calculateStabilityRange(results)
    };
  }

  /**
   * ì„ê³„ì  ì°¾ê¸° - ìˆœìœ„ê°€ ë°”ë€ŒëŠ” ì§€ì 
   */
  private findCriticalPoints(
    points: SensitivityPoint[]
  ): CriticalPoint[] {
    const criticalPoints: CriticalPoint[] = [];
    
    for (let i = 1; i < points.length; i++) {
      const prevRanking = points[i - 1].ranking;
      const currRanking = points[i].ranking;
      
      // ìˆœìœ„ ë³€í™” ê°ì§€
      for (let j = 0; j < prevRanking.length; j++) {
        if (prevRanking[j].alternativeId !== currRanking[j].alternativeId) {
          criticalPoints.push({
            weight: points[i].weight,
            weightRange: [points[i - 1].weight, points[i].weight],
            alternativesSwapped: [
              prevRanking[j].alternativeId,
              currRanking[j].alternativeId
            ],
            rankPositions: j + 1,
            sensitivity: this.calculateSensitivityIndex(
              points[i - 1].weight,
              points[i].weight
            )
          });
          break;
        }
      }
    }
    
    return criticalPoints;
  }

  /**
   * ì•ˆì •ì„± ë²”ìœ„ ê³„ì‚° - 1ìˆœìœ„ê°€ ìœ ì§€ë˜ëŠ” ê°€ì¤‘ì¹˜ ë²”ìœ„
   */
  private calculateStabilityRange(
    points: SensitivityPoint[]
  ): StabilityRange {
    const originalFirst = points[0].ranking[0].alternativeId;
    let minWeight = 0;
    let maxWeight = 1;
    let isStable = true;
    
    for (let i = 0; i < points.length; i++) {
      if (points[i].ranking[0].alternativeId === originalFirst) {
        if (i === 0 || points[i - 1].ranking[0].alternativeId !== originalFirst) {
          minWeight = points[i].weight;
        }
      } else {
        if (i > 0 && points[i - 1].ranking[0].alternativeId === originalFirst) {
          maxWeight = points[i - 1].weight;
          isStable = false;
          break;
        }
      }
    }
    
    return {
      minWeight,
      maxWeight,
      range: maxWeight - minWeight,
      isStable,
      stabilityIndex: (maxWeight - minWeight) // 0~1, 1ì´ ê°€ì¥ ì•ˆì •ì 
    };
  }

  /**
   * ë‹¤ì°¨ì› ë¯¼ê°ë„ ë¶„ì„
   * ì—¬ëŸ¬ ê¸°ì¤€ì„ ë™ì‹œì— ë³€í™”ì‹œí‚¤ë©° ë¶„ì„
   */
  performMultiDimensionalAnalysis(
    criteriaIds: string[],
    resolution: number = 10
  ): MultiDimensionalSensitivity {
    const results: MultiDimensionalPoint[] = [];
    const dimensions = criteriaIds.length;
    
    // ëª¨ë“  ì¡°í•©ì— ëŒ€í•´ ë¶„ì„ (ê³„ì‚°ëŸ‰ ì£¼ì˜)
    const iterate = (
      index: number,
      weights: number[]
    ): void => {
      if (index === dimensions) {
        // ê°€ì¤‘ì¹˜ ì •ê·œí™”
        const sum = weights.reduce((a, b) => a + b, 0);
        if (sum > 0 && sum <= 1) {
          const normalizedWeights = weights.map(w => w / sum);
          
          // ìƒˆë¡œìš´ ê°€ì¤‘ì¹˜ë¡œ ê³„ì‚°
          const adjustedWeights = new Map<string, number>();
          criteriaIds.forEach((id, i) => {
            adjustedWeights.set(id, normalizedWeights[i]);
          });
          
          // ë‚˜ë¨¸ì§€ ê¸°ì¤€ë“¤ ì¡°ì •
          this.adjustRemainingWeights(adjustedWeights, criteriaIds);
          
          const scores = this.recalculateAlternativeScores(adjustedWeights);
          const ranking = this.getRanking(scores);
          
          results.push({
            weights: [...normalizedWeights],
            ranking,
            scores,
            stabilityScore: this.calculateStabilityScore(ranking)
          });
        }
        return;
      }
      
      // ì¬ê·€ì ìœ¼ë¡œ ëª¨ë“  ì¡°í•© ìƒì„±
      for (let i = 0; i <= resolution; i++) {
        weights[index] = i / resolution;
        iterate(index + 1, weights);
      }
    };
    
    iterate(0, new Array(dimensions).fill(0));
    
    return {
      criteriaIds,
      dimensions,
      points: results,
      paretoFrontier: this.findParetoFrontier(results),
      stabilityRegions: this.identifyStabilityRegions(results)
    };
  }

  /**
   * ê·¸ë˜ë””ì–¸íŠ¸ ê¸°ë°˜ ë¯¼ê°ë„ ë¶„ì„
   * ê° ê¸°ì¤€ì˜ í•œê³„ ì˜í–¥ë ¥ ê³„ì‚°
   */
  calculateGradientSensitivity(): GradientSensitivity {
    const gradients = new Map<string, number>();
    const epsilon = 0.001; // ë¯¸ì†Œ ë³€í™”ëŸ‰
    
    this.criteria.forEach(criterion => {
      const originalWeight = this.baseWeights.get(criterion.id) || 0;
      
      // ì „ì§„ ì°¨ë¶„ë²•ìœ¼ë¡œ ê·¸ë˜ë””ì–¸íŠ¸ ê³„ì‚°
      const weightPlus = originalWeight + epsilon;
      const weightMinus = Math.max(0, originalWeight - epsilon);
      
      // +epsilonì—ì„œì˜ ì ìˆ˜
      const weightsPlus = new Map(this.baseWeights);
      weightsPlus.set(criterion.id, weightPlus);
      this.normalizeWeights(weightsPlus);
      const scoresPlus = this.recalculateAlternativeScores(weightsPlus);
      
      // -epsilonì—ì„œì˜ ì ìˆ˜
      const weightsMinus = new Map(this.baseWeights);
      weightsMinus.set(criterion.id, weightMinus);
      this.normalizeWeights(weightsMinus);
      const scoresMinus = this.recalculateAlternativeScores(weightsMinus);
      
      // ê·¸ë˜ë””ì–¸íŠ¸ ê³„ì‚° (ì¤‘ì‹¬ ì°¨ë¶„ë²•)
      let totalGradient = 0;
      this.alternativeScores.forEach((_, altId) => {
        const gradientAlt = (
          (scoresPlus.get(altId) || 0) - (scoresMinus.get(altId) || 0)
        ) / (2 * epsilon);
        totalGradient += Math.abs(gradientAlt);
      });
      
      gradients.set(criterion.id, totalGradient);
    });
    
    return {
      gradients,
      mostSensitive: this.findMostSensitive(gradients),
      leastSensitive: this.findLeastSensitive(gradients),
      averageSensitivity: this.calculateAverageSensitivity(gradients)
    };
  }
}

interface SingleCriterionSensitivity {
  criterionId: string;
  originalWeight: number;
  sensitivityPoints: SensitivityPoint[];
  criticalPoints: CriticalPoint[];
  stabilityRange: StabilityRange;
}

interface SensitivityPoint {
  weight: number;
  ranking: AlternativeRank[];
  scores: Map<string, number>;
  rankChanges: RankChange[];
}

interface CriticalPoint {
  weight: number;
  weightRange: [number, number];
  alternativesSwapped: [string, string];
  rankPositions: number;
  sensitivity: number;
}

interface StabilityRange {
  minWeight: number;
  maxWeight: number;
  range: number;
  isStable: boolean;
  stabilityIndex: number;
}
```

### 2.2 ì„±ëŠ¥ ë¯¼ê°ë„ ë¶„ì„

```typescript
/**
 * ì„±ëŠ¥ ë¯¼ê°ë„ ë¶„ì„
 * ëŒ€ì•ˆì˜ ì„±ëŠ¥ ì ìˆ˜ ë³€í™”ê°€ ìˆœìœ„ì— ë¯¸ì¹˜ëŠ” ì˜í–¥
 */
export class PerformanceSensitivityAnalyzer {
  /**
   * ëŒ€ì•ˆ ì„±ëŠ¥ ë¯¼ê°ë„ ë¶„ì„
   */
  analyzeAlternativePerformance(
    alternativeId: string,
    criterionId: string,
    range: [number, number] = [0.5, 2.0],
    steps: number = 50
  ): PerformanceSensitivity {
    const results: PerformancePoint[] = [];
    const originalScore = this.getOriginalScore(alternativeId, criterionId);
    
    for (let i = 0; i <= steps; i++) {
      const multiplier = range[0] + (range[1] - range[0]) * (i / steps);
      const newScore = originalScore * multiplier;
      
      // ìƒˆë¡œìš´ ì ìˆ˜ë¡œ ì¬ê³„ì‚°
      const updatedScores = this.updateAlternativeScore(
        alternativeId,
        criterionId,
        newScore
      );
      
      const ranking = this.getRanking(updatedScores);
      const alternativeRank = this.getAlternativeRank(ranking, alternativeId);
      
      results.push({
        multiplier,
        newScore,
        rank: alternativeRank,
        totalScore: updatedScores.get(alternativeId) || 0,
        ranking
      });
    }
    
    return {
      alternativeId,
      criterionId,
      originalScore,
      performancePoints: results,
      breakEvenPoints: this.findBreakEvenPoints(results),
      dominanceRange: this.calculateDominanceRange(results)
    };
  }

  /**
   * ê· í˜•ì  ì°¾ê¸° - ìˆœìœ„ê°€ ë³€í•˜ëŠ” ì„±ëŠ¥ ê°’
   */
  private findBreakEvenPoints(
    points: PerformancePoint[]
  ): BreakEvenPoint[] {
    const breakPoints: BreakEvenPoint[] = [];
    
    for (let i = 1; i < points.length; i++) {
      if (points[i].rank !== points[i - 1].rank) {
        breakPoints.push({
          multiplierRange: [points[i - 1].multiplier, points[i].multiplier],
          scoreRange: [points[i - 1].newScore, points[i].newScore],
          rankChange: [points[i - 1].rank, points[i].rank],
          criticalValue: (points[i - 1].newScore + points[i].newScore) / 2
        });
      }
    }
    
    return breakPoints;
  }
}
```

---

## 3. ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜

### 3.1 ë¶ˆí™•ì‹¤ì„± ëª¨ë¸ë§

```typescript
/**
 * ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ ì—”ì§„
 * ë¶ˆí™•ì‹¤ì„± í•˜ì—ì„œì˜ ì˜ì‚¬ê²°ì • ë¶„ì„
 */
export class MonteCarloSimulator {
  private rng: RandomNumberGenerator;
  private iterations: number;
  
  constructor(iterations: number = 10000, seed?: number) {
    this.iterations = iterations;
    this.rng = new RandomNumberGenerator(seed);
  }

  /**
   * ìŒëŒ€ë¹„êµ ë¶ˆí™•ì‹¤ì„± ì‹œë®¬ë ˆì´ì…˜
   * í‰ê°€ìì˜ íŒë‹¨ ë¶ˆí™•ì‹¤ì„±ì„ ëª¨ë¸ë§
   */
  simulateComparisonUncertainty(
    baseMatrix: number[][],
    uncertaintyLevel: number = 0.2 // Â±20% ë³€ë™
  ): MonteCarloResults {
    const results: SimulationRun[] = [];
    const rankingFrequency = new Map<string, number[]>();
    
    for (let iter = 0; iter < this.iterations; iter++) {
      // ë¶ˆí™•ì‹¤ì„±ì´ ì ìš©ëœ í–‰ë ¬ ìƒì„±
      const perturbedMatrix = this.perturbMatrix(
        baseMatrix,
        uncertaintyLevel
      );
      
      // AHP ê³„ì‚°
      const ahpMatrix = new PairwiseComparisonMatrix(perturbedMatrix);
      const priorities = ahpMatrix.calculatePriorityVector();
      const cr = ConsistencyChecker.calculateConsistencyRatio(
        ahpMatrix.calculateMaxEigenvalue(),
        baseMatrix.length
      );
      
      // ì¼ê´€ì„± ìˆëŠ” ê²½ìš°ë§Œ ìˆ˜ì§‘
      if (cr <= 0.15) { // ëª¬í…Œì¹´ë¥¼ë¡œì—ì„œëŠ” ê¸°ì¤€ì„ ì™„í™”
        const scores = this.calculateAlternativeScores(priorities);
        const ranking = this.getRanking(scores);
        
        // ìˆœìœ„ ë¹ˆë„ ì¶”ì 
        ranking.forEach((item, rank) => {
          if (!rankingFrequency.has(item.alternativeId)) {
            rankingFrequency.set(
              item.alternativeId,
              new Array(ranking.length).fill(0)
            );
          }
          const freq = rankingFrequency.get(item.alternativeId)!;
          freq[rank]++;
        });
        
        results.push({
          iteration: iter,
          matrix: perturbedMatrix,
          priorities,
          consistencyRatio: cr,
          ranking,
          scores
        });
      }
    }
    
    return {
      totalIterations: this.iterations,
      validIterations: results.length,
      convergenceRate: results.length / this.iterations,
      results,
      statistics: this.calculateStatistics(results),
      rankProbabilities: this.calculateRankProbabilities(rankingFrequency, results.length),
      confidenceIntervals: this.calculateConfidenceIntervals(results),
      stabilityMetrics: this.calculateStabilityMetrics(results)
    };
  }

  /**
   * í–‰ë ¬ ì„­ë™ (perturbation)
   * ë¡œê·¸ì •ê·œë¶„í¬ë¥¼ ì‚¬ìš©í•œ ê³±ì…ˆì  ì„­ë™
   */
  private perturbMatrix(
    matrix: number[][],
    uncertaintyLevel: number
  ): number[][] {
    const n = matrix.length;
    const perturbed = Array(n).fill(null).map(() => Array(n).fill(1));
    
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        // ë¡œê·¸ì •ê·œë¶„í¬ë¡œ ì„­ë™
        const logMean = Math.log(matrix[i][j]);
        const logStd = uncertaintyLevel;
        const perturbation = this.rng.logNormal(logMean, logStd);
        
        // Saaty ì²™ë„ ë²”ìœ„ ì œí•œ [1/9, 9]
        const bounded = Math.max(1/9, Math.min(9, perturbation));
        
        perturbed[i][j] = bounded;
        perturbed[j][i] = 1 / bounded;
      }
    }
    
    return perturbed;
  }

  /**
   * ê°€ì¤‘ì¹˜ ë¶ˆí™•ì‹¤ì„± ì‹œë®¬ë ˆì´ì…˜
   * Beta ë¶„í¬ë¥¼ ì‚¬ìš©í•œ ê°€ì¤‘ì¹˜ ë³€ë™
   */
  simulateWeightUncertainty(
    baseWeights: Map<string, number>,
    confidence: number = 0.8 // ì‹ ë¢°ë„ (alpha, beta íŒŒë¼ë¯¸í„° ê²°ì •)
  ): WeightUncertaintyResults {
    const results: WeightSimulationRun[] = [];
    const weightDistributions = new Map<string, number[]>();
    
    // Beta ë¶„í¬ íŒŒë¼ë¯¸í„° ê³„ì‚°
    const alpha = confidence * 10;
    const beta = (1 - confidence) * 10;
    
    for (let iter = 0; iter < this.iterations; iter++) {
      const sampledWeights = new Map<string, number>();
      let totalWeight = 0;
      
      // ê° ê¸°ì¤€ì— ëŒ€í•´ Beta ë¶„í¬ì—ì„œ ìƒ˜í”Œë§
      baseWeights.forEach((weight, criterionId) => {
        const sample = this.rng.beta(
          alpha * weight,
          beta * (1 - weight)
        );
        sampledWeights.set(criterionId, sample);
        totalWeight += sample;
      });
      
      // ì •ê·œí™”
      sampledWeights.forEach((weight, id) => {
        const normalized = weight / totalWeight;
        sampledWeights.set(id, normalized);
        
        if (!weightDistributions.has(id)) {
          weightDistributions.set(id, []);
        }
        weightDistributions.get(id)!.push(normalized);
      });
      
      // ëŒ€ì•ˆ ì ìˆ˜ ê³„ì‚°
      const scores = this.recalculateAlternativeScores(sampledWeights);
      const ranking = this.getRanking(scores);
      
      results.push({
        iteration: iter,
        weights: sampledWeights,
        scores,
        ranking
      });
    }
    
    return {
      iterations: this.iterations,
      results,
      weightStatistics: this.calculateWeightStatistics(weightDistributions),
      rankingStability: this.analyzeRankingStability(results),
      correlations: this.calculateWeightCorrelations(results)
    };
  }

  /**
   * ì‹œë‚˜ë¦¬ì˜¤ ê¸°ë°˜ ì‹œë®¬ë ˆì´ì…˜
   * ë‹¤ì–‘í•œ ë¯¸ë˜ ì‹œë‚˜ë¦¬ì˜¤ í•˜ì—ì„œì˜ ë¶„ì„
   */
  simulateScenarios(
    scenarios: Scenario[]
  ): ScenarioSimulationResults {
    const results = new Map<string, ScenarioResult>();
    
    scenarios.forEach(scenario => {
      const scenarioRuns: SimulationRun[] = [];
      
      for (let iter = 0; iter < this.iterations; iter++) {
        // ì‹œë‚˜ë¦¬ì˜¤ë³„ íŒŒë¼ë¯¸í„° ì ìš©
        const adjustedWeights = this.applyScenario(scenario);
        
        // ë¶ˆí™•ì‹¤ì„± ì¶”ê°€
        const perturbedWeights = this.perturbWeights(
          adjustedWeights,
          scenario.uncertainty
        );
        
        // ê³„ì‚° ë° ì €ì¥
        const scores = this.recalculateAlternativeScores(perturbedWeights);
        const ranking = this.getRanking(scores);
        
        scenarioRuns.push({
          iteration: iter,
          weights: perturbedWeights,
          scores,
          ranking
        });
      }
      
      results.set(scenario.id, {
        scenario,
        runs: scenarioRuns,
        summary: this.summarizeScenarioResults(scenarioRuns),
        robustness: this.calculateRobustness(scenarioRuns)
      });
    });
    
    return {
      scenarios: results,
      crossScenarioAnalysis: this.analyzeCrossScenario(results),
      recommendedAlternative: this.findRobustAlternative(results)
    };
  }

  /**
   * í†µê³„ ê³„ì‚°
   */
  private calculateStatistics(
    results: SimulationRun[]
  ): SimulationStatistics {
    const scoreArrays = new Map<string, number[]>();
    
    // ê° ëŒ€ì•ˆì˜ ì ìˆ˜ ìˆ˜ì§‘
    results.forEach(run => {
      run.scores.forEach((score, altId) => {
        if (!scoreArrays.has(altId)) {
          scoreArrays.set(altId, []);
        }
        scoreArrays.get(altId)!.push(score);
      });
    });
    
    const statistics = new Map<string, AlternativeStatistics>();
    
    scoreArrays.forEach((scores, altId) => {
      statistics.set(altId, {
        mean: this.mean(scores),
        median: this.median(scores),
        standardDeviation: this.standardDeviation(scores),
        min: Math.min(...scores),
        max: Math.max(...scores),
        percentile25: this.percentile(scores, 25),
        percentile75: this.percentile(scores, 75),
        coefficientOfVariation: this.coefficientOfVariation(scores)
      });
    });
    
    return {
      alternativeStats: statistics,
      overallConvergence: this.checkConvergence(results),
      stabilityIndex: this.calculateOverallStability(results)
    };
  }

  /**
   * ìˆœìœ„ í™•ë¥  ê³„ì‚°
   */
  private calculateRankProbabilities(
    frequency: Map<string, number[]>,
    total: number
  ): Map<string, number[]> {
    const probabilities = new Map<string, number[]>();
    
    frequency.forEach((freq, altId) => {
      const probs = freq.map(f => f / total);
      probabilities.set(altId, probs);
    });
    
    return probabilities;
  }

  /**
   * ì‹ ë¢°êµ¬ê°„ ê³„ì‚° (ë¶€íŠ¸ìŠ¤íŠ¸ë© ë°©ë²•)
   */
  private calculateConfidenceIntervals(
    results: SimulationRun[],
    confidenceLevel: number = 0.95
  ): Map<string, ConfidenceInterval> {
    const intervals = new Map<string, ConfidenceInterval>();
    const alpha = 1 - confidenceLevel;
    
    // ê° ëŒ€ì•ˆì— ëŒ€í•´
    this.getAlternativeIds(results).forEach(altId => {
      const scores = results.map(r => r.scores.get(altId) || 0);
      scores.sort((a, b) => a - b);
      
      const lowerIndex = Math.floor(scores.length * (alpha / 2));
      const upperIndex = Math.ceil(scores.length * (1 - alpha / 2));
      
      intervals.set(altId, {
        lower: scores[lowerIndex],
        upper: scores[upperIndex],
        mean: this.mean(scores),
        confidenceLevel
      });
    });
    
    return intervals;
  }
}

interface MonteCarloResults {
  totalIterations: number;
  validIterations: number;
  convergenceRate: number;
  results: SimulationRun[];
  statistics: SimulationStatistics;
  rankProbabilities: Map<string, number[]>;
  confidenceIntervals: Map<string, ConfidenceInterval>;
  stabilityMetrics: StabilityMetrics;
}

interface SimulationRun {
  iteration: number;
  matrix?: number[][];
  weights?: Map<string, number>;
  priorities?: number[];
  consistencyRatio?: number;
  ranking: AlternativeRank[];
  scores: Map<string, number>;
}
```

### 3.2 ëœë¤ ìˆ«ì ìƒì„±ê¸°

```typescript
/**
 * ì‹œë“œ ê¸°ë°˜ ë‚œìˆ˜ ìƒì„±ê¸°
 * ì¬í˜„ ê°€ëŠ¥í•œ ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•´
 */
class RandomNumberGenerator {
  private seed: number;
  
  constructor(seed: number = Date.now()) {
    this.seed = seed;
  }

  /**
   * Linear Congruential Generator
   */
  private next(): number {
    this.seed = (this.seed * 1664525 + 1013904223) % 4294967296;
    return this.seed / 4294967296;
  }

  /**
   * ê· ë“±ë¶„í¬ [min, max]
   */
  uniform(min: number = 0, max: number = 1): number {
    return min + (max - min) * this.next();
  }

  /**
   * ì •ê·œë¶„í¬
   */
  normal(mean: number = 0, std: number = 1): number {
    // Box-Muller ë³€í™˜
    const u1 = this.next();
    const u2 = this.next();
    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    return mean + std * z;
  }

  /**
   * ë¡œê·¸ì •ê·œë¶„í¬
   */
  logNormal(logMean: number, logStd: number): number {
    return Math.exp(this.normal(logMean, logStd));
  }

  /**
   * Beta ë¶„í¬
   */
  beta(alpha: number, beta: number): number {
    // ê°ë§ˆ ë¶„í¬ë¥¼ ì‚¬ìš©í•œ Beta ìƒì„±
    const x = this.gamma(alpha);
    const y = this.gamma(beta);
    return x / (x + y);
  }

  /**
   * ê°ë§ˆ ë¶„í¬ (Marsaglia and Tsang method)
   */
  private gamma(shape: number): number {
    if (shape < 1) {
      return this.gamma(shape + 1) * Math.pow(this.next(), 1 / shape);
    }
    
    const d = shape - 1/3;
    const c = 1 / Math.sqrt(9 * d);
    
    while (true) {
      const x = this.normal();
      const v = Math.pow(1 + c * x, 3);
      
      if (v > 0) {
        const u = this.next();
        const xSquared = x * x;
        
        if (u < 1 - 0.0331 * xSquared * xSquared) {
          return d * v;
        }
        
        if (Math.log(u) < 0.5 * xSquared + d * (1 - v + Math.log(v))) {
          return d * v;
        }
      }
    }
  }
}
```

---

## 4. What-if ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„

### 4.1 ì‹œë‚˜ë¦¬ì˜¤ ëª¨ë¸ë§

```typescript
/**
 * What-if ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„ ì—”ì§„
 */
export class WhatIfAnalyzer {
  private baseScenario: BaseScenario;
  private alternatives: Alternative[];
  private criteria: Criterion[];

  /**
   * ì‹œë‚˜ë¦¬ì˜¤ ì •ì˜ ë° ì‹¤í–‰
   */
  defineScenario(
    name: string,
    changes: ScenarioChange[]
  ): ScenarioDefinition {
    return {
      id: this.generateScenarioId(),
      name,
      description: this.generateDescription(changes),
      changes,
      timestamp: new Date(),
      type: this.classifyScenarioType(changes)
    };
  }

  /**
   * ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰
   */
  executeScenario(scenario: ScenarioDefinition): ScenarioExecutionResult {
    // ë² ì´ìŠ¤ë¼ì¸ ì €ì¥
    const baseline = this.captureBaseline();
    
    // ë³€ê²½ì‚¬í•­ ì ìš©
    const modifiedState = this.applyChanges(scenario.changes);
    
    // AHP ì¬ê³„ì‚°
    const newResults = this.recalculateAHP(modifiedState);
    
    // ì˜í–¥ ë¶„ì„
    const impact = this.analyzeImpact(baseline, newResults);
    
    // ë³µì› ê°€ëŠ¥í•œ ì•¡ì…˜ ìƒì„±
    const revertActions = this.generateRevertActions(scenario.changes);
    
    return {
      scenario,
      baseline,
      results: newResults,
      impact,
      recommendations: this.generateRecommendations(impact),
      revertActions,
      confidence: this.calculateConfidence(scenario, newResults)
    };
  }

  /**
   * ë³µí•© ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„
   * ì—¬ëŸ¬ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì¡°í•©í•˜ì—¬ ë¶„ì„
   */
  analyzeCompositeScenario(
    scenarios: ScenarioDefinition[]
  ): CompositeScenarioResult {
    const individualResults: ScenarioExecutionResult[] = [];
    const interactionEffects: InteractionEffect[] = [];
    
    // ê°œë³„ ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰
    scenarios.forEach(scenario => {
      individualResults.push(this.executeScenario(scenario));
    });
    
    // ì¡°í•© ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰
    const combinedChanges = scenarios.flatMap(s => s.changes);
    const combinedScenario = this.defineScenario(
      'Combined Scenario',
      combinedChanges
    );
    const combinedResult = this.executeScenario(combinedScenario);
    
    // ìƒí˜¸ì‘ìš© íš¨ê³¼ ë¶„ì„
    for (let i = 0; i < scenarios.length; i++) {
      for (let j = i + 1; j < scenarios.length; j++) {
        const interaction = this.analyzeInteraction(
          individualResults[i],
          individualResults[j],
          combinedResult
        );
        interactionEffects.push(interaction);
      }
    }
    
    return {
      individualResults,
      combinedResult,
      interactionEffects,
      synergies: this.identifySynergies(interactionEffects),
      conflicts: this.identifyConflicts(interactionEffects),
      optimalCombination: this.findOptimalCombination(scenarios)
    };
  }

  /**
   * ëª©í‘œ íƒìƒ‰ ì‹œë‚˜ë¦¬ì˜¤
   * ì›í•˜ëŠ” ê²°ê³¼ë¥¼ ì–»ê¸° ìœ„í•œ ë³€ê²½ì‚¬í•­ ì°¾ê¸°
   */
  goalSeekingScenario(
    targetAlternative: string,
    targetRank: number = 1
  ): GoalSeekingResult {
    const currentRank = this.getCurrentRank(targetAlternative);
    
    if (currentRank === targetRank) {
      return {
        achieved: true,
        currentRank,
        targetRank,
        requiredChanges: [],
        feasibility: 1.0
      };
    }
    
    // ìœ ì „ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•œ ìµœì í™”
    const optimizer = new GeneticOptimizer({
      populationSize: 100,
      generations: 50,
      mutationRate: 0.1,
      crossoverRate: 0.7
    });
    
    const solution = optimizer.optimize(
      (changes: ScenarioChange[]) => {
        const result = this.executeScenario(
          this.defineScenario('Goal Seeking', changes)
        );
        const newRank = this.getRankFromResults(
          result.results,
          targetAlternative
        );
        
        // ëª©ì í•¨ìˆ˜: ìˆœìœ„ ì°¨ì´ ìµœì†Œí™” + ë³€ê²½ ìµœì†Œí™”
        const rankDiff = Math.abs(newRank - targetRank);
        const changePenalty = changes.length * 0.1;
        
        return -(rankDiff + changePenalty);
      }
    );
    
    return {
      achieved: solution.fitness === 0,
      currentRank,
      targetRank,
      requiredChanges: solution.changes,
      feasibility: this.assessFeasibility(solution.changes),
      alternativePaths: this.findAlternativePaths(
        targetAlternative,
        targetRank
      )
    };
  }

  /**
   * íŒŒë ˆí†  ìµœì  ì‹œë‚˜ë¦¬ì˜¤
   * ë‹¤ì¤‘ ëª©í‘œ ìµœì í™”
   */
  findParetoOptimalScenarios(
    objectives: Objective[]
  ): ParetoOptimalResult {
    const scenarios: EvaluatedScenario[] = [];
    const sampleSize = 1000;
    
    // ëœë¤ ì‹œë‚˜ë¦¬ì˜¤ ìƒì„± ë° í‰ê°€
    for (let i = 0; i < sampleSize; i++) {
      const changes = this.generateRandomChanges();
      const scenario = this.defineScenario(`Scenario ${i}`, changes);
      const result = this.executeScenario(scenario);
      
      const scores = objectives.map(obj => 
        obj.evaluate(result)
      );
      
      scenarios.push({
        scenario,
        result,
        objectiveScores: scores
      });
    }
    
    // íŒŒë ˆí†  í”„ë¡ í‹°ì–´ ì°¾ê¸°
    const paretoFront = this.findParetoFrontier(scenarios);
    
    // íŠ¸ë ˆì´ë“œì˜¤í”„ ë¶„ì„
    const tradeoffs = this.analyzeTradeoffs(paretoFront, objectives);
    
    return {
      allScenarios: scenarios,
      paretoFront,
      tradeoffs,
      recommendedScenarios: this.recommendScenarios(
        paretoFront,
        objectives
      )
    };
  }
}

interface ScenarioChange {
  type: 'weight' | 'score' | 'comparison' | 'alternative' | 'criterion';
  target: string;
  subTarget?: string;
  oldValue: any;
  newValue: any;
  reason?: string;
}

interface ScenarioExecutionResult {
  scenario: ScenarioDefinition;
  baseline: BaselineState;
  results: AHPResults;
  impact: ImpactAnalysis;
  recommendations: Recommendation[];
  revertActions: RevertAction[];
  confidence: number;
}
```

---

## 5. ë¡œë²„ìŠ¤íŠ¸ì„± ë¶„ì„

### 5.1 ë¡œë²„ìŠ¤íŠ¸ì„± ì¸¡ì •

```typescript
/**
 * ë¡œë²„ìŠ¤íŠ¸ì„± ë¶„ì„ê¸°
 * ë‹¤ì–‘í•œ ë¶ˆí™•ì‹¤ì„± í•˜ì—ì„œì˜ ì•ˆì •ì„± í‰ê°€
 */
export class RobustnessAnalyzer {
  /**
   * ìˆœìœ„ ì—­ì „ ë¶„ì„
   * ìˆœìœ„ê°€ ë°”ë€ŒëŠ” ì¡°ê±´ ì°¾ê¸°
   */
  analyzeRankReversal(): RankReversalAnalysis {
    const reversalConditions: ReversalCondition[] = [];
    const alternatives = this.getAlternatives();
    
    // ëª¨ë“  ëŒ€ì•ˆ ìŒì— ëŒ€í•´ ë¶„ì„
    for (let i = 0; i < alternatives.length; i++) {
      for (let j = i + 1; j < alternatives.length; j++) {
        const alt1 = alternatives[i];
        const alt2 = alternatives[j];
        
        if (this.getRank(alt1) < this.getRank(alt2)) {
          // alt1ì´ alt2ë³´ë‹¤ ë†’ì€ ìˆœìœ„
          const condition = this.findReversalCondition(alt1, alt2);
          
          if (condition) {
            reversalConditions.push({
              higher: alt1,
              lower: alt2,
              condition,
              probability: this.estimateReversalProbability(condition),
              impact: this.assessReversalImpact(alt1, alt2)
            });
          }
        }
      }
    }
    
    return {
      reversalConditions,
      mostVulnerable: this.findMostVulnerable(reversalConditions),
      overallRobustness: this.calculateOverallRobustness(reversalConditions)
    };
  }

  /**
   * ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸
   * ê·¹ë‹¨ì  ì¡°ê±´ì—ì„œì˜ ì„±ëŠ¥ í‰ê°€
   */
  performStressTest(
    stressLevels: number[] = [0.1, 0.2, 0.3, 0.5]
  ): StressTestResult {
    const results: StressLevelResult[] = [];
    
    stressLevels.forEach(level => {
      const stressedResults: AHPResults[] = [];
      
      // ë‹¤ì–‘í•œ ìŠ¤íŠ¸ë ˆìŠ¤ ì‹œë‚˜ë¦¬ì˜¤ ìƒì„±
      const scenarios = this.generateStressScenarios(level);
      
      scenarios.forEach(scenario => {
        const result = this.applyStress(scenario);
        stressedResults.push(result);
      });
      
      // ìŠ¤íŠ¸ë ˆìŠ¤ ë ˆë²¨ë³„ ê²°ê³¼ ë¶„ì„
      results.push({
        stressLevel: level,
        scenarios: scenarios.length,
        rankingStability: this.measureRankingStability(stressedResults),
        scoreVariation: this.measureScoreVariation(stressedResults),
        consistencyDegradation: this.measureConsistencyDegradation(stressedResults),
        failurePoints: this.identifyFailurePoints(stressedResults)
      });
    });
    
    return {
      stressLevels: results,
      breakingPoint: this.findBreakingPoint(results),
      resilience: this.calculateResilience(results),
      recommendations: this.generateStressRecommendations(results)
    };
  }

  /**
   * ëŒ€ì•ˆ ì¶”ê°€/ì œê±° ë¡œë²„ìŠ¤íŠ¸ì„±
   * IIA (Independence of Irrelevant Alternatives) ê²€ì¦
   */
  testIIARobustness(): IIARobustnessResult {
    const baseRanking = this.getBaseRanking();
    const violations: IIAViolation[] = [];
    
    // ëŒ€ì•ˆ ì œê±° í…ŒìŠ¤íŠ¸
    this.alternatives.forEach(altToRemove => {
      const newRanking = this.recalculateWithoutAlternative(altToRemove);
      const violation = this.checkIIAViolation(
        baseRanking,
        newRanking,
        altToRemove
      );
      
      if (violation) {
        violations.push({
          type: 'removal',
          alternative: altToRemove,
          violation,
          severity: this.assessViolationSeverity(violation)
        });
      }
    });
    
    // ëŒ€ì•ˆ ì¶”ê°€ í…ŒìŠ¤íŠ¸
    const hypotheticalAlternatives = this.generateHypotheticalAlternatives();
    
    hypotheticalAlternatives.forEach(newAlt => {
      const newRanking = this.recalculateWithNewAlternative(newAlt);
      const violation = this.checkIIAViolation(
        baseRanking,
        newRanking,
        null,
        newAlt
      );
      
      if (violation) {
        violations.push({
          type: 'addition',
          alternative: newAlt,
          violation,
          severity: this.assessViolationSeverity(violation)
        });
      }
    });
    
    return {
      iiaCompliant: violations.length === 0,
      violations,
      robustnessScore: 1 - (violations.length / (this.alternatives.length * 2)),
      recommendations: this.generateIIARecommendations(violations)
    };
  }
}
```

---

## 6. ì‹œê°í™” ë° ë¦¬í¬íŠ¸ ìƒì„±

### 6.1 ë¦¬í¬íŠ¸ ìƒì„± ì—”ì§„

```typescript
/**
 * ê³ ê¸‰ ë¶„ì„ ë¦¬í¬íŠ¸ ìƒì„±ê¸°
 */
export class AnalysisReportGenerator {
  /**
   * ì¢…í•© ë¶„ì„ ë¦¬í¬íŠ¸ ìƒì„±
   */
  async generateComprehensiveReport(
    analysisResults: ComprehensiveAnalysisResults
  ): Promise<AnalysisReport> {
    const report: AnalysisReport = {
      metadata: this.generateMetadata(),
      executiveSummary: await this.generateExecutiveSummary(analysisResults),
      sections: []
    };

    // 1. ê¸°ë³¸ AHP ê²°ê³¼
    report.sections.push(
      await this.generateBasicResultsSection(analysisResults.basic)
    );

    // 2. ë¯¼ê°ë„ ë¶„ì„
    report.sections.push(
      await this.generateSensitivitySection(analysisResults.sensitivity)
    );

    // 3. ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜
    report.sections.push(
      await this.generateMonteCarloSection(analysisResults.monteCarlo)
    );

    // 4. What-if ì‹œë‚˜ë¦¬ì˜¤
    report.sections.push(
      await this.generateScenarioSection(analysisResults.scenarios)
    );

    // 5. ë¡œë²„ìŠ¤íŠ¸ì„± ë¶„ì„
    report.sections.push(
      await this.generateRobustnessSection(analysisResults.robustness)
    );

    // 6. ê¶Œê³ ì‚¬í•­
    report.sections.push(
      await this.generateRecommendationsSection(analysisResults)
    );

    // 7. ë¶€ë¡
    report.appendices = await this.generateAppendices(analysisResults);

    return report;
  }

  /**
   * ì‹œê°í™” ìƒì„±
   */
  private async generateVisualizations(
    data: AnalysisData
  ): Promise<Visualization[]> {
    const visualizations: Visualization[] = [];

    // 1. ë¯¼ê°ë„ ë¶„ì„ ì°¨íŠ¸
    visualizations.push({
      type: 'sensitivity-tornado',
      title: 'í† ë„¤ì´ë„ ë‹¤ì´ì–´ê·¸ë¨',
      data: this.prepareTornadoData(data.sensitivity),
      options: {
        width: 800,
        height: 400,
        colors: ['#667eea', '#f56565'],
        interactive: true
      }
    });

    // 2. ëª¬í…Œì¹´ë¥¼ë¡œ íˆìŠ¤í† ê·¸ë¨
    visualizations.push({
      type: 'monte-carlo-histogram',
      title: 'ìˆœìœ„ í™•ë¥  ë¶„í¬',
      data: this.prepareHistogramData(data.monteCarlo),
      options: {
        bins: 20,
        showProbabilityDensity: true,
        confidenceIntervals: [0.95, 0.99]
      }
    });

    // 3. ìŠ¤íŒŒì´ë” ì°¨íŠ¸ (ë‹¤ì°¨ì› ë¹„êµ)
    visualizations.push({
      type: 'spider-chart',
      title: 'ëŒ€ì•ˆë³„ ì„±ëŠ¥ ë¹„êµ',
      data: this.prepareSpiderData(data.alternatives),
      options: {
        axes: data.criteria.map(c => c.name),
        fillOpacity: 0.3,
        animation: true
      }
    });

    // 4. íˆíŠ¸ë§µ (ìƒê´€ê´€ê³„)
    visualizations.push({
      type: 'heatmap',
      title: 'ê¸°ì¤€ ê°„ ìƒê´€ê´€ê³„',
      data: this.prepareHeatmapData(data.correlations),
      options: {
        colorScale: 'RdBu',
        showValues: true,
        clustering: true
      }
    });

    return visualizations;
  }

  /**
   * PDF ë¦¬í¬íŠ¸ ìƒì„±
   */
  async exportToPDF(report: AnalysisReport): Promise<Buffer> {
    const pdfDoc = new PDFDocument({
      size: 'A4',
      margin: 50,
      info: {
        Title: report.metadata.title,
        Author: 'AHP Analysis System',
        Subject: 'Advanced Analysis Report',
        CreationDate: new Date()
      }
    });

    // í‘œì§€
    this.addCoverPage(pdfDoc, report);

    // ëª©ì°¨
    this.addTableOfContents(pdfDoc, report);

    // ê° ì„¹ì…˜ ì¶”ê°€
    for (const section of report.sections) {
      await this.addSection(pdfDoc, section);
    }

    // ë¶€ë¡
    if (report.appendices) {
      await this.addAppendices(pdfDoc, report.appendices);
    }

    return pdfDoc.end();
  }

  /**
   * Excel ë¦¬í¬íŠ¸ ìƒì„±
   */
  async exportToExcel(
    analysisResults: ComprehensiveAnalysisResults
  ): Promise<ExcelWorkbook> {
    const workbook = new ExcelWorkbook();

    // ìš”ì•½ ì‹œíŠ¸
    const summarySheet = workbook.addWorksheet('Summary');
    this.populateSummarySheet(summarySheet, analysisResults);

    // ê¸°ë³¸ ê²°ê³¼ ì‹œíŠ¸
    const resultsSheet = workbook.addWorksheet('Results');
    this.populateResultsSheet(resultsSheet, analysisResults.basic);

    // ë¯¼ê°ë„ ë¶„ì„ ì‹œíŠ¸
    const sensitivitySheet = workbook.addWorksheet('Sensitivity');
    this.populateSensitivitySheet(sensitivitySheet, analysisResults.sensitivity);

    // ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œíŠ¸
    const monteCarloSheet = workbook.addWorksheet('Monte Carlo');
    this.populateMonteCarloSheet(monteCarloSheet, analysisResults.monteCarlo);

    // ì‹œë‚˜ë¦¬ì˜¤ ì‹œíŠ¸
    const scenarioSheet = workbook.addWorksheet('Scenarios');
    this.populateScenarioSheet(scenarioSheet, analysisResults.scenarios);

    // ì°¨íŠ¸ ì‹œíŠ¸
    const chartsSheet = workbook.addWorksheet('Charts');
    await this.addExcelCharts(chartsSheet, analysisResults);

    return workbook;
  }
}

interface AnalysisReport {
  metadata: ReportMetadata;
  executiveSummary: ExecutiveSummary;
  sections: ReportSection[];
  appendices?: ReportAppendix[];
}

interface ReportSection {
  id: string;
  title: string;
  content: ReportContent;
  visualizations: Visualization[];
  tables: DataTable[];
  insights: Insight[];
}

interface Visualization {
  type: string;
  title: string;
  data: any;
  options: VisualizationOptions;
}
```

---

## 7. êµ¬í˜„ ë¡œë“œë§µ

### Phase 1: ë¯¼ê°ë„ ë¶„ì„ (2ì¼)
- [ ] SingleCriterionSensitivity êµ¬í˜„
- [ ] MultiDimensionalAnalysis êµ¬í˜„
- [ ] GradientSensitivity êµ¬í˜„
- [ ] ì„ê³„ì  íƒì§€ ì•Œê³ ë¦¬ì¦˜

### Phase 2: ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ (3ì¼)
- [ ] RandomNumberGenerator êµ¬í˜„
- [ ] ë¶ˆí™•ì‹¤ì„± ëª¨ë¸ë§
- [ ] ì‹œë®¬ë ˆì´ì…˜ ì—”ì§„
- [ ] í†µê³„ ê³„ì‚° ëª¨ë“ˆ

### Phase 3: What-if ë¶„ì„ (2ì¼)
- [ ] ì‹œë‚˜ë¦¬ì˜¤ ì •ì˜ ë° ì‹¤í–‰
- [ ] ë³µí•© ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„
- [ ] ëª©í‘œ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜
- [ ] íŒŒë ˆí†  ìµœì í™”

### Phase 4: ë¡œë²„ìŠ¤íŠ¸ì„± (2ì¼)
- [ ] ìˆœìœ„ ì—­ì „ ë¶„ì„
- [ ] ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸
- [ ] IIA ê²€ì¦

### Phase 5: ë¦¬í¬íŠ¸ ìƒì„± (2ì¼)
- [ ] ì‹œê°í™” ì»´í¬ë„ŒíŠ¸
- [ ] PDF ìƒì„±
- [ ] Excel ë‚´ë³´ë‚´ê¸°
- [ ] ëŒ€ì‹œë³´ë“œ UI

---

## 8. ì„±ëŠ¥ ìµœì í™” ì „ëµ

### 8.1 ë³‘ë ¬ ì²˜ë¦¬
- Web Workersë¥¼ ì‚¬ìš©í•œ ì‹œë®¬ë ˆì´ì…˜ ë³‘ë ¬í™”
- GPU.jsë¥¼ í™œìš©í•œ í–‰ë ¬ ì—°ì‚° ê°€ì†
- ì²­í¬ ë‹¨ìœ„ ì²˜ë¦¬

### 8.2 ìºì‹± ì „ëµ
- ê³„ì‚° ê²°ê³¼ ë©”ëª¨ì´ì œì´ì…˜
- IndexedDBë¥¼ ì‚¬ìš©í•œ ë¡œì»¬ ìºì‹±
- Redis ê¸°ë°˜ ì„œë²„ ìºì‹±

### 8.3 ì ì§„ì  ë Œë”ë§
- ê°€ìƒ ìŠ¤í¬ë¡¤ë§
- ì§€ì—° ë¡œë”©
- ìŠ¤íŠ¸ë¦¬ë° ê²°ê³¼ í‘œì‹œ

---

**ì‘ì„± ì™„ë£Œ**: 2024-11-12 02:30 KST
**ë‹¤ìŒ ë‹¨ê³„**: ê²°ì œ ì‹œìŠ¤í…œ ì„¤ê³„