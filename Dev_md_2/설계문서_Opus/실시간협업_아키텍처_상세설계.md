# ğŸ”„ AHP ì‹¤ì‹œê°„ í˜‘ì—… ì‹œìŠ¤í…œ ìƒì„¸ ì„¤ê³„
**ì‘ì„±ì¼**: 2024-11-29  
**ì‘ì„±ì**: Claude Opus 4.1  
**ë²„ì „**: 1.0

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ëª©ì 
ë‹¤ìˆ˜ì˜ í‰ê°€ìê°€ ë™ì‹œì— AHP í‰ê°€ë¥¼ ìˆ˜í–‰í•˜ê³ , ì‹¤ì‹œê°„ìœ¼ë¡œ ì§„í–‰ ìƒí™©ì„ ê³µìœ í•˜ë©°, ì¶©ëŒ ì—†ì´ í˜‘ì—…í•  ìˆ˜ ìˆëŠ” ë¶„ì‚° ì‹œìŠ¤í…œ êµ¬ì¶•

### 1.2 í•µì‹¬ ìš”êµ¬ì‚¬í•­
- **ì‹¤ì‹œê°„ ë™ê¸°í™”**: ëª¨ë“  ë³€ê²½ì‚¬í•­ ì¦‰ì‹œ ë°˜ì˜ (<100ms ì§€ì—°)
- **ì¶©ëŒ í•´ê²°**: CRDT ì•Œê³ ë¦¬ì¦˜ ê¸°ë°˜ ìë™ ë³‘í•©
- **ì˜¤í”„ë¼ì¸ ì§€ì›**: ì—°ê²° ëŠê¹€ ì‹œì—ë„ ì‘ì—… ê°€ëŠ¥
- **í™•ì¥ì„±**: ìˆ˜ë°± ëª… ë™ì‹œ ì ‘ì† ì§€ì›
- **ì¼ê´€ì„± ë³´ì¥**: ìµœì¢… ì¼ê´€ì„±(Eventual Consistency) ë‹¬ì„±

---

## 2. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### 2.1 ì „ì²´ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Client Layer                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  React Components  â”‚  CRDT Engine  â”‚  WebSocket Client â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                      WebSocket/HTTP
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 API Gateway Layer                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Load Balancer   â”‚   Auth Service   â”‚   Rate Limiterâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              WebSocket Server Cluster                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Connection Manager â”‚  Session Store  â”‚  Event Router â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Message Queue                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Redis Pub/Sub  â”‚  RabbitMQ  â”‚  Kafka         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Data Layer                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   PostgreSQL   â”‚   Redis Cache   â”‚   S3 Storage      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 WebSocket ì„œë²„ ì„¤ê³„

```python
import asyncio
import json
import uuid
from typing import Dict, Set, Optional, List
from dataclasses import dataclass, asdict
from datetime import datetime
import websockets
from websockets.server import WebSocketServerProtocol
import redis.asyncio as redis
from enum import Enum

class MessageType(Enum):
    """ë©”ì‹œì§€ ìœ í˜• ì •ì˜"""
    JOIN_SESSION = "join_session"
    LEAVE_SESSION = "leave_session"
    STATE_UPDATE = "state_update"
    CURSOR_MOVE = "cursor_move"
    SELECTION_CHANGE = "selection_change"
    JUDGMENT_UPDATE = "judgment_update"
    SYNC_REQUEST = "sync_request"
    SYNC_RESPONSE = "sync_response"
    PRESENCE_UPDATE = "presence_update"
    CONFLICT_RESOLUTION = "conflict_resolution"
    HEARTBEAT = "heartbeat"

@dataclass
class CollaborationSession:
    """í˜‘ì—… ì„¸ì…˜ ë°ì´í„° í´ë˜ìŠ¤"""
    id: str
    project_id: str
    participants: Set[str]
    state: Dict
    created_at: datetime
    last_activity: datetime
    
class RealtimeCollaborationServer:
    """ì‹¤ì‹œê°„ í˜‘ì—… WebSocket ì„œë²„"""
    
    def __init__(
        self,
        host: str = "localhost",
        port: int = 8765,
        redis_url: str = "redis://localhost"
    ):
        self.host = host
        self.port = port
        self.connections: Dict[str, WebSocketServerProtocol] = {}
        self.sessions: Dict[str, CollaborationSession] = {}
        self.user_sessions: Dict[str, str] = {}  # user_id -> session_id
        self.redis_client = None
        self.pubsub = None
        
    async def start(self):
        """ì„œë²„ ì‹œì‘"""
        # Redis ì—°ê²°
        self.redis_client = await redis.from_url(self.redis_url)
        self.pubsub = self.redis_client.pubsub()
        
        # WebSocket ì„œë²„ ì‹œì‘
        async with websockets.serve(
            self.handle_connection,
            self.host,
            self.port,
            ping_interval=20,
            ping_timeout=10
        ):
            print(f"Collaboration server started on ws://{self.host}:{self.port}")
            
            # Redis êµ¬ë… ì‹œì‘
            await self.start_redis_listener()
            
            await asyncio.Future()  # ë¬´í•œ ëŒ€ê¸°
    
    async def handle_connection(
        self,
        websocket: WebSocketServerProtocol,
        path: str
    ):
        """ìƒˆ WebSocket ì—°ê²° ì²˜ë¦¬"""
        
        connection_id = str(uuid.uuid4())
        self.connections[connection_id] = websocket
        
        try:
            # ì¸ì¦ ì²˜ë¦¬
            auth_message = await asyncio.wait_for(
                websocket.recv(),
                timeout=5.0
            )
            
            auth_data = json.loads(auth_message)
            user_id = await self.authenticate_user(auth_data)
            
            if not user_id:
                await websocket.send(json.dumps({
                    "type": "error",
                    "message": "Authentication failed"
                }))
                return
            
            # ì—°ê²° ì„±ê³µ ì•Œë¦¼
            await websocket.send(json.dumps({
                "type": "connected",
                "connection_id": connection_id,
                "user_id": user_id
            }))
            
            # ë©”ì‹œì§€ ì²˜ë¦¬ ë£¨í”„
            async for message in websocket:
                await self.handle_message(
                    connection_id,
                    user_id,
                    json.loads(message)
                )
                
        except websockets.exceptions.ConnectionClosed:
            print(f"Connection {connection_id} closed")
            
        except asyncio.TimeoutError:
            print(f"Connection {connection_id} timed out")
            
        except Exception as e:
            print(f"Error handling connection {connection_id}: {e}")
            
        finally:
            await self.cleanup_connection(connection_id)
    
    async def handle_message(
        self,
        connection_id: str,
        user_id: str,
        message: Dict
    ):
        """ë©”ì‹œì§€ ì²˜ë¦¬ ë° ë¼ìš°íŒ…"""
        
        msg_type = MessageType(message.get("type"))
        
        if msg_type == MessageType.JOIN_SESSION:
            await self.handle_join_session(
                connection_id,
                user_id,
                message["session_id"]
            )
            
        elif msg_type == MessageType.LEAVE_SESSION:
            await self.handle_leave_session(user_id)
            
        elif msg_type == MessageType.STATE_UPDATE:
            await self.handle_state_update(
                user_id,
                message["operation"]
            )
            
        elif msg_type == MessageType.JUDGMENT_UPDATE:
            await self.handle_judgment_update(
                user_id,
                message["judgment_data"]
            )
            
        elif msg_type == MessageType.CURSOR_MOVE:
            await self.handle_cursor_move(
                user_id,
                message["position"]
            )
            
        elif msg_type == MessageType.SYNC_REQUEST:
            await self.handle_sync_request(connection_id, user_id)
            
        elif msg_type == MessageType.HEARTBEAT:
            await self.handle_heartbeat(connection_id)
    
    async def handle_join_session(
        self,
        connection_id: str,
        user_id: str,
        session_id: str
    ):
        """ì„¸ì…˜ ì°¸ê°€ ì²˜ë¦¬"""
        
        # ì„¸ì…˜ í™•ì¸ ë˜ëŠ” ìƒì„±
        if session_id not in self.sessions:
            session = await self.create_session(session_id)
            self.sessions[session_id] = session
        else:
            session = self.sessions[session_id]
        
        # ì°¸ê°€ì ì¶”ê°€
        session.participants.add(user_id)
        self.user_sessions[user_id] = session_id
        
        # Redis ì±„ë„ êµ¬ë…
        channel = f"session:{session_id}"
        await self.pubsub.subscribe(channel)
        
        # í˜„ì¬ ìƒíƒœ ì „ì†¡
        await self.send_to_user(connection_id, {
            "type": "session_joined",
            "session_id": session_id,
            "state": session.state,
            "participants": list(session.participants)
        })
        
        # ë‹¤ë¥¸ ì°¸ê°€ìë“¤ì—ê²Œ ì•Œë¦¼
        await self.broadcast_to_session(
            session_id,
            {
                "type": "participant_joined",
                "user_id": user_id,
                "timestamp": datetime.now().isoformat()
            },
            exclude_user=user_id
        )
    
    async def handle_state_update(
        self,
        user_id: str,
        operation: Dict
    ):
        """ìƒíƒœ ì—…ë°ì´íŠ¸ ì²˜ë¦¬"""
        
        session_id = self.user_sessions.get(user_id)
        if not session_id:
            return
        
        session = self.sessions[session_id]
        
        # CRDT ì—°ì‚° ì ìš©
        updated_state = await self.apply_crdt_operation(
            session.state,
            operation,
            user_id
        )
        
        session.state = updated_state
        session.last_activity = datetime.now()
        
        # Redisì— ìƒíƒœ ì €ì¥
        await self.save_session_state(session_id, updated_state)
        
        # ëª¨ë“  ì°¸ê°€ìì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
        await self.broadcast_to_session(
            session_id,
            {
                "type": "state_updated",
                "operation": operation,
                "user_id": user_id,
                "timestamp": datetime.now().isoformat()
            }
        )
    
    async def broadcast_to_session(
        self,
        session_id: str,
        message: Dict,
        exclude_user: Optional[str] = None
    ):
        """ì„¸ì…˜ ì°¸ê°€ìë“¤ì—ê²Œ ë¸Œë¡œë“œìºìŠ¤íŠ¸"""
        
        session = self.sessions.get(session_id)
        if not session:
            return
        
        # Redis Pub/Subìœ¼ë¡œ ë‹¤ë¥¸ ì„œë²„ ì¸ìŠ¤í„´ìŠ¤ì—ë„ ì „íŒŒ
        channel = f"session:{session_id}"
        await self.redis_client.publish(
            channel,
            json.dumps(message)
        )
        
        # í˜„ì¬ ì„œë²„ì˜ ì—°ê²°ëœ ì‚¬ìš©ìë“¤ì—ê²Œ ì „ì†¡
        for user_id in session.participants:
            if user_id != exclude_user:
                connection_id = self.get_user_connection(user_id)
                if connection_id:
                    await self.send_to_user(connection_id, message)
    
    async def apply_crdt_operation(
        self,
        current_state: Dict,
        operation: Dict,
        user_id: str
    ) -> Dict:
        """CRDT ì—°ì‚° ì ìš©"""
        
        # ì—°ì‚° íƒ€ì…ì— ë”°ë¥¸ ì²˜ë¦¬
        op_type = operation.get("type")
        
        if op_type == "lww_register":
            # Last-Writer-Wins Register
            return await self.apply_lww_register(
                current_state,
                operation,
                user_id
            )
            
        elif op_type == "g_counter":
            # Grow-only Counter
            return await self.apply_g_counter(
                current_state,
                operation,
                user_id
            )
            
        elif op_type == "or_set":
            # Observed-Remove Set
            return await self.apply_or_set(
                current_state,
                operation,
                user_id
            )
            
        elif op_type == "rga":
            # Replicated Growable Array
            return await self.apply_rga(
                current_state,
                operation,
                user_id
            )
        
        return current_state
```

---

## 3. CRDT ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„

### 3.1 CRDT ë°ì´í„° êµ¬ì¡°

```python
from typing import Any, Tuple, Set, List
import hashlib
import time

class CRDTEngine:
    """CRDT(Conflict-free Replicated Data Type) ì—”ì§„"""
    
    def __init__(self, replica_id: str):
        self.replica_id = replica_id
        self.vector_clock = VectorClock()
        self.operation_log = []
    
    def generate_operation_id(self) -> str:
        """ê³ ìœ  ì—°ì‚° ID ìƒì„±"""
        timestamp = str(time.time_ns())
        unique_string = f"{self.replica_id}:{timestamp}"
        return hashlib.sha256(unique_string.encode()).hexdigest()[:16]

class VectorClock:
    """ë²¡í„° ì‹œê³„ êµ¬í˜„"""
    
    def __init__(self):
        self.clock: Dict[str, int] = {}
    
    def increment(self, replica_id: str) -> Dict[str, int]:
        """ì‹œê³„ ì¦ê°€"""
        self.clock[replica_id] = self.clock.get(replica_id, 0) + 1
        return self.clock.copy()
    
    def update(self, other_clock: Dict[str, int]):
        """ë‹¤ë¥¸ ì‹œê³„ì™€ ë³‘í•©"""
        for replica_id, timestamp in other_clock.items():
            self.clock[replica_id] = max(
                self.clock.get(replica_id, 0),
                timestamp
            )
    
    def compare(self, other: 'VectorClock') -> str:
        """ì‹œê³„ ë¹„êµ"""
        less_than = False
        greater_than = False
        
        all_keys = set(self.clock.keys()) | set(other.clock.keys())
        
        for key in all_keys:
            self_val = self.clock.get(key, 0)
            other_val = other.clock.get(key, 0)
            
            if self_val < other_val:
                less_than = True
            elif self_val > other_val:
                greater_than = True
        
        if less_than and not greater_than:
            return "before"
        elif greater_than and not less_than:
            return "after"
        elif not less_than and not greater_than:
            return "equal"
        else:
            return "concurrent"

class LWWRegister:
    """Last-Writer-Wins Register CRDT"""
    
    def __init__(self, replica_id: str):
        self.replica_id = replica_id
        self.value: Any = None
        self.timestamp: float = 0
        self.writer_id: str = ""
    
    def set(self, value: Any) -> Dict:
        """ê°’ ì„¤ì •"""
        timestamp = time.time()
        
        operation = {
            "type": "lww_register_set",
            "value": value,
            "timestamp": timestamp,
            "replica_id": self.replica_id
        }
        
        self.apply_operation(operation)
        return operation
    
    def apply_operation(self, operation: Dict):
        """ì—°ì‚° ì ìš©"""
        op_timestamp = operation["timestamp"]
        op_replica = operation["replica_id"]
        
        # íƒ€ì„ìŠ¤íƒ¬í”„ ë¹„êµ (ê°™ìœ¼ë©´ replica_idë¡œ ê²°ì •)
        if op_timestamp > self.timestamp or \
           (op_timestamp == self.timestamp and op_replica > self.writer_id):
            self.value = operation["value"]
            self.timestamp = op_timestamp
            self.writer_id = op_replica
    
    def merge(self, other: 'LWWRegister'):
        """ë‹¤ë¥¸ ë ˆì§€ìŠ¤í„°ì™€ ë³‘í•©"""
        if other.timestamp > self.timestamp or \
           (other.timestamp == self.timestamp and other.writer_id > self.writer_id):
            self.value = other.value
            self.timestamp = other.timestamp
            self.writer_id = other.writer_id
    
    def get(self) -> Any:
        """í˜„ì¬ ê°’ ë°˜í™˜"""
        return self.value

class GCounter:
    """Grow-only Counter CRDT"""
    
    def __init__(self, replica_id: str):
        self.replica_id = replica_id
        self.counts: Dict[str, int] = {}
    
    def increment(self, amount: int = 1) -> Dict:
        """ì¹´ìš´í„° ì¦ê°€"""
        self.counts[self.replica_id] = self.counts.get(self.replica_id, 0) + amount
        
        return {
            "type": "g_counter_increment",
            "replica_id": self.replica_id,
            "amount": amount,
            "counts": self.counts.copy()
        }
    
    def merge(self, other_counts: Dict[str, int]):
        """ë‹¤ë¥¸ ì¹´ìš´í„°ì™€ ë³‘í•©"""
        for replica_id, count in other_counts.items():
            self.counts[replica_id] = max(
                self.counts.get(replica_id, 0),
                count
            )
    
    def value(self) -> int:
        """ì´í•© ë°˜í™˜"""
        return sum(self.counts.values())

class ORSet:
    """Observed-Remove Set CRDT"""
    
    def __init__(self, replica_id: str):
        self.replica_id = replica_id
        self.elements: Dict[Any, Set[str]] = {}  # element -> set of unique tags
        self.tombstones: Set[str] = set()  # removed tags
    
    def add(self, element: Any) -> Dict:
        """ì›ì†Œ ì¶”ê°€"""
        tag = f"{self.replica_id}:{time.time_ns()}"
        
        if element not in self.elements:
            self.elements[element] = set()
        
        self.elements[element].add(tag)
        
        return {
            "type": "or_set_add",
            "element": element,
            "tag": tag,
            "replica_id": self.replica_id
        }
    
    def remove(self, element: Any) -> Dict:
        """ì›ì†Œ ì œê±°"""
        if element in self.elements:
            tags = self.elements[element].copy()
            self.tombstones.update(tags)
            
            return {
                "type": "or_set_remove",
                "element": element,
                "tags": list(tags),
                "replica_id": self.replica_id
            }
        
        return {
            "type": "or_set_remove",
            "element": element,
            "tags": [],
            "replica_id": self.replica_id
        }
    
    def apply_operation(self, operation: Dict):
        """ì—°ì‚° ì ìš©"""
        op_type = operation["type"]
        
        if op_type == "or_set_add":
            element = operation["element"]
            tag = operation["tag"]
            
            if element not in self.elements:
                self.elements[element] = set()
            
            if tag not in self.tombstones:
                self.elements[element].add(tag)
                
        elif op_type == "or_set_remove":
            tags = operation["tags"]
            self.tombstones.update(tags)
    
    def merge(self, other: 'ORSet'):
        """ë‹¤ë¥¸ ì§‘í•©ê³¼ ë³‘í•©"""
        # ëª¨ë“  ì›ì†Œì™€ íƒœê·¸ ë³‘í•©
        for element, tags in other.elements.items():
            if element not in self.elements:
                self.elements[element] = set()
            self.elements[element].update(tags)
        
        # í†°ìŠ¤í†¤ ë³‘í•©
        self.tombstones.update(other.tombstones)
        
        # í†°ìŠ¤í†¤ì— ìˆëŠ” íƒœê·¸ ì œê±°
        for element in list(self.elements.keys()):
            self.elements[element] -= self.tombstones
            if not self.elements[element]:
                del self.elements[element]
    
    def get_elements(self) -> Set[Any]:
        """í˜„ì¬ ì›ì†Œë“¤ ë°˜í™˜"""
        result = set()
        for element, tags in self.elements.items():
            active_tags = tags - self.tombstones
            if active_tags:
                result.add(element)
        return result

class RGA:
    """Replicated Growable Array CRDT"""
    
    def __init__(self, replica_id: str):
        self.replica_id = replica_id
        self.sequence: List[RGANode] = []
        self.tombstones: Set[str] = set()
    
    class RGANode:
        """RGA ë…¸ë“œ"""
        def __init__(self, value: Any, timestamp: Tuple[int, str], prev_timestamp: Optional[Tuple]):
            self.value = value
            self.timestamp = timestamp  # (logical_time, replica_id)
            self.prev_timestamp = prev_timestamp
            self.next_timestamps: List[Tuple] = []
    
    def insert(self, index: int, value: Any) -> Dict:
        """íŠ¹ì • ìœ„ì¹˜ì— ì‚½ì…"""
        logical_time = int(time.time_ns())
        timestamp = (logical_time, self.replica_id)
        
        prev_timestamp = None
        if index > 0 and index <= len(self.sequence):
            prev_timestamp = self.sequence[index - 1].timestamp
        
        node = self.RGANode(value, timestamp, prev_timestamp)
        
        # ì˜¬ë°”ë¥¸ ìœ„ì¹˜ ì°¾ê¸°
        insert_pos = self._find_insert_position(node)
        self.sequence.insert(insert_pos, node)
        
        return {
            "type": "rga_insert",
            "value": value,
            "timestamp": timestamp,
            "prev_timestamp": prev_timestamp,
            "replica_id": self.replica_id
        }
    
    def delete(self, index: int) -> Dict:
        """íŠ¹ì • ìœ„ì¹˜ ì‚­ì œ"""
        if 0 <= index < len(self.sequence):
            node = self.sequence[index]
            self.tombstones.add(node.timestamp)
            
            return {
                "type": "rga_delete",
                "timestamp": node.timestamp,
                "replica_id": self.replica_id
            }
        
        return {
            "type": "rga_delete",
            "timestamp": None,
            "replica_id": self.replica_id
        }
    
    def _find_insert_position(self, new_node: RGANode) -> int:
        """ì‚½ì… ìœ„ì¹˜ ì°¾ê¸°"""
        # íƒ€ì„ìŠ¤íƒ¬í”„ ìˆœì„œë¡œ ì •ë ¬ëœ ìœ„ì¹˜ ì°¾ê¸°
        for i, node in enumerate(self.sequence):
            if self._compare_timestamps(new_node.timestamp, node.timestamp) < 0:
                return i
        return len(self.sequence)
    
    def _compare_timestamps(self, t1: Tuple, t2: Tuple) -> int:
        """íƒ€ì„ìŠ¤íƒ¬í”„ ë¹„êµ"""
        if t1[0] < t2[0]:
            return -1
        elif t1[0] > t2[0]:
            return 1
        else:
            # ë…¼ë¦¬ì  ì‹œê°„ì´ ê°™ìœ¼ë©´ replica_idë¡œ ë¹„êµ
            if t1[1] < t2[1]:
                return -1
            elif t1[1] > t2[1]:
                return 1
            else:
                return 0
    
    def get_array(self) -> List[Any]:
        """í˜„ì¬ ë°°ì—´ ë°˜í™˜ (í†°ìŠ¤í†¤ ì œì™¸)"""
        result = []
        for node in self.sequence:
            if node.timestamp not in self.tombstones:
                result.append(node.value)
        return result
```

### 3.2 AHP íŠ¹í™” CRDT

```python
class AHPJudgmentCRDT:
    """AHP íŒë‹¨ í–‰ë ¬ì„ ìœ„í•œ íŠ¹í™” CRDT"""
    
    def __init__(self, replica_id: str, matrix_size: int):
        self.replica_id = replica_id
        self.matrix_size = matrix_size
        self.judgments: Dict[Tuple[int, int], LWWRegister] = {}
        
        # íŒë‹¨ í–‰ë ¬ ì´ˆê¸°í™”
        for i in range(matrix_size):
            for j in range(matrix_size):
                if i != j:
                    self.judgments[(i, j)] = LWWRegister(replica_id)
    
    def update_judgment(
        self,
        row: int,
        col: int,
        value: float
    ) -> Dict:
        """íŒë‹¨ê°’ ì—…ë°ì´íŠ¸"""
        
        if row == col:
            return {"error": "Cannot update diagonal elements"}
        
        # ìƒì‚¼ê° í–‰ë ¬ë§Œ ì—…ë°ì´íŠ¸
        if row > col:
            row, col = col, row
            value = 1 / value
        
        # LWW Registerë¡œ ê°’ ì„¤ì •
        operation = self.judgments[(row, col)].set(value)
        
        # ì—­ìˆ˜ ìë™ ì—…ë°ì´íŠ¸
        self.judgments[(col, row)].set(1 / value)
        
        return {
            "type": "judgment_update",
            "row": row,
            "col": col,
            "value": value,
            "operation": operation,
            "replica_id": self.replica_id
        }
    
    def get_matrix(self) -> np.ndarray:
        """í˜„ì¬ íŒë‹¨ í–‰ë ¬ ë°˜í™˜"""
        matrix = np.eye(self.matrix_size)
        
        for i in range(self.matrix_size):
            for j in range(self.matrix_size):
                if i < j:
                    value = self.judgments[(i, j)].get()
                    if value is not None:
                        matrix[i, j] = value
                        matrix[j, i] = 1 / value
        
        return matrix
    
    def merge(self, other: 'AHPJudgmentCRDT'):
        """ë‹¤ë¥¸ íŒë‹¨ í–‰ë ¬ê³¼ ë³‘í•©"""
        for key in self.judgments:
            self.judgments[key].merge(other.judgments[key])
    
    def calculate_consistency_ratio(self) -> float:
        """ì¼ê´€ì„± ë¹„ìœ¨ ê³„ì‚°"""
        matrix = self.get_matrix()
        
        # ê³ ìœ ê°’ ê³„ì‚°
        eigenvalues = np.linalg.eigvals(matrix)
        lambda_max = max(eigenvalues.real)
        
        # ì¼ê´€ì„± ì§€ìˆ˜
        n = self.matrix_size
        ci = (lambda_max - n) / (n - 1)
        
        # ë¬´ì‘ìœ„ ì¼ê´€ì„± ì§€ìˆ˜
        ri_values = {
            3: 0.58, 4: 0.90, 5: 1.12, 6: 1.24,
            7: 1.32, 8: 1.41, 9: 1.45, 10: 1.49
        }
        ri = ri_values.get(n, 1.49)
        
        # ì¼ê´€ì„± ë¹„ìœ¨
        cr = ci / ri if ri > 0 else 0
        
        return cr

class CollaborativeCriteriaTree:
    """í˜‘ì—… ê¸°ì¤€ íŠ¸ë¦¬ CRDT"""
    
    def __init__(self, replica_id: str):
        self.replica_id = replica_id
        self.nodes: ORSet = ORSet(replica_id)
        self.edges: ORSet = ORSet(replica_id)
        self.node_data: Dict[str, LWWRegister] = {}
    
    def add_node(
        self,
        node_id: str,
        parent_id: Optional[str],
        data: Dict
    ) -> Dict:
        """ë…¸ë“œ ì¶”ê°€"""
        
        # ë…¸ë“œ ì¶”ê°€
        node_op = self.nodes.add(node_id)
        
        # ë…¸ë“œ ë°ì´í„° ì„¤ì •
        if node_id not in self.node_data:
            self.node_data[node_id] = LWWRegister(self.replica_id)
        
        data_op = self.node_data[node_id].set(data)
        
        # ì—£ì§€ ì¶”ê°€
        edge_op = None
        if parent_id:
            edge = (parent_id, node_id)
            edge_op = self.edges.add(edge)
        
        return {
            "type": "tree_add_node",
            "node_id": node_id,
            "parent_id": parent_id,
            "data": data,
            "node_operation": node_op,
            "data_operation": data_op,
            "edge_operation": edge_op,
            "replica_id": self.replica_id
        }
    
    def remove_node(self, node_id: str) -> Dict:
        """ë…¸ë“œ ì œê±°"""
        
        # ë…¸ë“œ ì œê±°
        node_op = self.nodes.remove(node_id)
        
        # ê´€ë ¨ ì—£ì§€ ì œê±°
        edge_ops = []
        for edge in self.edges.get_elements():
            if edge[0] == node_id or edge[1] == node_id:
                edge_ops.append(self.edges.remove(edge))
        
        return {
            "type": "tree_remove_node",
            "node_id": node_id,
            "node_operation": node_op,
            "edge_operations": edge_ops,
            "replica_id": self.replica_id
        }
    
    def move_node(
        self,
        node_id: str,
        new_parent_id: str
    ) -> Dict:
        """ë…¸ë“œ ì´ë™"""
        
        # ê¸°ì¡´ ë¶€ëª¨ ì—£ì§€ ì œê±°
        old_edges_removed = []
        for edge in self.edges.get_elements():
            if edge[1] == node_id:
                old_edges_removed.append(self.edges.remove(edge))
        
        # ìƒˆ ë¶€ëª¨ ì—£ì§€ ì¶”ê°€
        new_edge = (new_parent_id, node_id)
        new_edge_op = self.edges.add(new_edge)
        
        return {
            "type": "tree_move_node",
            "node_id": node_id,
            "new_parent_id": new_parent_id,
            "old_edges_removed": old_edges_removed,
            "new_edge_added": new_edge_op,
            "replica_id": self.replica_id
        }
    
    def get_tree(self) -> Dict:
        """í˜„ì¬ íŠ¸ë¦¬ êµ¬ì¡° ë°˜í™˜"""
        
        nodes = list(self.nodes.get_elements())
        edges = list(self.edges.get_elements())
        
        # íŠ¸ë¦¬ êµ¬ì¡° ìƒì„±
        tree = {
            "nodes": {},
            "edges": edges,
            "root": None
        }
        
        # ë…¸ë“œ ë°ì´í„° ìˆ˜ì§‘
        for node_id in nodes:
            if node_id in self.node_data:
                tree["nodes"][node_id] = self.node_data[node_id].get()
        
        # ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°
        child_nodes = set(edge[1] for edge in edges)
        root_candidates = set(nodes) - child_nodes
        
        if root_candidates:
            tree["root"] = list(root_candidates)[0]
        
        return tree
```

---

## 4. ë™ê¸°í™” ë° ì¶©ëŒ í•´ê²°

### 4.1 ë™ê¸°í™” í”„ë¡œí† ì½œ

```python
class SyncProtocol:
    """ë™ê¸°í™” í”„ë¡œí† ì½œ êµ¬í˜„"""
    
    def __init__(self, replica_id: str):
        self.replica_id = replica_id
        self.version_vector = {}
        self.operation_buffer = []
        self.sync_in_progress = False
    
    async def initiate_sync(
        self,
        remote_replica: str,
        websocket: WebSocketServerProtocol
    ):
        """ë™ê¸°í™” ì‹œì‘"""
        
        if self.sync_in_progress:
            return
        
        self.sync_in_progress = True
        
        try:
            # 1. ë²„ì „ ë²¡í„° êµí™˜
            await self.exchange_version_vectors(remote_replica, websocket)
            
            # 2. ë¸íƒ€ ê³„ì‚°
            delta_operations = await self.calculate_delta(remote_replica)
            
            # 3. ë¸íƒ€ ì „ì†¡
            await self.send_delta(remote_replica, delta_operations, websocket)
            
            # 4. ë¸íƒ€ ìˆ˜ì‹  ë° ì ìš©
            received_delta = await self.receive_delta(websocket)
            await self.apply_delta(received_delta)
            
            # 5. ë²„ì „ ë²¡í„° ì—…ë°ì´íŠ¸
            self.update_version_vector(remote_replica)
            
        finally:
            self.sync_in_progress = False
    
    async def handle_concurrent_updates(
        self,
        local_op: Dict,
        remote_op: Dict
    ) -> List[Dict]:
        """ë™ì‹œ ì—…ë°ì´íŠ¸ ì²˜ë¦¬"""
        
        # íƒ€ì„ìŠ¤íƒ¬í”„ ë¹„êµ
        local_ts = local_op.get("timestamp", 0)
        remote_ts = remote_op.get("timestamp", 0)
        
        if local_ts == remote_ts:
            # íƒ€ì„ìŠ¤íƒ¬í”„ê°€ ê°™ìœ¼ë©´ replica_idë¡œ ìˆœì„œ ê²°ì •
            if self.replica_id < remote_op.get("replica_id", ""):
                return [local_op, remote_op]
            else:
                return [remote_op, local_op]
        elif local_ts < remote_ts:
            return [local_op, remote_op]
        else:
            return [remote_op, local_op]
    
    async def resolve_conflicts(
        self,
        conflicts: List[Dict]
    ) -> Dict:
        """ì¶©ëŒ í•´ê²°"""
        
        resolution_strategy = conflicts[0].get("resolution_strategy", "lww")
        
        if resolution_strategy == "lww":
            # Last-Writer-Wins
            return max(conflicts, key=lambda x: x.get("timestamp", 0))
            
        elif resolution_strategy == "mws":
            # Multi-Value with Semantic resolution
            return await self.semantic_resolution(conflicts)
            
        elif resolution_strategy == "custom":
            # ì‚¬ìš©ì ì •ì˜ í•´ê²°
            return await self.custom_resolution(conflicts)
        
        return conflicts[0]
    
    async def semantic_resolution(
        self,
        conflicts: List[Dict]
    ) -> Dict:
        """ì˜ë¯¸ë¡ ì  ì¶©ëŒ í•´ê²°"""
        
        # AHP íŒë‹¨ê°’ ì¶©ëŒì˜ ê²½ìš°
        if conflicts[0].get("type") == "judgment_update":
            # ê¸°í•˜í‰ê·  ì‚¬ìš©
            values = [c.get("value", 1) for c in conflicts]
            geometric_mean = np.prod(values) ** (1 / len(values))
            
            resolved = conflicts[0].copy()
            resolved["value"] = geometric_mean
            resolved["resolution_method"] = "geometric_mean"
            
            return resolved
        
        # ê¸°ì¤€ íŠ¸ë¦¬ ì¶©ëŒì˜ ê²½ìš°
        elif conflicts[0].get("type") == "tree_operation":
            # ê°€ì¥ ë§ì€ ë™ì˜ë¥¼ ë°›ì€ ë³€ê²½ ì„ íƒ
            votes = {}
            for conflict in conflicts:
                key = json.dumps(conflict.get("change", {}), sort_keys=True)
                votes[key] = votes.get(key, 0) + 1
            
            winner_key = max(votes, key=votes.get)
            for conflict in conflicts:
                if json.dumps(conflict.get("change", {}), sort_keys=True) == winner_key:
                    return conflict
        
        return conflicts[0]
```

### 4.2 ì˜¤í”„ë¼ì¸ ì§€ì›

```python
class OfflineManager:
    """ì˜¤í”„ë¼ì¸ ëª¨ë“œ ê´€ë¦¬"""
    
    def __init__(self, local_storage):
        self.local_storage = local_storage
        self.offline_queue = []
        self.is_online = True
        self.last_sync_timestamp = None
    
    async def handle_offline_operation(
        self,
        operation: Dict
    ):
        """ì˜¤í”„ë¼ì¸ ì—°ì‚° ì²˜ë¦¬"""
        
        # ë¡œì»¬ ìƒíƒœì— ì¦‰ì‹œ ì ìš©
        await self.apply_local(operation)
        
        # íì— ì¶”ê°€
        self.offline_queue.append({
            "operation": operation,
            "timestamp": time.time(),
            "status": "pending"
        })
        
        # ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
        await self.save_to_local_storage()
    
    async def sync_when_online(self):
        """ì˜¨ë¼ì¸ ë³µê·€ ì‹œ ë™ê¸°í™”"""
        
        if not self.is_online or not self.offline_queue:
            return
        
        synced_operations = []
        failed_operations = []
        
        for queued_item in self.offline_queue:
            try:
                # ì„œë²„ë¡œ ì „ì†¡
                result = await self.send_to_server(queued_item["operation"])
                
                if result.get("success"):
                    synced_operations.append(queued_item)
                    queued_item["status"] = "synced"
                else:
                    # ì¶©ëŒ ë°œìƒ
                    resolution = await self.resolve_sync_conflict(
                        queued_item["operation"],
                        result.get("conflict_data")
                    )
                    
                    if resolution:
                        synced_operations.append(queued_item)
                        queued_item["status"] = "resolved"
                    else:
                        failed_operations.append(queued_item)
                        queued_item["status"] = "failed"
                        
            except Exception as e:
                print(f"Sync error: {e}")
                failed_operations.append(queued_item)
                queued_item["status"] = "error"
        
        # ì„±ê³µí•œ ì—°ì‚° ì œê±°
        self.offline_queue = failed_operations
        
        # ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì—…ë°ì´íŠ¸
        await self.save_to_local_storage()
        
        self.last_sync_timestamp = time.time()
        
        return {
            "synced": len(synced_operations),
            "failed": len(failed_operations),
            "remaining": len(self.offline_queue)
        }
    
    async def resolve_sync_conflict(
        self,
        local_operation: Dict,
        server_state: Dict
    ) -> Optional[Dict]:
        """ë™ê¸°í™” ì¶©ëŒ í•´ê²°"""
        
        # 3-way merge ì‹œë„
        base_state = await self.get_last_known_state()
        
        if base_state:
            merged = await self.three_way_merge(
                base_state,
                local_operation,
                server_state
            )
            
            if merged:
                return merged
        
        # ìë™ í•´ê²° ì‹¤íŒ¨ ì‹œ ì‚¬ìš©ìì—ê²Œ ì„ íƒ ìš”ì²­
        return await self.request_user_resolution(
            local_operation,
            server_state
        )
```

---

## 5. ì„±ëŠ¥ ìµœì í™”

### 5.1 ë©”ì‹œì§€ ì••ì¶• ë° ë°°ì¹­

```python
import zlib
import msgpack

class MessageOptimizer:
    """ë©”ì‹œì§€ ìµœì í™”"""
    
    def __init__(self):
        self.batch_size = 50
        self.batch_timeout = 100  # ms
        self.message_buffer = []
        self.compression_threshold = 1024  # bytes
    
    def compress_message(self, message: Dict) -> bytes:
        """ë©”ì‹œì§€ ì••ì¶•"""
        
        # MessagePackìœ¼ë¡œ ì§ë ¬í™”
        packed = msgpack.packb(message)
        
        # í¬ê¸°ê°€ ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ë©´ ì••ì¶•
        if len(packed) > self.compression_threshold:
            compressed = zlib.compress(packed, level=6)
            
            # ì••ì¶•ì´ íš¨ê³¼ì ì¸ ê²½ìš°ë§Œ ì‚¬ìš©
            if len(compressed) < len(packed) * 0.9:
                return b'Z' + compressed  # 'Z' prefix for compressed
        
        return b'U' + packed  # 'U' prefix for uncompressed
    
    def decompress_message(self, data: bytes) -> Dict:
        """ë©”ì‹œì§€ ì••ì¶• í•´ì œ"""
        
        if data[0] == ord('Z'):
            decompressed = zlib.decompress(data[1:])
            return msgpack.unpackb(decompressed)
        else:
            return msgpack.unpackb(data[1:])
    
    async def batch_messages(
        self,
        message: Dict
    ) -> Optional[List[Dict]]:
        """ë©”ì‹œì§€ ë°°ì¹­"""
        
        self.message_buffer.append(message)
        
        # ë°°ì¹˜ í¬ê¸° ë„ë‹¬ ë˜ëŠ” íƒ€ì„ì•„ì›ƒ
        if len(self.message_buffer) >= self.batch_size:
            batch = self.message_buffer.copy()
            self.message_buffer.clear()
            return batch
        
        # íƒ€ì´ë¨¸ ì„¤ì • (ì²« ë©”ì‹œì§€ ë„ì°© ì‹œ)
        if len(self.message_buffer) == 1:
            asyncio.create_task(self._batch_timeout())
        
        return None
    
    async def _batch_timeout(self):
        """ë°°ì¹˜ íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬"""
        await asyncio.sleep(self.batch_timeout / 1000)
        
        if self.message_buffer:
            batch = self.message_buffer.copy()
            self.message_buffer.clear()
            await self.send_batch(batch)
```

### 5.2 ìºì‹± ì „ëµ

```python
from functools import lru_cache
import hashlib

class CollaborationCache:
    """í˜‘ì—… ë°ì´í„° ìºì‹±"""
    
    def __init__(self, max_size: int = 1000):
        self.max_size = max_size
        self.operation_cache = {}
        self.state_cache = {}
        self.conflict_resolution_cache = {}
    
    def cache_key(self, *args) -> str:
        """ìºì‹œ í‚¤ ìƒì„±"""
        key_str = json.dumps(args, sort_keys=True)
        return hashlib.md5(key_str.encode()).hexdigest()
    
    @lru_cache(maxsize=128)
    def get_cached_state(
        self,
        session_id: str,
        version: int
    ) -> Optional[Dict]:
        """ìºì‹œëœ ìƒíƒœ ì¡°íšŒ"""
        key = self.cache_key(session_id, version)
        return self.state_cache.get(key)
    
    def cache_state(
        self,
        session_id: str,
        version: int,
        state: Dict
    ):
        """ìƒíƒœ ìºì‹±"""
        key = self.cache_key(session_id, version)
        self.state_cache[key] = state
        
        # LRU ì •ì±…
        if len(self.state_cache) > self.max_size:
            # ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì œê±°
            oldest = min(self.state_cache.keys())
            del self.state_cache[oldest]
    
    def cache_conflict_resolution(
        self,
        conflict_hash: str,
        resolution: Dict
    ):
        """ì¶©ëŒ í•´ê²° ê²°ê³¼ ìºì‹±"""
        self.conflict_resolution_cache[conflict_hash] = resolution
    
    def get_cached_resolution(
        self,
        conflict_data: List[Dict]
    ) -> Optional[Dict]:
        """ìºì‹œëœ ì¶©ëŒ í•´ê²° ì¡°íšŒ"""
        conflict_hash = self.cache_key(conflict_data)
        return self.conflict_resolution_cache.get(conflict_hash)
```

---

## 6. ëª¨ë‹ˆí„°ë§ ë° ë©”íŠ¸ë¦­

### 6.1 ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§

```python
import prometheus_client as prom
from dataclasses import dataclass
from typing import Deque
from collections import deque

@dataclass
class CollaborationMetrics:
    """í˜‘ì—… ë©”íŠ¸ë¦­"""
    active_sessions: int = 0
    active_connections: int = 0
    messages_per_second: float = 0
    average_latency: float = 0
    conflict_rate: float = 0
    sync_success_rate: float = 0

class CollaborationMonitor:
    """ì‹¤ì‹œê°„ í˜‘ì—… ëª¨ë‹ˆí„°ë§"""
    
    def __init__(self):
        # Prometheus ë©”íŠ¸ë¦­
        self.active_sessions_gauge = prom.Gauge(
            'collaboration_active_sessions',
            'Number of active collaboration sessions'
        )
        self.active_connections_gauge = prom.Gauge(
            'collaboration_active_connections',
            'Number of active WebSocket connections'
        )
        self.message_rate = prom.Counter(
            'collaboration_messages_total',
            'Total messages processed',
            ['message_type']
        )
        self.latency_histogram = prom.Histogram(
            'collaboration_latency_seconds',
            'Message processing latency'
        )
        self.conflict_counter = prom.Counter(
            'collaboration_conflicts_total',
            'Total conflicts detected'
        )
        
        # ë‚´ë¶€ ë©”íŠ¸ë¦­
        self.message_timestamps: Deque[float] = deque(maxlen=1000)
        self.latency_measurements: Deque[float] = deque(maxlen=1000)
    
    def record_message(
        self,
        message_type: str,
        processing_time: float
    ):
        """ë©”ì‹œì§€ ê¸°ë¡"""
        self.message_rate.labels(message_type=message_type).inc()
        self.latency_histogram.observe(processing_time)
        
        self.message_timestamps.append(time.time())
        self.latency_measurements.append(processing_time)
    
    def record_conflict(self):
        """ì¶©ëŒ ê¸°ë¡"""
        self.conflict_counter.inc()
    
    def get_metrics(self) -> CollaborationMetrics:
        """í˜„ì¬ ë©”íŠ¸ë¦­ ì¡°íšŒ"""
        
        # ë©”ì‹œì§€ ì²˜ë¦¬ìœ¨ ê³„ì‚°
        if len(self.message_timestamps) >= 2:
            time_span = self.message_timestamps[-1] - self.message_timestamps[0]
            messages_per_second = len(self.message_timestamps) / time_span if time_span > 0 else 0
        else:
            messages_per_second = 0
        
        # í‰ê·  ì§€ì—°ì‹œê°„
        avg_latency = np.mean(self.latency_measurements) if self.latency_measurements else 0
        
        return CollaborationMetrics(
            active_sessions=self.active_sessions_gauge._value.get(),
            active_connections=self.active_connections_gauge._value.get(),
            messages_per_second=messages_per_second,
            average_latency=avg_latency,
            conflict_rate=self._calculate_conflict_rate(),
            sync_success_rate=self._calculate_sync_success_rate()
        )
    
    def _calculate_conflict_rate(self) -> float:
        """ì¶©ëŒë¥  ê³„ì‚°"""
        # ìµœê·¼ 1000ê°œ ë©”ì‹œì§€ ì¤‘ ì¶©ëŒ ë¹„ìœ¨
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë” ì •êµí•œ ê³„ì‚° í•„ìš”
        return 0.02  # ì˜ˆì‹œ: 2%
    
    def _calculate_sync_success_rate(self) -> float:
        """ë™ê¸°í™” ì„±ê³µë¥  ê³„ì‚°"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë™ê¸°í™” ì‹œë„/ì„±ê³µ ì¶”ì  í•„ìš”
        return 0.98  # ì˜ˆì‹œ: 98%
```

---

## 7. ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 7.1 WebSocket ë³´ì•ˆ

```python
import jwt
import ssl

class SecureWebSocketServer:
    """ë³´ì•ˆ WebSocket ì„œë²„"""
    
    def __init__(self):
        self.ssl_context = self._create_ssl_context()
        self.rate_limiter = RateLimiter()
    
    def _create_ssl_context(self) -> ssl.SSLContext:
        """SSL ì»¨í…ìŠ¤íŠ¸ ìƒì„±"""
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        context.load_cert_chain(
            certfile="path/to/cert.pem",
            keyfile="path/to/key.pem"
        )
        return context
    
    async def authenticate_connection(
        self,
        token: str
    ) -> Optional[str]:
        """WebSocket ì—°ê²° ì¸ì¦"""
        try:
            payload = jwt.decode(
                token,
                self.jwt_secret,
                algorithms=['HS256']
            )
            
            user_id = payload.get('user_id')
            
            # ê¶Œí•œ í™•ì¸
            if not await self.check_permissions(user_id):
                return None
            
            return user_id
            
        except jwt.InvalidTokenError:
            return None
    
    async def check_permissions(
        self,
        user_id: str
    ) -> bool:
        """ì‚¬ìš©ì ê¶Œí•œ í™•ì¸"""
        # ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ê¶Œí•œ ì¡°íšŒ
        # ì‹¤ì œ êµ¬í˜„ í•„ìš”
        return True

class RateLimiter:
    """Rate Limiting"""
    
    def __init__(self):
        self.limits = {
            'messages_per_second': 10,
            'connections_per_ip': 5,
            'operations_per_minute': 100
        }
        self.counters = {}
    
    async def check_limit(
        self,
        identifier: str,
        limit_type: str
    ) -> bool:
        """ì œí•œ í™•ì¸"""
        key = f"{identifier}:{limit_type}"
        current_count = self.counters.get(key, 0)
        
        if current_count >= self.limits.get(limit_type, float('inf')):
            return False
        
        self.counters[key] = current_count + 1
        
        # ì‹œê°„ ê¸°ë°˜ ë¦¬ì…‹ (ì‹¤ì œ êµ¬í˜„ í•„ìš”)
        asyncio.create_task(self._reset_counter(key))
        
        return True
```

---

## 8. í…ŒìŠ¤íŠ¸ ì „ëµ

### 8.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```python
import pytest
import asyncio

class TestCRDT:
    """CRDT í…ŒìŠ¤íŠ¸"""
    
    @pytest.mark.asyncio
    async def test_lww_register(self):
        """LWW Register í…ŒìŠ¤íŠ¸"""
        reg1 = LWWRegister("replica1")
        reg2 = LWWRegister("replica2")
        
        # ë™ì‹œ ì—…ë°ì´íŠ¸
        reg1.set("value1")
        await asyncio.sleep(0.001)
        reg2.set("value2")
        
        # ë³‘í•©
        reg1.merge(reg2)
        reg2.merge(reg1)
        
        # ê°™ì€ ê°’ì„ ê°€ì ¸ì•¼ í•¨
        assert reg1.get() == reg2.get()
        assert reg1.get() == "value2"  # ë‚˜ì¤‘ ê°’
    
    @pytest.mark.asyncio
    async def test_or_set(self):
        """OR-Set í…ŒìŠ¤íŠ¸"""
        set1 = ORSet("replica1")
        set2 = ORSet("replica2")
        
        # ë™ì‹œ ì¶”ê°€/ì œê±°
        set1.add("item1")
        set2.add("item2")
        set1.remove("item2")  # ì•„ì§ ëª¨ë¦„
        
        # ë³‘í•©
        set1.merge(set2)
        set2.merge(set1)
        
        # ê²°ê³¼ í™•ì¸
        assert "item1" in set1.get_elements()
        assert "item2" in set2.get_elements()
    
    @pytest.mark.asyncio
    async def test_judgment_crdt(self):
        """AHP íŒë‹¨ CRDT í…ŒìŠ¤íŠ¸"""
        judge1 = AHPJudgmentCRDT("evaluator1", 3)
        judge2 = AHPJudgmentCRDT("evaluator2", 3)
        
        # ì„œë¡œ ë‹¤ë¥¸ íŒë‹¨
        judge1.update_judgment(0, 1, 3.0)
        judge2.update_judgment(0, 1, 5.0)
        
        # ë³‘í•©
        judge1.merge(judge2)
        
        # ë‚˜ì¤‘ ê°’ì´ ìš°ì„ 
        matrix = judge1.get_matrix()
        assert matrix[0, 1] == 5.0
        assert matrix[1, 0] == 0.2

class TestWebSocketSync:
    """WebSocket ë™ê¸°í™” í…ŒìŠ¤íŠ¸"""
    
    @pytest.mark.asyncio
    async def test_connection_handling(self):
        """ì—°ê²° ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        server = RealtimeCollaborationServer()
        
        # ëª¨ì˜ WebSocket ì—°ê²°
        mock_ws = MockWebSocket()
        
        # ì—°ê²° ì²˜ë¦¬
        await server.handle_connection(mock_ws, "/")
        
        # ì¸ì¦ í™•ì¸
        assert mock_ws.messages_sent[0]["type"] == "connected"
    
    @pytest.mark.asyncio
    async def test_message_broadcast(self):
        """ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸ í…ŒìŠ¤íŠ¸"""
        server = RealtimeCollaborationServer()
        
        # ì„¸ì…˜ ìƒì„±
        session_id = "test_session"
        server.sessions[session_id] = CollaborationSession(
            id=session_id,
            project_id="project1",
            participants={"user1", "user2"},
            state={},
            created_at=datetime.now(),
            last_activity=datetime.now()
        )
        
        # ë¸Œë¡œë“œìºìŠ¤íŠ¸
        await server.broadcast_to_session(
            session_id,
            {"type": "test_message"}
        )
        
        # Redis ê²Œì‹œ í™•ì¸
        # ì‹¤ì œ í…ŒìŠ¤íŠ¸ êµ¬í˜„ í•„ìš”
```

---

## 9. ë°°í¬ ë° í™•ì¥ì„±

### 9.1 Docker ì»¨í…Œì´ë„ˆí™”

```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

# ì˜ì¡´ì„± ì„¤ì¹˜
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# ì• í”Œë¦¬ì¼€ì´ì…˜ ë³µì‚¬
COPY . .

# WebSocket ì„œë²„ ì‹¤í–‰
CMD ["python", "-m", "collaboration_server", "--host", "0.0.0.0", "--port", "8765"]
```

### 9.2 Kubernetes ë°°í¬

```yaml
# kubernetes-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: collaboration-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: collaboration-server
  template:
    metadata:
      labels:
        app: collaboration-server
    spec:
      containers:
      - name: websocket-server
        image: ahp-collaboration:latest
        ports:
        - containerPort: 8765
        env:
        - name: REDIS_URL
          value: "redis://redis-service:6379"
        - name: DB_URL
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: url
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8765
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8765
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: collaboration-service
spec:
  selector:
    app: collaboration-server
  ports:
  - protocol: TCP
    port: 8765
    targetPort: 8765
  type: LoadBalancer
  sessionAffinity: ClientIP
```

---

## 10. êµ¬í˜„ ë¡œë“œë§µ

### Phase 1: ê¸°ë³¸ WebSocket (Week 1)
- [ ] WebSocket ì„œë²„ êµ¬í˜„
- [ ] ì—°ê²° ê´€ë¦¬
- [ ] ê¸°ë³¸ ë©”ì‹œì§€ ë¼ìš°íŒ…
- [ ] Redis Pub/Sub í†µí•©

### Phase 2: CRDT êµ¬í˜„ (Week 2)
- [ ] LWW Register
- [ ] OR-Set
- [ ] RGA
- [ ] AHP íŠ¹í™” CRDT

### Phase 3: ë™ê¸°í™” í”„ë¡œí† ì½œ (Week 3)
- [ ] ë²„ì „ ë²¡í„°
- [ ] ë¸íƒ€ ë™ê¸°í™”
- [ ] ì¶©ëŒ í•´ê²°
- [ ] ì˜¤í”„ë¼ì¸ ì§€ì›

### Phase 4: ìµœì í™” ë° ëª¨ë‹ˆí„°ë§ (Week 4)
- [ ] ë©”ì‹œì§€ ì••ì¶•
- [ ] ìºì‹± ì „ëµ
- [ ] ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
- [ ] ë³´ì•ˆ ê°•í™”

---

**ë¬¸ì„œ ë²„ì „**: 1.0  
**ìµœì¢… ìˆ˜ì •ì¼**: 2024-11-29  
**ì‘ì„±ì**: Claude Opus 4.1  
**ê²€í†  ìƒíƒœ**: ì„¤ê³„ ì™„ë£Œ