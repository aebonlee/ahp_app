# ğŸ’³ ê²°ì œ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ì„¤ê³„ ë¬¸ì„œ
## ì‘ì„±ì¼: 2024-11-12
## ì‘ì„±ì: Claude Opus 4.1
## í”„ë¡œì íŠ¸: AHP Decision Support Platform

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ëª©ì 
SaaS ê¸°ë°˜ AHP í”Œë«í¼ì„ ìœ„í•œ í™•ì¥ ê°€ëŠ¥í•˜ê³  ì•ˆì „í•œ ê²°ì œ ì‹œìŠ¤í…œ êµ¬ì¶•

### 1.2 í•µì‹¬ ìš”êµ¬ì‚¬í•­
- ë‹¤ì–‘í•œ êµ¬ë… ëª¨ë¸ ì§€ì› (Freemium, Professional, Enterprise)
- PCI DSS ì¤€ìˆ˜
- ê¸€ë¡œë²Œ ê²°ì œ ë°©ë²• ì§€ì›
- ì‚¬ìš©ëŸ‰ ê¸°ë°˜ ê³¼ê¸ˆ ì˜µì…˜
- ìë™ ì²­êµ¬ ë° ì¸ë³´ì´ìŠ¤ ìƒì„±
- í™˜ë¶ˆ ë° í”„ë¡œë ˆì´íŠ¸ ì²˜ë¦¬

### 1.3 ê¸°ìˆ  ìŠ¤íƒ
- Stripe / PayPal ê²°ì œ ê²Œì´íŠ¸ì›¨ì´
- PostgreSQL íŠ¸ëœì­ì…˜ ë°ì´í„°ë² ì´ìŠ¤
- Redis ì„¸ì…˜ ê´€ë¦¬
- Bull Queue ë¹„ë™ê¸° ì²˜ë¦¬
- SendGrid ì´ë©”ì¼ ì•Œë¦¼

---

## 2. êµ¬ë… ëª¨ë¸ ì„¤ê³„

### 2.1 ê°€ê²© í‹°ì–´ êµ¬ì¡°

```typescript
export enum PricingTier {
  FREE = 'FREE',
  STARTER = 'STARTER', 
  PROFESSIONAL = 'PROFESSIONAL',
  ENTERPRISE = 'ENTERPRISE',
  CUSTOM = 'CUSTOM'
}

export interface PricingPlan {
  id: string;
  tier: PricingTier;
  name: string;
  description: string;
  pricing: {
    monthly: number;
    annual: number; // ì—°ê°„ í• ì¸ ì ìš©
    currency: 'USD' | 'KRW' | 'EUR';
  };
  features: PlanFeatures;
  limits: PlanLimits;
  addOns: AddOn[];
}

export interface PlanFeatures {
  // í”„ë¡œì íŠ¸ ê´€ë ¨
  maxProjects: number | 'unlimited';
  maxCriteriaPerProject: number | 'unlimited';
  maxAlternativesPerProject: number | 'unlimited';
  maxEvaluatorsPerProject: number | 'unlimited';
  
  // ê¸°ëŠ¥ ê´€ë ¨
  basicAnalysis: boolean;
  sensitivityAnalysis: boolean;
  monteCarloSimulation: boolean;
  whatIfScenarios: boolean;
  advancedReporting: boolean;
  apiAccess: boolean;
  
  // í˜‘ì—… ê¸°ëŠ¥
  teamCollaboration: boolean;
  roleBasedAccess: boolean;
  auditLog: boolean;
  
  // ì§€ì›
  emailSupport: boolean;
  prioritySupport: boolean;
  dedicatedAccountManager: boolean;
  sla: string | null;
}

export interface PlanLimits {
  monthlyApiCalls: number | 'unlimited';
  dataRetentionDays: number | 'unlimited';
  storageGB: number | 'unlimited';
  exportFormats: string[];
  concurrentEvaluations: number | 'unlimited';
}

// ê°€ê²© í”Œëœ ì •ì˜
export const PRICING_PLANS: Record<PricingTier, PricingPlan> = {
  [PricingTier.FREE]: {
    id: 'plan_free',
    tier: PricingTier.FREE,
    name: 'Free',
    description: 'ê°œì¸ ì‚¬ìš©ìë¥¼ ìœ„í•œ ë¬´ë£Œ í”Œëœ',
    pricing: {
      monthly: 0,
      annual: 0,
      currency: 'USD'
    },
    features: {
      maxProjects: 3,
      maxCriteriaPerProject: 10,
      maxAlternativesPerProject: 10,
      maxEvaluatorsPerProject: 5,
      basicAnalysis: true,
      sensitivityAnalysis: false,
      monteCarloSimulation: false,
      whatIfScenarios: false,
      advancedReporting: false,
      apiAccess: false,
      teamCollaboration: false,
      roleBasedAccess: false,
      auditLog: false,
      emailSupport: true,
      prioritySupport: false,
      dedicatedAccountManager: false,
      sla: null
    },
    limits: {
      monthlyApiCalls: 0,
      dataRetentionDays: 30,
      storageGB: 0.5,
      exportFormats: ['PDF'],
      concurrentEvaluations: 1
    },
    addOns: []
  },
  
  [PricingTier.STARTER]: {
    id: 'plan_starter',
    tier: PricingTier.STARTER,
    name: 'Starter',
    description: 'ì†Œê·œëª¨ íŒ€ì„ ìœ„í•œ ìŠ¤íƒ€í„° í”Œëœ',
    pricing: {
      monthly: 29,
      annual: 290, // 17% í• ì¸
      currency: 'USD'
    },
    features: {
      maxProjects: 20,
      maxCriteriaPerProject: 50,
      maxAlternativesPerProject: 50,
      maxEvaluatorsPerProject: 20,
      basicAnalysis: true,
      sensitivityAnalysis: true,
      monteCarloSimulation: false,
      whatIfScenarios: true,
      advancedReporting: true,
      apiAccess: false,
      teamCollaboration: true,
      roleBasedAccess: true,
      auditLog: false,
      emailSupport: true,
      prioritySupport: false,
      dedicatedAccountManager: false,
      sla: null
    },
    limits: {
      monthlyApiCalls: 1000,
      dataRetentionDays: 90,
      storageGB: 5,
      exportFormats: ['PDF', 'Excel', 'CSV'],
      concurrentEvaluations: 5
    },
    addOns: ['EXTRA_STORAGE', 'EXTRA_EVALUATORS']
  },
  
  [PricingTier.PROFESSIONAL]: {
    id: 'plan_professional',
    tier: PricingTier.PROFESSIONAL,
    name: 'Professional',
    description: 'ì „ë¬¸ê°€ì™€ ì¤‘ê²¬ ê¸°ì—…ì„ ìœ„í•œ í”„ë¡œí˜ì…”ë„ í”Œëœ',
    pricing: {
      monthly: 99,
      annual: 990, // 17% í• ì¸
      currency: 'USD'
    },
    features: {
      maxProjects: 100,
      maxCriteriaPerProject: 'unlimited',
      maxAlternativesPerProject: 'unlimited',
      maxEvaluatorsPerProject: 100,
      basicAnalysis: true,
      sensitivityAnalysis: true,
      monteCarloSimulation: true,
      whatIfScenarios: true,
      advancedReporting: true,
      apiAccess: true,
      teamCollaboration: true,
      roleBasedAccess: true,
      auditLog: true,
      emailSupport: true,
      prioritySupport: true,
      dedicatedAccountManager: false,
      sla: '99.5%'
    },
    limits: {
      monthlyApiCalls: 10000,
      dataRetentionDays: 365,
      storageGB: 50,
      exportFormats: ['PDF', 'Excel', 'CSV', 'PowerPoint', 'JSON'],
      concurrentEvaluations: 20
    },
    addOns: ['EXTRA_STORAGE', 'EXTRA_API_CALLS', 'WHITE_LABEL']
  },
  
  [PricingTier.ENTERPRISE]: {
    id: 'plan_enterprise',
    tier: PricingTier.ENTERPRISE,
    name: 'Enterprise',
    description: 'ëŒ€ê¸°ì—…ì„ ìœ„í•œ ì—”í„°í”„ë¼ì´ì¦ˆ í”Œëœ',
    pricing: {
      monthly: 499,
      annual: 4990, // 17% í• ì¸
      currency: 'USD'
    },
    features: {
      maxProjects: 'unlimited',
      maxCriteriaPerProject: 'unlimited',
      maxAlternativesPerProject: 'unlimited',
      maxEvaluatorsPerProject: 'unlimited',
      basicAnalysis: true,
      sensitivityAnalysis: true,
      monteCarloSimulation: true,
      whatIfScenarios: true,
      advancedReporting: true,
      apiAccess: true,
      teamCollaboration: true,
      roleBasedAccess: true,
      auditLog: true,
      emailSupport: true,
      prioritySupport: true,
      dedicatedAccountManager: true,
      sla: '99.9%'
    },
    limits: {
      monthlyApiCalls: 'unlimited',
      dataRetentionDays: 'unlimited',
      storageGB: 500,
      exportFormats: ['PDF', 'Excel', 'CSV', 'PowerPoint', 'JSON', 'XML'],
      concurrentEvaluations: 'unlimited'
    },
    addOns: ['SSO', 'CUSTOM_INTEGRATION', 'ON_PREMISE_OPTION']
  },
  
  [PricingTier.CUSTOM]: {
    id: 'plan_custom',
    tier: PricingTier.CUSTOM,
    name: 'Custom',
    description: 'ë§ì¶¤í˜• ì—”í„°í”„ë¼ì´ì¦ˆ ì†”ë£¨ì…˜',
    pricing: {
      monthly: -1, // í˜‘ì˜
      annual: -1, // í˜‘ì˜
      currency: 'USD'
    },
    features: {
      // ëª¨ë“  ê¸°ëŠ¥ í˜‘ì˜ ê°€ëŠ¥
      maxProjects: 'unlimited',
      maxCriteriaPerProject: 'unlimited',
      maxAlternativesPerProject: 'unlimited',
      maxEvaluatorsPerProject: 'unlimited',
      basicAnalysis: true,
      sensitivityAnalysis: true,
      monteCarloSimulation: true,
      whatIfScenarios: true,
      advancedReporting: true,
      apiAccess: true,
      teamCollaboration: true,
      roleBasedAccess: true,
      auditLog: true,
      emailSupport: true,
      prioritySupport: true,
      dedicatedAccountManager: true,
      sla: 'custom'
    },
    limits: {
      monthlyApiCalls: 'unlimited',
      dataRetentionDays: 'unlimited',
      storageGB: 'unlimited',
      exportFormats: ['ALL'],
      concurrentEvaluations: 'unlimited'
    },
    addOns: ['ALL']
  }
};
```

### 2.2 ì¶”ê°€ ì˜µì…˜ (Add-ons)

```typescript
export interface AddOn {
  id: string;
  name: string;
  description: string;
  pricing: {
    monthly: number;
    annual?: number;
    oneTime?: number;
  };
  type: 'recurring' | 'one-time' | 'usage-based';
  limits?: Record<string, any>;
}

export const ADD_ONS: Record<string, AddOn> = {
  EXTRA_STORAGE: {
    id: 'addon_extra_storage',
    name: 'ì¶”ê°€ ìŠ¤í† ë¦¬ì§€',
    description: '100GB ì¶”ê°€ ìŠ¤í† ë¦¬ì§€',
    pricing: {
      monthly: 10,
      annual: 100
    },
    type: 'recurring',
    limits: { storageGB: 100 }
  },
  
  EXTRA_EVALUATORS: {
    id: 'addon_extra_evaluators',
    name: 'ì¶”ê°€ í‰ê°€ì',
    description: 'í”„ë¡œì íŠ¸ë‹¹ 50ëª… ì¶”ê°€ í‰ê°€ì',
    pricing: {
      monthly: 20,
      annual: 200
    },
    type: 'recurring',
    limits: { extraEvaluators: 50 }
  },
  
  EXTRA_API_CALLS: {
    id: 'addon_extra_api',
    name: 'API í˜¸ì¶œ ì¶”ê°€',
    description: 'ì›” 10,000íšŒ ì¶”ê°€ API í˜¸ì¶œ',
    pricing: {
      monthly: 50
    },
    type: 'usage-based',
    limits: { monthlyApiCalls: 10000 }
  },
  
  WHITE_LABEL: {
    id: 'addon_white_label',
    name: 'í™”ì´íŠ¸ ë¼ë²¨',
    description: 'ë¸Œëœë”© ì»¤ìŠ¤í„°ë§ˆì´ì§•',
    pricing: {
      monthly: 100,
      oneTime: 500 // ì´ˆê¸° ì„¤ì • ë¹„ìš©
    },
    type: 'recurring'
  },
  
  SSO: {
    id: 'addon_sso',
    name: 'SSO í†µí•©',
    description: 'SAML/OAuth SSO í†µí•©',
    pricing: {
      monthly: 50,
      oneTime: 1000 // ì´ˆê¸° ì„¤ì • ë¹„ìš©
    },
    type: 'recurring'
  },
  
  CUSTOM_INTEGRATION: {
    id: 'addon_custom_integration',
    name: 'ì»¤ìŠ¤í…€ í†µí•©',
    description: 'ì™¸ë¶€ ì‹œìŠ¤í…œê³¼ì˜ ì»¤ìŠ¤í…€ í†µí•©',
    pricing: {
      oneTime: 5000 // í˜‘ì˜ ê°€ëŠ¥
    },
    type: 'one-time'
  },
  
  ON_PREMISE_OPTION: {
    id: 'addon_on_premise',
    name: 'ì˜¨í”„ë ˆë¯¸ìŠ¤ ì˜µì…˜',
    description: 'ìì²´ ì„œë²„ì— ì„¤ì¹˜',
    pricing: {
      oneTime: 10000,
      monthly: 500 // ìœ ì§€ë³´ìˆ˜ ë¹„ìš©
    },
    type: 'recurring'
  }
};
```

---

## 3. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

### 3.1 êµ¬ë… ê´€ë¦¬ í…Œì´ë¸”

```sql
-- êµ¬ë… í…Œì´ë¸”
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id),
  plan_id VARCHAR(50) NOT NULL,
  tier VARCHAR(20) NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'active', 
  -- 'active', 'canceled', 'past_due', 'trialing', 'paused', 'expired'
  
  -- Stripe/PayPal ì •ë³´
  payment_provider VARCHAR(20) NOT NULL, -- 'stripe', 'paypal'
  provider_subscription_id VARCHAR(255) UNIQUE,
  provider_customer_id VARCHAR(255),
  
  -- êµ¬ë… ê¸°ê°„
  current_period_start TIMESTAMP WITH TIME ZONE NOT NULL,
  current_period_end TIMESTAMP WITH TIME ZONE NOT NULL,
  trial_start TIMESTAMP WITH TIME ZONE,
  trial_end TIMESTAMP WITH TIME ZONE,
  canceled_at TIMESTAMP WITH TIME ZONE,
  ended_at TIMESTAMP WITH TIME ZONE,
  
  -- ê°€ê²© ì •ë³´
  billing_cycle VARCHAR(20) NOT NULL, -- 'monthly', 'annual'
  amount DECIMAL(10,2) NOT NULL,
  currency VARCHAR(3) NOT NULL DEFAULT 'USD',
  discount_percentage DECIMAL(5,2) DEFAULT 0,
  
  -- ë©”íƒ€ë°ì´í„°
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  
  CONSTRAINT check_status CHECK (
    status IN ('active', 'canceled', 'past_due', 'trialing', 'paused', 'expired')
  ),
  CONSTRAINT check_billing_cycle CHECK (
    billing_cycle IN ('monthly', 'annual', 'custom')
  )
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
CREATE INDEX idx_subscriptions_provider_subscription_id ON subscriptions(provider_subscription_id);

-- êµ¬ë… ì¶”ê°€ ì˜µì…˜ í…Œì´ë¸”
CREATE TABLE subscription_addons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  subscription_id UUID NOT NULL REFERENCES subscriptions(id) ON DELETE CASCADE,
  addon_id VARCHAR(50) NOT NULL,
  name VARCHAR(100) NOT NULL,
  quantity INTEGER NOT NULL DEFAULT 1,
  amount DECIMAL(10,2) NOT NULL,
  billing_type VARCHAR(20) NOT NULL, -- 'recurring', 'one-time', 'usage-based'
  status VARCHAR(20) NOT NULL DEFAULT 'active',
  activated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  deactivated_at TIMESTAMP WITH TIME ZONE,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  
  UNIQUE(subscription_id, addon_id)
);

-- ê²°ì œ ë‚´ì—­ í…Œì´ë¸”
CREATE TABLE payment_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  subscription_id UUID REFERENCES subscriptions(id) ON DELETE SET NULL,
  user_id UUID NOT NULL REFERENCES users(id),
  
  -- ê²°ì œ ì •ë³´
  payment_type VARCHAR(20) NOT NULL, -- 'subscription', 'addon', 'one-time'
  amount DECIMAL(10,2) NOT NULL,
  currency VARCHAR(3) NOT NULL,
  status VARCHAR(20) NOT NULL, -- 'pending', 'succeeded', 'failed', 'refunded'
  
  -- ê²°ì œ ê²Œì´íŠ¸ì›¨ì´ ì •ë³´
  provider VARCHAR(20) NOT NULL,
  provider_payment_id VARCHAR(255) UNIQUE,
  provider_payment_method_id VARCHAR(255),
  provider_invoice_id VARCHAR(255),
  
  -- ì²­êµ¬ ì •ë³´
  billing_period_start DATE,
  billing_period_end DATE,
  description TEXT,
  
  -- í™˜ë¶ˆ ì •ë³´
  refunded_amount DECIMAL(10,2) DEFAULT 0,
  refund_reason TEXT,
  refunded_at TIMESTAMP WITH TIME ZONE,
  
  -- ë©”íƒ€ë°ì´í„°
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  
  CONSTRAINT check_payment_status CHECK (
    status IN ('pending', 'succeeded', 'failed', 'refunded', 'partial_refund')
  )
);

-- ì¸ë³´ì´ìŠ¤ í…Œì´ë¸”
CREATE TABLE invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  invoice_number VARCHAR(50) UNIQUE NOT NULL,
  subscription_id UUID REFERENCES subscriptions(id),
  user_id UUID NOT NULL REFERENCES users(id),
  organization_id UUID REFERENCES organizations(id),
  
  -- ì¸ë³´ì´ìŠ¤ ì •ë³´
  status VARCHAR(20) NOT NULL DEFAULT 'draft',
  -- 'draft', 'open', 'paid', 'void', 'uncollectible'
  issue_date DATE NOT NULL,
  due_date DATE NOT NULL,
  paid_date DATE,
  
  -- ê¸ˆì•¡ ì •ë³´
  subtotal DECIMAL(10,2) NOT NULL,
  tax_amount DECIMAL(10,2) DEFAULT 0,
  discount_amount DECIMAL(10,2) DEFAULT 0,
  total_amount DECIMAL(10,2) NOT NULL,
  currency VARCHAR(3) NOT NULL,
  
  -- ì²­êµ¬ì§€ ì •ë³´
  billing_address JSONB,
  tax_id VARCHAR(50),
  
  -- PDF ë§í¬
  pdf_url TEXT,
  
  -- ê²°ì œ ì •ë³´
  payment_id UUID REFERENCES payment_history(id),
  provider_invoice_id VARCHAR(255),
  
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë³´ì´ìŠ¤ í•­ëª© í…Œì´ë¸”
CREATE TABLE invoice_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  invoice_id UUID NOT NULL REFERENCES invoices(id) ON DELETE CASCADE,
  
  type VARCHAR(20) NOT NULL, -- 'subscription', 'addon', 'usage', 'discount', 'tax'
  description TEXT NOT NULL,
  quantity DECIMAL(10,2) NOT NULL DEFAULT 1,
  unit_price DECIMAL(10,2) NOT NULL,
  amount DECIMAL(10,2) NOT NULL,
  
  -- ê¸°ê°„ ì •ë³´ (êµ¬ë…ì˜ ê²½ìš°)
  period_start DATE,
  period_end DATE,
  
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- ì‚¬ìš©ëŸ‰ ì¶”ì  í…Œì´ë¸”
CREATE TABLE usage_tracking (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  subscription_id UUID NOT NULL REFERENCES subscriptions(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id),
  
  -- ì‚¬ìš©ëŸ‰ íƒ€ì…
  usage_type VARCHAR(50) NOT NULL, 
  -- 'api_calls', 'storage_gb', 'projects', 'evaluators', 'exports'
  
  -- ì‚¬ìš©ëŸ‰ ì •ë³´
  quantity DECIMAL(10,2) NOT NULL,
  unit VARCHAR(20) NOT NULL,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  
  -- ì²­êµ¬ ì •ë³´
  billed BOOLEAN DEFAULT FALSE,
  billed_at TIMESTAMP WITH TIME ZONE,
  invoice_item_id UUID REFERENCES invoice_items(id),
  
  metadata JSONB,
  
  INDEX idx_usage_subscription (subscription_id, usage_type, timestamp),
  INDEX idx_usage_unbilled (subscription_id, billed)
);

-- ì¿ í°/í• ì¸ ì½”ë“œ í…Œì´ë¸”
CREATE TABLE coupons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code VARCHAR(50) UNIQUE NOT NULL,
  description TEXT,
  
  -- í• ì¸ ì •ë³´
  discount_type VARCHAR(20) NOT NULL, -- 'percentage', 'fixed_amount'
  discount_value DECIMAL(10,2) NOT NULL,
  currency VARCHAR(3), -- NULL if percentage
  
  -- ì ìš© ì¡°ê±´
  applicable_tiers VARCHAR(20)[] DEFAULT ARRAY['ALL'],
  minimum_amount DECIMAL(10,2),
  
  -- ìœ íš¨ ê¸°ê°„
  valid_from TIMESTAMP WITH TIME ZONE NOT NULL,
  valid_until TIMESTAMP WITH TIME ZONE NOT NULL,
  
  -- ì‚¬ìš© ì œí•œ
  max_uses INTEGER,
  used_count INTEGER DEFAULT 0,
  max_uses_per_user INTEGER DEFAULT 1,
  
  -- ìƒíƒœ
  active BOOLEAN DEFAULT TRUE,
  
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  
  CONSTRAINT check_discount_type CHECK (
    discount_type IN ('percentage', 'fixed_amount')
  )
);

-- ì¿ í° ì‚¬ìš© ë‚´ì—­
CREATE TABLE coupon_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  coupon_id UUID NOT NULL REFERENCES coupons(id),
  user_id UUID NOT NULL REFERENCES users(id),
  subscription_id UUID REFERENCES subscriptions(id),
  
  applied_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  discount_amount DECIMAL(10,2) NOT NULL,
  
  UNIQUE(coupon_id, user_id, subscription_id)
);
```

---

## 4. ê²°ì œ ì²˜ë¦¬ ì‹œìŠ¤í…œ

### 4.1 Stripe í†µí•©

```typescript
import Stripe from 'stripe';

export class StripePaymentService {
  private stripe: Stripe;
  
  constructor() {
    this.stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
      apiVersion: '2023-10-16',
      typescript: true
    });
  }

  /**
   * ê³ ê° ìƒì„±
   */
  async createCustomer(
    user: User,
    paymentMethodId?: string
  ): Promise<Stripe.Customer> {
    const customer = await this.stripe.customers.create({
      email: user.email,
      name: user.name,
      metadata: {
        userId: user.id,
        organizationId: user.organizationId || ''
      },
      payment_method: paymentMethodId,
      invoice_settings: paymentMethodId ? {
        default_payment_method: paymentMethodId
      } : undefined
    });
    
    // DBì— ê³ ê° ID ì €ì¥
    await this.saveCustomerId(user.id, customer.id);
    
    return customer;
  }

  /**
   * êµ¬ë… ìƒì„±
   */
  async createSubscription(
    customerId: string,
    planId: string,
    options?: SubscriptionOptions
  ): Promise<Stripe.Subscription> {
    const subscriptionData: Stripe.SubscriptionCreateParams = {
      customer: customerId,
      items: [{ price: planId }],
      payment_behavior: 'default_incomplete',
      payment_settings: {
        save_default_payment_method: 'on_subscription'
      },
      expand: ['latest_invoice.payment_intent'],
      metadata: options?.metadata || {}
    };
    
    // í‰ê°€íŒ ì„¤ì •
    if (options?.trialDays) {
      subscriptionData.trial_period_days = options.trialDays;
    }
    
    // ì¿ í° ì ìš©
    if (options?.couponCode) {
      subscriptionData.coupon = options.couponCode;
    }
    
    // ì¶”ê°€ ì˜µì…˜ ì ìš©
    if (options?.addons && options.addons.length > 0) {
      options.addons.forEach(addon => {
        subscriptionData.items!.push({
          price: addon.priceId,
          quantity: addon.quantity || 1
        });
      });
    }
    
    const subscription = await this.stripe.subscriptions.create(subscriptionData);
    
    // DBì— êµ¬ë… ì •ë³´ ì €ì¥
    await this.saveSubscription(subscription);
    
    return subscription;
  }

  /**
   * êµ¬ë… ì—…ê·¸ë ˆì´ë“œ/ë‹¤ìš´ê·¸ë ˆì´ë“œ
   */
  async updateSubscription(
    subscriptionId: string,
    newPlanId: string,
    prorate: boolean = true
  ): Promise<Stripe.Subscription> {
    const subscription = await this.stripe.subscriptions.retrieve(subscriptionId);
    
    // í˜„ì¬ êµ¬ë… ì•„ì´í…œ ì°¾ê¸°
    const currentItem = subscription.items.data.find(
      item => item.price.type === 'recurring'
    );
    
    if (!currentItem) {
      throw new Error('No recurring item found in subscription');
    }
    
    // êµ¬ë… ì—…ë°ì´íŠ¸
    const updated = await this.stripe.subscriptions.update(subscriptionId, {
      items: [{
        id: currentItem.id,
        price: newPlanId
      }],
      proration_behavior: prorate ? 'create_prorations' : 'none',
      expand: ['latest_invoice']
    });
    
    // í”„ë¡œë ˆì´ì…˜ ì¸ë³´ì´ìŠ¤ ì²˜ë¦¬
    if (prorate && updated.latest_invoice) {
      await this.handleProrationInvoice(updated.latest_invoice as Stripe.Invoice);
    }
    
    return updated;
  }

  /**
   * êµ¬ë… ì·¨ì†Œ
   */
  async cancelSubscription(
    subscriptionId: string,
    immediately: boolean = false
  ): Promise<Stripe.Subscription> {
    if (immediately) {
      // ì¦‰ì‹œ ì·¨ì†Œ
      return await this.stripe.subscriptions.cancel(subscriptionId);
    } else {
      // ê¸°ê°„ ë§Œë£Œ ì‹œ ì·¨ì†Œ
      return await this.stripe.subscriptions.update(subscriptionId, {
        cancel_at_period_end: true
      });
    }
  }

  /**
   * ê²°ì œ ë°©ë²• ì¶”ê°€/ì—…ë°ì´íŠ¸
   */
  async updatePaymentMethod(
    customerId: string,
    paymentMethodId: string
  ): Promise<void> {
    // ê²°ì œ ë°©ë²•ì„ ê³ ê°ì—ê²Œ ì—°ê²°
    await this.stripe.paymentMethods.attach(paymentMethodId, {
      customer: customerId
    });
    
    // ê¸°ë³¸ ê²°ì œ ë°©ë²•ìœ¼ë¡œ ì„¤ì •
    await this.stripe.customers.update(customerId, {
      invoice_settings: {
        default_payment_method: paymentMethodId
      }
    });
  }

  /**
   * í™˜ë¶ˆ ì²˜ë¦¬
   */
  async createRefund(
    paymentIntentId: string,
    amount?: number,
    reason?: string
  ): Promise<Stripe.Refund> {
    const refundData: Stripe.RefundCreateParams = {
      payment_intent: paymentIntentId,
      reason: this.mapRefundReason(reason)
    };
    
    if (amount) {
      refundData.amount = Math.round(amount * 100); // centsë¡œ ë³€í™˜
    }
    
    const refund = await this.stripe.refunds.create(refundData);
    
    // DBì— í™˜ë¶ˆ ê¸°ë¡
    await this.recordRefund(refund);
    
    return refund;
  }

  /**
   * ì‚¬ìš©ëŸ‰ ê¸°ë°˜ ê³¼ê¸ˆ ê¸°ë¡
   */
  async reportUsage(
    subscriptionItemId: string,
    quantity: number,
    timestamp?: number
  ): Promise<Stripe.UsageRecord> {
    return await this.stripe.subscriptionItems.createUsageRecord(
      subscriptionItemId,
      {
        quantity,
        timestamp: timestamp || Math.floor(Date.now() / 1000),
        action: 'increment' // or 'set'
      }
    );
  }

  /**
   * ì›¹í›… ì´ë²¤íŠ¸ ì²˜ë¦¬
   */
  async handleWebhook(
    payload: string | Buffer,
    signature: string
  ): Promise<void> {
    let event: Stripe.Event;
    
    try {
      event = this.stripe.webhooks.constructEvent(
        payload,
        signature,
        process.env.STRIPE_WEBHOOK_SECRET!
      );
    } catch (err) {
      throw new Error(`Webhook signature verification failed: ${err.message}`);
    }
    
    // ì´ë²¤íŠ¸ íƒ€ì…ë³„ ì²˜ë¦¬
    switch (event.type) {
      case 'payment_intent.succeeded':
        await this.handlePaymentSuccess(event.data.object as Stripe.PaymentIntent);
        break;
        
      case 'payment_intent.payment_failed':
        await this.handlePaymentFailure(event.data.object as Stripe.PaymentIntent);
        break;
        
      case 'customer.subscription.created':
        await this.handleSubscriptionCreated(event.data.object as Stripe.Subscription);
        break;
        
      case 'customer.subscription.updated':
        await this.handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;
        
      case 'customer.subscription.deleted':
        await this.handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;
        
      case 'invoice.payment_succeeded':
        await this.handleInvoicePaid(event.data.object as Stripe.Invoice);
        break;
        
      case 'invoice.payment_failed':
        await this.handleInvoicePaymentFailed(event.data.object as Stripe.Invoice);
        break;
        
      default:
        console.log(`Unhandled event type: ${event.type}`);
    }
  }

  /**
   * ê²°ì œ ì„±ê³µ ì²˜ë¦¬
   */
  private async handlePaymentSuccess(paymentIntent: Stripe.PaymentIntent): Promise<void> {
    // ê²°ì œ ë‚´ì—­ ì—…ë°ì´íŠ¸
    await db.query(
      `UPDATE payment_history 
       SET status = 'succeeded', 
           updated_at = CURRENT_TIMESTAMP
       WHERE provider_payment_id = $1`,
      [paymentIntent.id]
    );
    
    // ì´ë©”ì¼ ì•Œë¦¼ ë°œì†¡
    await this.sendPaymentSuccessEmail(paymentIntent);
  }

  /**
   * êµ¬ë… ìƒì„± ì²˜ë¦¬
   */
  private async handleSubscriptionCreated(subscription: Stripe.Subscription): Promise<void> {
    // DBì— êµ¬ë… ì •ë³´ ì €ì¥
    await db.query(
      `INSERT INTO subscriptions (
        user_id, plan_id, tier, status,
        payment_provider, provider_subscription_id,
        provider_customer_id, current_period_start,
        current_period_end, amount, currency,
        billing_cycle, metadata
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)`,
      [
        subscription.metadata.userId,
        subscription.items.data[0].price.id,
        subscription.metadata.tier,
        this.mapSubscriptionStatus(subscription.status),
        'stripe',
        subscription.id,
        subscription.customer,
        new Date(subscription.current_period_start * 1000),
        new Date(subscription.current_period_end * 1000),
        subscription.items.data[0].price.unit_amount! / 100,
        subscription.currency,
        subscription.items.data[0].price.recurring?.interval,
        JSON.stringify(subscription.metadata)
      ]
    );
    
    // ê¸°ëŠ¥ í™œì„±í™”
    await this.activateFeatures(subscription.metadata.userId, subscription.metadata.tier);
  }
}
```

### 4.2 PayPal í†µí•©

```typescript
import paypal from '@paypal/checkout-server-sdk';

export class PayPalPaymentService {
  private client: paypal.core.PayPalHttpClient;
  
  constructor() {
    const environment = process.env.NODE_ENV === 'production'
      ? new paypal.core.LiveEnvironment(
          process.env.PAYPAL_CLIENT_ID!,
          process.env.PAYPAL_CLIENT_SECRET!
        )
      : new paypal.core.SandboxEnvironment(
          process.env.PAYPAL_CLIENT_ID!,
          process.env.PAYPAL_CLIENT_SECRET!
        );
    
    this.client = new paypal.core.PayPalHttpClient(environment);
  }

  /**
   * êµ¬ë… í”Œëœ ìƒì„±
   */
  async createSubscriptionPlan(plan: PricingPlan): Promise<any> {
    const request = new paypal.subscriptions.PlansCreateRequest();
    request.requestBody({
      product_id: plan.id,
      name: plan.name,
      description: plan.description,
      billing_cycles: [
        {
          frequency: {
            interval_unit: plan.pricing.monthly ? 'MONTH' : 'YEAR',
            interval_count: 1
          },
          tenure_type: 'REGULAR',
          sequence: 1,
          total_cycles: 0, // ë¬´ì œí•œ
          pricing_scheme: {
            fixed_price: {
              value: plan.pricing.monthly || plan.pricing.annual,
              currency_code: plan.pricing.currency
            }
          }
        }
      ],
      payment_preferences: {
        auto_bill_outstanding: true,
        setup_fee_failure_action: 'CONTINUE',
        payment_failure_threshold: 3
      }
    });
    
    const response = await this.client.execute(request);
    return response.result;
  }

  /**
   * êµ¬ë… ìƒì„±
   */
  async createSubscription(
    planId: string,
    subscriber: SubscriberInfo
  ): Promise<any> {
    const request = new paypal.subscriptions.SubscriptionsCreateRequest();
    request.requestBody({
      plan_id: planId,
      subscriber: {
        name: {
          given_name: subscriber.firstName,
          surname: subscriber.lastName
        },
        email_address: subscriber.email
      },
      application_context: {
        brand_name: 'AHP Platform',
        locale: 'en-US',
        shipping_preference: 'NO_SHIPPING',
        user_action: 'SUBSCRIBE_NOW',
        return_url: `${process.env.FRONTEND_URL}/subscription/success`,
        cancel_url: `${process.env.FRONTEND_URL}/subscription/cancel`
      }
    });
    
    const response = await this.client.execute(request);
    return response.result;
  }
}
```

---

## 5. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§

### 5.1 êµ¬ë… ê´€ë¦¬ ì„œë¹„ìŠ¤

```typescript
export class SubscriptionManagementService {
  private stripeService: StripePaymentService;
  private paypalService: PayPalPaymentService;
  private emailService: EmailService;
  private analyticsService: AnalyticsService;
  
  /**
   * ë¬´ë£Œ í‰ê°€íŒ ì‹œì‘
   */
  async startFreeTrial(
    userId: string,
    planTier: PricingTier,
    trialDays: number = 14
  ): Promise<SubscriptionResult> {
    // ì´ë¯¸ êµ¬ë…ì´ ìˆëŠ”ì§€ í™•ì¸
    const existing = await this.checkExistingSubscription(userId);
    if (existing) {
      throw new Error('User already has an active subscription');
    }
    
    // í‰ê°€íŒ êµ¬ë… ìƒì„±
    const trialEnd = new Date();
    trialEnd.setDate(trialEnd.getDate() + trialDays);
    
    const subscription = await db.query(
      `INSERT INTO subscriptions (
        user_id, plan_id, tier, status,
        trial_start, trial_end,
        current_period_start, current_period_end,
        amount, currency, billing_cycle
      ) VALUES ($1, $2, $3, 'trialing', $4, $5, $6, $7, 0, 'USD', 'monthly')
      RETURNING *`,
      [
        userId,
        PRICING_PLANS[planTier].id,
        planTier,
        new Date(),
        trialEnd,
        new Date(),
        trialEnd
      ]
    );
    
    // ê¸°ëŠ¥ í™œì„±í™”
    await this.activateFeatures(userId, planTier);
    
    // ì•Œë¦¼ ì´ë©”ì¼ ë°œì†¡
    await this.emailService.sendTrialStartEmail(userId, planTier, trialDays);
    
    // í‰ê°€íŒ ì¢…ë£Œ ë¦¬ë§ˆì¸ë” ìŠ¤ì¼€ì¤„ë§
    await this.scheduleTrialReminders(subscription.id, trialEnd);
    
    return {
      success: true,
      subscription,
      message: `${trialDays}ì¼ ë¬´ë£Œ í‰ê°€íŒì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.`
    };
  }

  /**
   * êµ¬ë… ì—…ê·¸ë ˆì´ë“œ
   */
  async upgradeSubscription(
    subscriptionId: string,
    newTier: PricingTier,
    immediately: boolean = true
  ): Promise<SubscriptionUpgradeResult> {
    const subscription = await this.getSubscription(subscriptionId);
    const currentPlan = PRICING_PLANS[subscription.tier];
    const newPlan = PRICING_PLANS[newTier];
    
    // ì—…ê·¸ë ˆì´ë“œ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
    if (this.getTierLevel(newTier) <= this.getTierLevel(subscription.tier)) {
      throw new Error('New tier must be higher than current tier');
    }
    
    // í”„ë¡œë ˆì´ì…˜ ê³„ì‚°
    const prorationAmount = this.calculateProration(
      subscription,
      currentPlan,
      newPlan
    );
    
    // ê²°ì œ ì²˜ë¦¬
    if (subscription.payment_provider === 'stripe') {
      await this.stripeService.updateSubscription(
        subscription.provider_subscription_id,
        newPlan.id,
        immediately
      );
    } else if (subscription.payment_provider === 'paypal') {
      // PayPal ì—…ê·¸ë ˆì´ë“œ ì²˜ë¦¬
      await this.paypalService.updateSubscription(
        subscription.provider_subscription_id,
        newPlan.id
      );
    }
    
    // DB ì—…ë°ì´íŠ¸
    await db.query(
      `UPDATE subscriptions 
       SET tier = $1, plan_id = $2, amount = $3, updated_at = CURRENT_TIMESTAMP
       WHERE id = $4`,
      [newTier, newPlan.id, newPlan.pricing.monthly, subscriptionId]
    );
    
    // ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¦‰ì‹œ í™œì„±í™”
    await this.activateFeatures(subscription.user_id, newTier);
    
    return {
      success: true,
      previousTier: subscription.tier,
      newTier,
      prorationAmount,
      effectiveDate: immediately ? new Date() : subscription.current_period_end
    };
  }

  /**
   * êµ¬ë… ë‹¤ìš´ê·¸ë ˆì´ë“œ
   */
  async downgradeSubscription(
    subscriptionId: string,
    newTier: PricingTier
  ): Promise<SubscriptionDowngradeResult> {
    const subscription = await this.getSubscription(subscriptionId);
    
    // ë‹¤ìš´ê·¸ë ˆì´ë“œ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
    if (this.getTierLevel(newTier) >= this.getTierLevel(subscription.tier)) {
      throw new Error('New tier must be lower than current tier');
    }
    
    // ì‚¬ìš©ëŸ‰ ì²´í¬ (ë‹¤ìš´ê·¸ë ˆì´ë“œ ì‹œ ì œí•œ ì´ˆê³¼ í™•ì¸)
    const usage = await this.checkUsageAgainstLimits(
      subscription.user_id,
      PRICING_PLANS[newTier].limits
    );
    
    if (!usage.compatible) {
      return {
        success: false,
        incompatibleFeatures: usage.incompatibleFeatures,
        message: 'í˜„ì¬ ì‚¬ìš©ëŸ‰ì´ ìƒˆ í”Œëœì˜ ì œí•œì„ ì´ˆê³¼í•©ë‹ˆë‹¤.'
      };
    }
    
    // ë‹¤ìš´ê·¸ë ˆì´ë“œëŠ” í˜„ì¬ ê¸°ê°„ ì¢…ë£Œ ì‹œ ì ìš©
    await db.query(
      `UPDATE subscriptions 
       SET 
         tier = $1,
         plan_id = $2,
         amount = $3,
         downgrade_to_tier = $4,
         downgrade_at = current_period_end,
         updated_at = CURRENT_TIMESTAMP
       WHERE id = $5`,
      [
        subscription.tier, // í˜„ì¬ í‹°ì–´ ìœ ì§€
        subscription.plan_id,
        subscription.amount,
        newTier, // ë‹¤ìš´ê·¸ë ˆì´ë“œ ì˜ˆì • í‹°ì–´
        subscriptionId
      ]
    );
    
    // ì•Œë¦¼ ë°œì†¡
    await this.emailService.sendDowngradeScheduledEmail(
      subscription.user_id,
      subscription.tier,
      newTier,
      subscription.current_period_end
    );
    
    return {
      success: true,
      currentTier: subscription.tier,
      scheduledTier: newTier,
      effectiveDate: subscription.current_period_end,
      message: 'ë‹¤ìš´ê·¸ë ˆì´ë“œê°€ ì˜ˆì•½ë˜ì—ˆìŠµë‹ˆë‹¤. í˜„ì¬ ê²°ì œ ê¸°ê°„ì´ ì¢…ë£Œë˜ë©´ ì ìš©ë©ë‹ˆë‹¤.'
    };
  }

  /**
   * í”„ë¡œë ˆì´ì…˜ ê³„ì‚°
   */
  private calculateProration(
    subscription: Subscription,
    currentPlan: PricingPlan,
    newPlan: PricingPlan
  ): number {
    const now = new Date();
    const periodStart = new Date(subscription.current_period_start);
    const periodEnd = new Date(subscription.current_period_end);
    
    // ë‚¨ì€ ê¸°ê°„ ê³„ì‚° (ì¼ ë‹¨ìœ„)
    const totalDays = (periodEnd.getTime() - periodStart.getTime()) / (1000 * 60 * 60 * 24);
    const remainingDays = (periodEnd.getTime() - now.getTime()) / (1000 * 60 * 60 * 24);
    const usedDays = totalDays - remainingDays;
    
    // ì‚¬ìš©í•œ ê¸ˆì•¡ (í˜„ì¬ í”Œëœ)
    const usedAmount = (currentPlan.pricing.monthly / totalDays) * usedDays;
    
    // ë‚¨ì€ ê¸°ê°„ ê¸ˆì•¡ (ìƒˆ í”Œëœ)
    const remainingAmount = (newPlan.pricing.monthly / totalDays) * remainingDays;
    
    // ì´ë¯¸ ì§€ë¶ˆí•œ ê¸ˆì•¡
    const paidAmount = currentPlan.pricing.monthly;
    
    // ì¶”ê°€ ê²°ì œ í•„ìš” ê¸ˆì•¡
    return Math.max(0, usedAmount + remainingAmount - paidAmount);
  }

  /**
   * ìë™ ê°±ì‹  ì²˜ë¦¬
   */
  async processAutoRenewal(subscriptionId: string): Promise<void> {
    const subscription = await this.getSubscription(subscriptionId);
    
    try {
      // ê²°ì œ ì²˜ë¦¬
      const paymentResult = await this.processPayment(subscription);
      
      if (paymentResult.success) {
        // êµ¬ë… ê¸°ê°„ ì—°ì¥
        const newPeriodEnd = new Date(subscription.current_period_end);
        if (subscription.billing_cycle === 'monthly') {
          newPeriodEnd.setMonth(newPeriodEnd.getMonth() + 1);
        } else {
          newPeriodEnd.setFullYear(newPeriodEnd.getFullYear() + 1);
        }
        
        await db.query(
          `UPDATE subscriptions 
           SET 
             current_period_start = current_period_end,
             current_period_end = $1,
             status = 'active',
             updated_at = CURRENT_TIMESTAMP
           WHERE id = $2`,
          [newPeriodEnd, subscriptionId]
        );
        
        // ì¸ë³´ì´ìŠ¤ ìƒì„±
        await this.generateInvoice(subscription, paymentResult);
        
        // ê°±ì‹  ì„±ê³µ ì•Œë¦¼
        await this.emailService.sendRenewalSuccessEmail(subscription);
        
      } else {
        // ê²°ì œ ì‹¤íŒ¨ ì²˜ë¦¬
        await this.handlePaymentFailure(subscription, paymentResult.error);
      }
    } catch (error) {
      await this.handleRenewalError(subscription, error);
    }
  }

  /**
   * ê²°ì œ ì‹¤íŒ¨ ì²˜ë¦¬
   */
  private async handlePaymentFailure(
    subscription: Subscription,
    error: any
  ): Promise<void> {
    // ì¬ì‹œë„ íšŸìˆ˜ ì¦ê°€
    const retryCount = (subscription.metadata?.retryCount || 0) + 1;
    
    if (retryCount <= 3) {
      // ì¬ì‹œë„ ìŠ¤ì¼€ì¤„ë§
      await this.schedulePaymentRetry(subscription.id, retryCount);
      
      // êµ¬ë… ìƒíƒœë¥¼ past_dueë¡œ ë³€ê²½
      await db.query(
        `UPDATE subscriptions 
         SET status = 'past_due', 
             metadata = jsonb_set(metadata, '{retryCount}', $1::jsonb)
         WHERE id = $2`,
        [retryCount, subscription.id]
      );
      
      // ê²°ì œ ì‹¤íŒ¨ ì•Œë¦¼
      await this.emailService.sendPaymentFailedEmail(
        subscription,
        retryCount,
        error.message
      );
    } else {
      // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ - êµ¬ë… ì¼ì‹œ ì¤‘ì§€
      await this.suspendSubscription(subscription.id);
    }
  }
}
```

---

## 6. API ì—”ë“œí¬ì¸íŠ¸

### 6.1 êµ¬ë… ê´€ë ¨ API

```typescript
// GET /api/pricing/plans
router.get('/pricing/plans', async (req, res) => {
  const plans = Object.values(PRICING_PLANS).map(plan => ({
    ...plan,
    features: plan.features,
    limits: plan.limits
  }));
  
  res.json({
    plans,
    addons: Object.values(ADD_ONS)
  });
});

// POST /api/subscription/create
router.post('/subscription/create', authenticate, async (req, res) => {
  const { planTier, paymentMethodId, couponCode } = req.body;
  
  try {
    const result = await subscriptionService.createSubscription(
      req.user.id,
      planTier,
      {
        paymentMethodId,
        couponCode
      }
    );
    
    res.json(result);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// POST /api/subscription/upgrade
router.post('/subscription/upgrade', authenticate, async (req, res) => {
  const { newTier, immediately } = req.body;
  
  try {
    const subscription = await subscriptionService.getUserSubscription(req.user.id);
    const result = await subscriptionService.upgradeSubscription(
      subscription.id,
      newTier,
      immediately
    );
    
    res.json(result);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// POST /api/subscription/cancel
router.post('/subscription/cancel', authenticate, async (req, res) => {
  const { reason, immediately } = req.body;
  
  try {
    const subscription = await subscriptionService.getUserSubscription(req.user.id);
    const result = await subscriptionService.cancelSubscription(
      subscription.id,
      {
        reason,
        immediately
      }
    );
    
    res.json(result);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// GET /api/subscription/usage
router.get('/subscription/usage', authenticate, async (req, res) => {
  const usage = await usageTrackingService.getCurrentUsage(req.user.id);
  const limits = await subscriptionService.getCurrentLimits(req.user.id);
  
  res.json({
    usage,
    limits,
    percentages: calculateUsagePercentages(usage, limits)
  });
});

// GET /api/billing/invoices
router.get('/billing/invoices', authenticate, async (req, res) => {
  const invoices = await billingService.getUserInvoices(req.user.id);
  
  res.json(invoices);
});

// POST /api/billing/payment-method
router.post('/billing/payment-method', authenticate, async (req, res) => {
  const { paymentMethodId } = req.body;
  
  try {
    await billingService.updatePaymentMethod(req.user.id, paymentMethodId);
    res.json({ success: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

// POST /webhooks/stripe
router.post('/webhooks/stripe', 
  express.raw({ type: 'application/json' }), 
  async (req, res) => {
    try {
      await stripeService.handleWebhook(req.body, req.headers['stripe-signature']);
      res.json({ received: true });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }
);

// POST /webhooks/paypal
router.post('/webhooks/paypal', async (req, res) => {
  try {
    await paypalService.handleWebhook(req.body);
    res.json({ received: true });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});
```

---

## 7. ë³´ì•ˆ ë° ì»´í”Œë¼ì´ì–¸ìŠ¤

### 7.1 PCI DSS ì¤€ìˆ˜ ì‚¬í•­
- ì¹´ë“œ ì •ë³´ë¥¼ ì§ì ‘ ì €ì¥í•˜ì§€ ì•ŠìŒ (í† í°í™” ì‚¬ìš©)
- HTTPS ì „ìš© í†µì‹ 
- ê²°ì œ ì •ë³´ ì ‘ê·¼ ë¡œê¹…
- ì •ê¸° ë³´ì•ˆ ê°ì‚¬

### 7.2 ë°ì´í„° ë³´í˜¸
- ë¯¼ê°í•œ ê²°ì œ ì •ë³´ ì•”í˜¸í™”
- ê²°ì œ í† í°ë§Œ ì €ì¥
- ì ‘ê·¼ ê¶Œí•œ ê´€ë¦¬
- ê°ì‚¬ ë¡œê·¸ ìœ ì§€

### 7.3 ì‚¬ê¸° ë°©ì§€
- ë¹„ì •ìƒì ì¸ ê²°ì œ íŒ¨í„´ ê°ì§€
- IP ê¸°ë°˜ ì§€ì—­ í™•ì¸
- ì†ë„ ì œí•œ ì ìš©
- ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ ëª¨ë‹ˆí„°ë§

---

## 8. êµ¬í˜„ ìš°ì„ ìˆœìœ„

### Phase 1: ê¸°ë³¸ ê²°ì œ (1ì£¼ì°¨)
1. Stripe í†µí•©
2. ê¸°ë³¸ êµ¬ë… ìƒì„±/ì·¨ì†Œ
3. ê²°ì œ ì›¹í›… ì²˜ë¦¬
4. ì¸ë³´ì´ìŠ¤ ìƒì„±

### Phase 2: ê³ ê¸‰ ê¸°ëŠ¥ (2ì£¼ì°¨)
1. êµ¬ë… ì—…ê·¸ë ˆì´ë“œ/ë‹¤ìš´ê·¸ë ˆì´ë“œ
2. í”„ë¡œë ˆì´ì…˜ ì²˜ë¦¬
3. ì¿ í°/í• ì¸ ì‹œìŠ¤í…œ
4. ì‚¬ìš©ëŸ‰ ê¸°ë°˜ ê³¼ê¸ˆ

### Phase 3: ìµœì í™” (3ì£¼ì°¨)
1. PayPal í†µí•©
2. ë‹¤ì¤‘ í†µí™” ì§€ì›
3. ì„¸ê¸ˆ ê³„ì‚°
4. ë¶„ì„ ë° ë¦¬í¬íŠ¸

---

**ì‘ì„± ì™„ë£Œ**: 2024-11-12 03:00 KST
**ë‹¤ìŒ ë‹¨ê³„**: CLAUDE.md ì—…ë°ì´íŠ¸ ë° ë°±ì—…