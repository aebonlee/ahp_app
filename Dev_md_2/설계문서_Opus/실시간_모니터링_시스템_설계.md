# ğŸ“Š ì‹¤ì‹œê°„ í‰ê°€ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì„¤ê³„
## ì‘ì„±ì¼: 2024-11-11  
## ì‘ì„±ì: Claude Opus 4.1
## ë²„ì „: 1.0.0

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ëª©ì 
ì‹¤ì‹œê°„ í‰ê°€ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì€ ê´€ë¦¬ìì™€ í‰ê°€ìë“¤ì´ í‰ê°€ ì§„í–‰ ìƒí™©ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ì¶”ì í•˜ê³ , ë°ì´í„° ê¸°ë°˜ ì˜ì‚¬ê²°ì •ì„ ì§€ì›í•˜ëŠ” ì¢…í•© ëŒ€ì‹œë³´ë“œ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### 1.2 í•µì‹¬ ê¸°ëŠ¥
- ì‹¤ì‹œê°„ í‰ê°€ ì§„í–‰ë¥  ì¶”ì 
- í‰ê°€ìë³„ í™œë™ ëª¨ë‹ˆí„°ë§
- ì¼ê´€ì„± ì§€í‘œ ì‹¤ì‹œê°„ í‘œì‹œ
- ì´ìƒ íŒ¨í„´ ê°ì§€ ë° ì•Œë¦¼
- ì„±ê³¼ ë©”íŠ¸ë¦­ ëŒ€ì‹œë³´ë“œ
- ì˜ˆì¸¡ ë¶„ì„ ë° ì¶”ì²œ

### 1.3 ê¸°ìˆ  ìŠ¤íƒ
- **ì‹¤ì‹œê°„ í†µì‹ **: WebSocket (Socket.io)
- **ìŠ¤íŠ¸ë¦¬ë°**: Server-Sent Events (SSE)
- **ìºì‹±**: Redis Streams
- **ë©”ì‹œì§•**: RabbitMQ / Kafka
- **ëª¨ë‹ˆí„°ë§**: Prometheus + Grafana
- **ë¡œê¹…**: ELK Stack (Elasticsearch, Logstash, Kibana)

---

## 2. ì•„í‚¤í…ì²˜ ì„¤ê³„

### 2.1 ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

```typescript
// ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜
export interface MonitoringArchitecture {
  services: {
    apiGateway: 'Kong' | 'Nginx';
    realtimeService: 'Node.js + Socket.io';
    analyticsService: 'Python + FastAPI';
    notificationService: 'Node.js + Bull';
    dataProcessor: 'Apache Spark' | 'Flink';
  };
  
  dataFlow: {
    ingestion: 'Kafka';
    processing: 'Stream Processing';
    storage: 'TimeSeries DB + PostgreSQL';
    cache: 'Redis';
    delivery: 'WebSocket + SSE';
  };
  
  monitoring: {
    metrics: 'Prometheus';
    visualization: 'Grafana';
    logging: 'ELK Stack';
    tracing: 'Jaeger';
  };
}
```

### 2.2 ë°ì´í„° í”Œë¡œìš°

```mermaid
graph LR
    A[Client Apps] --> B[API Gateway]
    B --> C[WebSocket Server]
    B --> D[REST API]
    
    C --> E[Redis Pub/Sub]
    D --> F[Message Queue]
    
    E --> G[Stream Processor]
    F --> G
    
    G --> H[TimeSeries DB]
    G --> I[PostgreSQL]
    G --> J[Cache Layer]
    
    J --> K[Real-time Dashboard]
    H --> L[Analytics Engine]
    L --> K
```

---

## 3. ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„

### 3.1 ì‹œê³„ì—´ ë°ì´í„° ìŠ¤í‚¤ë§ˆ

```sql
-- ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
CREATE TABLE evaluation_events (
    id BIGSERIAL PRIMARY KEY,
    event_id UUID DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL,
    evaluator_id UUID NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    event_data JSONB NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    processed BOOLEAN DEFAULT false,
    
    INDEX idx_events_timestamp (timestamp DESC),
    INDEX idx_events_project (project_id, timestamp DESC),
    INDEX idx_events_evaluator (evaluator_id, timestamp DESC)
) PARTITION BY RANGE (timestamp);

-- ì›”ë³„ íŒŒí‹°ì…˜
CREATE TABLE evaluation_events_2024_11 PARTITION OF evaluation_events
    FOR VALUES FROM ('2024-11-01') TO ('2024-12-01');

-- ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­
CREATE TABLE realtime_metrics (
    id BIGSERIAL PRIMARY KEY,
    project_id UUID NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value DECIMAL(10,4),
    dimensions JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_metrics_project_time (project_id, metric_name, timestamp DESC)
);

-- í‰ê°€ì í™œë™ ì¶”ì 
CREATE TABLE evaluator_activities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    evaluator_id UUID NOT NULL REFERENCES evaluators(id),
    project_id UUID NOT NULL REFERENCES projects(id),
    session_id UUID,
    activity_type VARCHAR(50),
    details JSONB,
    ip_address INET,
    user_agent TEXT,
    duration_seconds INTEGER,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_activity_evaluator (evaluator_id, timestamp DESC),
    INDEX idx_activity_session (session_id)
);

-- ì•Œë¦¼ í
CREATE TABLE notification_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    recipient_id UUID NOT NULL,
    notification_type VARCHAR(50),
    priority INTEGER DEFAULT 5,
    title VARCHAR(255),
    message TEXT,
    data JSONB,
    channels JSONB DEFAULT '["email", "in_app"]',
    status VARCHAR(20) DEFAULT 'pending',
    scheduled_at TIMESTAMP WITH TIME ZONE,
    sent_at TIMESTAMP WITH TIME ZONE,
    read_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    
    INDEX idx_notif_recipient (recipient_id, status),
    INDEX idx_notif_scheduled (scheduled_at) WHERE status = 'pending'
);

-- ì„±ëŠ¥ ìŠ¤ëƒ…ìƒ·
CREATE TABLE performance_snapshots (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id),
    snapshot_type VARCHAR(50),
    metrics JSONB NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_snapshot_project (project_id, timestamp DESC)
);
```

### 3.2 Redis ë°ì´í„° êµ¬ì¡°

```typescript
// Redis í‚¤ êµ¬ì¡°
export const RedisSchema = {
  // ì‹¤ì‹œê°„ ì¹´ìš´í„°
  counters: {
    activeUsers: 'monitor:active_users',
    onlineEvaluators: 'monitor:project:{projectId}:online',
    completedToday: 'monitor:completed:today:{date}'
  },
  
  // ì‹¤ì‹œê°„ ì§„í–‰ë¥ 
  progress: {
    project: 'progress:project:{projectId}',
    evaluator: 'progress:evaluator:{evaluatorId}',
    node: 'progress:node:{nodeId}'
  },
  
  // ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­
  metrics: {
    throughput: 'metrics:throughput:{projectId}',
    latency: 'metrics:latency:{endpoint}',
    errorRate: 'metrics:errors:{service}'
  },
  
  // ì„¸ì…˜ ê´€ë¦¬
  sessions: {
    active: 'sessions:active:{sessionId}',
    evaluator: 'sessions:evaluator:{evaluatorId}'
  },
  
  // ì•Œë¦¼ ì±„ë„
  pubsub: {
    updates: 'channel:updates:{projectId}',
    notifications: 'channel:notifications:{userId}',
    broadcasts: 'channel:broadcast:all'
  }
};
```

---

## 4. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì—”ì§„

### 4.1 ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œìŠ¤í…œ

```typescript
export class RealTimeMonitoringEngine {
  private eventProcessor: EventProcessor;
  private metricsCollector: MetricsCollector;
  private anomalyDetector: AnomalyDetector;
  private notificationService: NotificationService;
  
  constructor(config: MonitoringConfig) {
    this.eventProcessor = new EventProcessor(config);
    this.metricsCollector = new MetricsCollector(config);
    this.anomalyDetector = new AnomalyDetector(config);
    this.notificationService = new NotificationService(config);
    
    this.initialize();
  }
  
  /**
   * ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬
   */
  async processEventStream(event: EvaluationEvent): Promise<void> {
    // 1. ì´ë²¤íŠ¸ ê²€ì¦
    if (!this.validateEvent(event)) {
      throw new Error('Invalid event format');
    }
    
    // 2. ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
    await this.updateMetrics(event);
    
    // 3. ìƒíƒœ ì—…ë°ì´íŠ¸
    await this.updateState(event);
    
    // 4. ì´ìƒ íƒì§€
    const anomalies = await this.detectAnomalies(event);
    
    // 5. ì•Œë¦¼ ë°œì†¡
    if (anomalies.length > 0) {
      await this.sendAlerts(anomalies);
    }
    
    // 6. ë¸Œë¡œë“œìºìŠ¤íŠ¸
    await this.broadcastUpdate(event);
    
    // 7. ë¡œê¹…
    await this.logEvent(event);
  }
  
  /**
   * ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ë° ì§‘ê³„
   */
  private async updateMetrics(event: EvaluationEvent): Promise<void> {
    const metrics = this.extractMetrics(event);
    
    // ì‹¤ì‹œê°„ ì¹´ìš´í„° ì—…ë°ì´íŠ¸
    await this.metricsCollector.increment(metrics.counters);
    
    // ê²Œì´ì§€ ì—…ë°ì´íŠ¸
    await this.metricsCollector.gauge(metrics.gauges);
    
    // íˆìŠ¤í† ê·¸ë¨ ì—…ë°ì´íŠ¸
    await this.metricsCollector.histogram(metrics.histograms);
    
    // ì‹œê³„ì—´ ë°ì´í„° ì €ì¥
    await this.saveTimeSeriesData(metrics);
  }
  
  /**
   * ì´ìƒ íŒ¨í„´ ê°ì§€
   */
  private async detectAnomalies(event: EvaluationEvent): Promise<Anomaly[]> {
    const anomalies: Anomaly[] = [];
    
    // 1. í†µê³„ì  ì´ìƒì¹˜ íƒì§€
    const statistical = await this.anomalyDetector.detectStatistical(event);
    if (statistical) anomalies.push(statistical);
    
    // 2. íŒ¨í„´ ê¸°ë°˜ ì´ìƒ íƒì§€
    const pattern = await this.anomalyDetector.detectPattern(event);
    if (pattern) anomalies.push(pattern);
    
    // 3. ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ íƒì§€
    const ml = await this.anomalyDetector.detectML(event);
    if (ml) anomalies.push(ml);
    
    // 4. ê·œì¹™ ê¸°ë°˜ íƒì§€
    const rules = await this.anomalyDetector.checkRules(event);
    anomalies.push(...rules);
    
    return anomalies;
  }
  
  /**
   * ì‹¤ì‹œê°„ ë¸Œë¡œë“œìºìŠ¤íŠ¸
   */
  private async broadcastUpdate(event: EvaluationEvent): Promise<void> {
    const update: RealtimeUpdate = {
      type: 'evaluation_update',
      projectId: event.projectId,
      timestamp: new Date(),
      data: {
        event,
        metrics: await this.getCurrentMetrics(event.projectId),
        progress: await this.getProgress(event.projectId),
        activeUsers: await this.getActiveUsers(event.projectId)
      }
    };
    
    // WebSocket ë¸Œë¡œë“œìºìŠ¤íŠ¸
    await this.websocketServer.broadcast(
      `project:${event.projectId}`,
      update
    );
    
    // Redis Pub/Sub
    await this.redis.publish(
      `channel:updates:${event.projectId}`,
      JSON.stringify(update)
    );
  }
  
  /**
   * ë©”íŠ¸ë¦­ ì¶”ì¶œ
   */
  private extractMetrics(event: EvaluationEvent): ExtractedMetrics {
    const metrics: ExtractedMetrics = {
      counters: {},
      gauges: {},
      histograms: {}
    };
    
    switch (event.type) {
      case 'comparison_submitted':
        metrics.counters['comparisons_total'] = 1;
        metrics.histograms['comparison_duration'] = event.duration;
        break;
        
      case 'node_completed':
        metrics.counters['nodes_completed'] = 1;
        metrics.gauges['consistency_ratio'] = event.consistencyRatio;
        break;
        
      case 'evaluation_started':
        metrics.counters['evaluations_started'] = 1;
        metrics.gauges['active_evaluations'] = 1;
        break;
        
      case 'evaluation_completed':
        metrics.counters['evaluations_completed'] = 1;
        metrics.gauges['active_evaluations'] = -1;
        metrics.histograms['evaluation_time'] = event.totalTime;
        break;
    }
    
    return metrics;
  }
}
```

### 4.2 ì‹¤ì‹œê°„ ì§„í–‰ë¥  ì¶”ì 

```typescript
export class ProgressTracker {
  private redis: RedisClient;
  private db: Database;
  private websocket: WebSocketServer;
  
  /**
   * ì§„í–‰ë¥  ì—…ë°ì´íŠ¸ ë° ë¸Œë¡œë“œìºìŠ¤íŠ¸
   */
  async updateProgress(
    projectId: string,
    evaluatorId: string,
    nodeId: string,
    progress: number
  ): Promise<void> {
    // 1. Redis ì—…ë°ì´íŠ¸ (ë¹ ë¥¸ ì½ê¸°ìš©)
    const key = `progress:${projectId}:${evaluatorId}:${nodeId}`;
    await this.redis.set(key, progress, 'EX', 3600);
    
    // 2. ì§‘ê³„ ê³„ì‚°
    const overallProgress = await this.calculateOverallProgress(projectId);
    const evaluatorProgress = await this.calculateEvaluatorProgress(projectId, evaluatorId);
    
    // 3. DB ì—…ë°ì´íŠ¸ (ì˜êµ¬ ì €ì¥)
    await this.saveProgressToDB({
      projectId,
      evaluatorId,
      nodeId,
      progress,
      overallProgress,
      timestamp: new Date()
    });
    
    // 4. ì‹¤ì‹œê°„ ë¸Œë¡œë“œìºìŠ¤íŠ¸
    await this.broadcastProgress({
      projectId,
      evaluatorId,
      nodeId,
      nodeProgress: progress,
      evaluatorProgress,
      overallProgress,
      timestamp: new Date()
    });
    
    // 5. ë§ˆì¼ìŠ¤í†¤ ì²´í¬
    await this.checkMilestones(projectId, overallProgress);
  }
  
  /**
   * ì „ì²´ ì§„í–‰ë¥  ê³„ì‚°
   */
  private async calculateOverallProgress(projectId: string): Promise<ProgressMetrics> {
    // Redisì—ì„œ ëª¨ë“  ì§„í–‰ë¥  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
    const pattern = `progress:${projectId}:*`;
    const keys = await this.redis.keys(pattern);
    
    if (keys.length === 0) {
      return {
        overall: 0,
        byLevel: {},
        byEvaluator: {},
        estimated: null
      };
    }
    
    // ì§„í–‰ë¥  ì§‘ê³„
    let totalProgress = 0;
    const levelProgress: Map<number, number[]> = new Map();
    const evaluatorProgress: Map<string, number[]> = new Map();
    
    for (const key of keys) {
      const parts = key.split(':');
      const evaluatorId = parts[2];
      const nodeId = parts[3];
      const progress = parseFloat(await this.redis.get(key) || '0');
      
      totalProgress += progress;
      
      // ë ˆë²¨ë³„ ì§‘ê³„
      const nodeLevel = await this.getNodeLevel(nodeId);
      if (!levelProgress.has(nodeLevel)) {
        levelProgress.set(nodeLevel, []);
      }
      levelProgress.get(nodeLevel)!.push(progress);
      
      // í‰ê°€ìë³„ ì§‘ê³„
      if (!evaluatorProgress.has(evaluatorId)) {
        evaluatorProgress.set(evaluatorId, []);
      }
      evaluatorProgress.get(evaluatorId)!.push(progress);
    }
    
    // í‰ê·  ê³„ì‚°
    const overall = totalProgress / keys.length;
    
    const byLevel: Record<number, number> = {};
    for (const [level, progresses] of levelProgress) {
      byLevel[level] = progresses.reduce((a, b) => a + b, 0) / progresses.length;
    }
    
    const byEvaluator: Record<string, number> = {};
    for (const [evaluatorId, progresses] of evaluatorProgress) {
      byEvaluator[evaluatorId] = progresses.reduce((a, b) => a + b, 0) / progresses.length;
    }
    
    // ì™„ë£Œ ì‹œê°„ ì˜ˆì¸¡
    const estimated = await this.estimateCompletion(projectId, overall);
    
    return {
      overall,
      byLevel,
      byEvaluator,
      estimated
    };
  }
  
  /**
   * ì™„ë£Œ ì‹œê°„ ì˜ˆì¸¡
   */
  private async estimateCompletion(
    projectId: string,
    currentProgress: number
  ): Promise<CompletionEstimate | null> {
    // ê³¼ê±° ì§„í–‰ë¥  ë°ì´í„° ì¡°íšŒ
    const history = await this.db.query<ProgressHistory>(
      `SELECT progress, timestamp 
       FROM performance_snapshots 
       WHERE project_id = $1 
         AND snapshot_type = 'progress'
       ORDER BY timestamp DESC 
       LIMIT 100`,
      [projectId]
    );
    
    if (history.length < 2) {
      return null;
    }
    
    // ì„ í˜• íšŒê·€ë¡œ ì§„í–‰ ì†ë„ ê³„ì‚°
    const regression = this.linearRegression(
      history.map(h => h.timestamp.getTime()),
      history.map(h => h.progress)
    );
    
    // 100% ë„ë‹¬ ì‹œì  ì˜ˆì¸¡
    const remainingProgress = 100 - currentProgress;
    const estimatedTime = remainingProgress / regression.slope;
    
    return {
      estimatedCompletion: new Date(Date.now() + estimatedTime),
      confidence: regression.r2,
      progressRate: regression.slope,
      remainingTime: estimatedTime
    };
  }
  
  /**
   * ë§ˆì¼ìŠ¤í†¤ ì²´í¬ ë° ì•Œë¦¼
   */
  private async checkMilestones(
    projectId: string,
    progress: ProgressMetrics
  ): Promise<void> {
    const milestones = [25, 50, 75, 90, 100];
    
    for (const milestone of milestones) {
      const key = `milestone:${projectId}:${milestone}`;
      const alreadyReached = await this.redis.get(key);
      
      if (!alreadyReached && progress.overall >= milestone) {
        // ë§ˆì¼ìŠ¤í†¤ ë„ë‹¬
        await this.redis.set(key, '1');
        
        // ì•Œë¦¼ ë°œì†¡
        await this.notificationService.send({
          type: 'milestone_reached',
          projectId,
          milestone,
          progress: progress.overall,
          message: `Project reached ${milestone}% completion!`
        });
        
        // ì´ë²¤íŠ¸ ë¡œê¹…
        await this.logMilestone(projectId, milestone, progress);
      }
    }
  }
}
```

### 4.3 ì´ìƒ íƒì§€ ì‹œìŠ¤í…œ

```typescript
export class AnomalyDetector {
  private threshold: AnomalyThresholds;
  private mlModel: TensorFlowModel;
  
  /**
   * í†µê³„ì  ì´ìƒì¹˜ íƒì§€ (Z-Score)
   */
  async detectStatistical(event: EvaluationEvent): Promise<Anomaly | null> {
    const historical = await this.getHistoricalData(event.type, event.projectId);
    
    if (historical.length < 30) {
      return null; // ì¶©ë¶„í•œ ë°ì´í„° ì—†ìŒ
    }
    
    const values = historical.map(h => h.value);
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    const std = Math.sqrt(
      values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length
    );
    
    const zScore = Math.abs((event.value - mean) / std);
    
    if (zScore > 3) {
      return {
        type: 'statistical',
        severity: zScore > 4 ? 'high' : 'medium',
        metric: event.type,
        value: event.value,
        expected: mean,
        deviation: zScore,
        message: `Unusual value detected: ${event.value} (Z-score: ${zScore.toFixed(2)})`
      };
    }
    
    return null;
  }
  
  /**
   * íŒ¨í„´ ê¸°ë°˜ ì´ìƒ íƒì§€
   */
  async detectPattern(event: EvaluationEvent): Promise<Anomaly | null> {
    const patterns = await this.loadPatterns(event.projectId);
    
    for (const pattern of patterns) {
      if (this.matchesPattern(event, pattern)) {
        return {
          type: 'pattern',
          severity: pattern.severity,
          metric: event.type,
          pattern: pattern.name,
          message: pattern.description
        };
      }
    }
    
    return null;
  }
  
  /**
   * ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ì´ìƒ íƒì§€
   */
  async detectML(event: EvaluationEvent): Promise<Anomaly | null> {
    // íŠ¹ì§• ì¶”ì¶œ
    const features = await this.extractFeatures(event);
    
    // ëª¨ë¸ ì˜ˆì¸¡
    const prediction = await this.mlModel.predict(features);
    
    if (prediction.isAnomaly && prediction.confidence > 0.8) {
      return {
        type: 'ml',
        severity: prediction.confidence > 0.9 ? 'high' : 'medium',
        metric: event.type,
        confidence: prediction.confidence,
        message: `ML model detected anomaly with ${(prediction.confidence * 100).toFixed(1)}% confidence`
      };
    }
    
    return null;
  }
  
  /**
   * ê·œì¹™ ê¸°ë°˜ íƒì§€
   */
  async checkRules(event: EvaluationEvent): Promise<Anomaly[]> {
    const anomalies: Anomaly[] = [];
    const rules = await this.loadRules(event.projectId);
    
    for (const rule of rules) {
      if (await this.evaluateRule(event, rule)) {
        anomalies.push({
          type: 'rule',
          severity: rule.severity,
          metric: event.type,
          rule: rule.name,
          message: rule.message
        });
      }
    }
    
    return anomalies;
  }
  
  /**
   * íŠ¹ì§• ì¶”ì¶œ
   */
  private async extractFeatures(event: EvaluationEvent): Promise<number[]> {
    const features: number[] = [];
    
    // ì‹œê°„ íŠ¹ì§•
    const hour = new Date(event.timestamp).getHours();
    const dayOfWeek = new Date(event.timestamp).getDay();
    features.push(hour, dayOfWeek);
    
    // ë¹ˆë„ íŠ¹ì§•
    const recentCount = await this.getRecentEventCount(event.evaluatorId, 3600);
    const avgInterval = await this.getAverageInterval(event.evaluatorId);
    features.push(recentCount, avgInterval);
    
    // ê°’ íŠ¹ì§•
    features.push(event.value || 0);
    
    // ì»¨í…ìŠ¤íŠ¸ íŠ¹ì§•
    const sessionDuration = await this.getSessionDuration(event.sessionId);
    const completionRate = await this.getCompletionRate(event.evaluatorId);
    features.push(sessionDuration, completionRate);
    
    return features;
  }
  
  /**
   * ì´ìƒ íŒ¨í„´ ì •ì˜
   */
  private patterns: AnomalyPattern[] = [
    {
      name: 'rapid_submission',
      description: 'Too many submissions in short time',
      severity: 'high',
      condition: (event) => event.rate > 10 // 10 per minute
    },
    {
      name: 'inconsistent_timing',
      description: 'Unusual evaluation timing pattern',
      severity: 'medium',
      condition: (event) => event.timeDeviation > 2
    },
    {
      name: 'extreme_values',
      description: 'Extreme comparison values detected',
      severity: 'high',
      condition: (event) => event.value === 9 || event.value === 1/9
    }
  ];
}
```

---

## 5. ëŒ€ì‹œë³´ë“œ ì»´í¬ë„ŒíŠ¸

### 5.1 ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ UI

```typescript
export class RealtimeDashboard extends React.Component<DashboardProps, DashboardState> {
  private websocket: WebSocket;
  private chartUpdateInterval: NodeJS.Timer;
  
  componentDidMount() {
    this.initializeWebSocket();
    this.loadInitialData();
    this.startPeriodicUpdates();
  }
  
  /**
   * WebSocket ì´ˆê¸°í™”
   */
  private initializeWebSocket(): void {
    const wsUrl = `wss://${config.wsHost}/monitoring/${this.props.projectId}`;
    
    this.websocket = new WebSocket(wsUrl);
    
    this.websocket.onopen = () => {
      console.log('Monitoring WebSocket connected');
      this.setState({ connectionStatus: 'connected' });
    };
    
    this.websocket.onmessage = (event) => {
      const update = JSON.parse(event.data);
      this.handleRealtimeUpdate(update);
    };
    
    this.websocket.onerror = (error) => {
      console.error('WebSocket error:', error);
      this.setState({ connectionStatus: 'error' });
    };
    
    this.websocket.onclose = () => {
      console.log('WebSocket disconnected, reconnecting...');
      this.setState({ connectionStatus: 'disconnected' });
      setTimeout(() => this.initializeWebSocket(), 5000);
    };
  }
  
  /**
   * ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì²˜ë¦¬
   */
  private handleRealtimeUpdate(update: RealtimeUpdate): void {
    switch (update.type) {
      case 'progress_update':
        this.updateProgressMetrics(update.data);
        break;
        
      case 'evaluator_activity':
        this.updateEvaluatorStatus(update.data);
        break;
        
      case 'consistency_check':
        this.updateConsistencyMetrics(update.data);
        break;
        
      case 'anomaly_detected':
        this.showAnomalyAlert(update.data);
        break;
        
      case 'milestone_reached':
        this.celebrateMilestone(update.data);
        break;
    }
  }
  
  render() {
    return (
      <div className="realtime-dashboard">
        {/* ì—°ê²° ìƒíƒœ í‘œì‹œ */}
        <ConnectionStatus status={this.state.connectionStatus} />
        
        {/* í•µì‹¬ ì§€í‘œ ì¹´ë“œ */}
        <div className="metrics-grid">
          <MetricCard
            title="Active Evaluators"
            value={this.state.activeEvaluators}
            trend={this.state.evaluatorTrend}
            icon={<UserIcon />}
            color="blue"
          />
          
          <MetricCard
            title="Overall Progress"
            value={`${this.state.overallProgress}%`}
            trend={this.state.progressTrend}
            icon={<ProgressIcon />}
            color="green"
          />
          
          <MetricCard
            title="Avg Consistency"
            value={this.state.avgConsistency.toFixed(3)}
            trend={this.state.consistencyTrend}
            icon={<CheckIcon />}
            color={this.state.avgConsistency < 0.1 ? 'green' : 'orange'}
          />
          
          <MetricCard
            title="Completion ETA"
            value={this.formatETA(this.state.estimatedCompletion)}
            icon={<ClockIcon />}
            color="purple"
          />
        </div>
        
        {/* ì‹¤ì‹œê°„ ì°¨íŠ¸ */}
        <div className="charts-container">
          <RealtimeChart
            title="Evaluation Progress"
            data={this.state.progressHistory}
            type="area"
            streaming={true}
          />
          
          <RealtimeChart
            title="Active Users"
            data={this.state.activeUsersHistory}
            type="line"
            streaming={true}
          />
          
          <HeatmapChart
            title="Activity Heatmap"
            data={this.state.activityHeatmap}
            xAxis="Hour"
            yAxis="Day"
          />
        </div>
        
        {/* í‰ê°€ì í…Œì´ë¸” */}
        <EvaluatorTable
          evaluators={this.state.evaluators}
          onSort={this.handleSort}
          onFilter={this.handleFilter}
        />
        
        {/* ì•Œë¦¼ íŒ¨ë„ */}
        <NotificationPanel
          notifications={this.state.notifications}
          onDismiss={this.dismissNotification}
        />
      </div>
    );
  }
}
```

### 5.2 ì°¨íŠ¸ ì»´í¬ë„ŒíŠ¸

```typescript
export class RealtimeChart extends React.Component<ChartProps> {
  private chart: Chart;
  private dataBuffer: ChartData[] = [];
  private updateInterval: NodeJS.Timer;
  
  componentDidMount() {
    this.initializeChart();
    
    if (this.props.streaming) {
      this.startStreaming();
    }
  }
  
  /**
   * ì°¨íŠ¸ ì´ˆê¸°í™”
   */
  private initializeChart(): void {
    const ctx = this.canvasRef.current?.getContext('2d');
    
    this.chart = new Chart(ctx, {
      type: this.props.type,
      data: {
        datasets: [{
          label: this.props.title,
          data: this.props.data,
          borderColor: this.props.color || 'rgb(75, 192, 192)',
          backgroundColor: this.props.color 
            ? `${this.props.color}33` 
            : 'rgba(75, 192, 192, 0.2)',
          tension: 0.4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            type: 'time',
            time: {
              displayFormats: {
                minute: 'HH:mm',
                hour: 'HH:mm'
              }
            }
          },
          y: {
            beginAtZero: true,
            max: this.props.maxY
          }
        },
        plugins: {
          streaming: this.props.streaming ? {
            duration: 20000, // 20 seconds of data
            refresh: 1000, // refresh every second
            delay: 1000,
            onRefresh: (chart) => this.onChartRefresh(chart)
          } : undefined
        }
      }
    });
  }
  
  /**
   * ìŠ¤íŠ¸ë¦¬ë° ì—…ë°ì´íŠ¸
   */
  private onChartRefresh(chart: Chart): void {
    // ë²„í¼ì—ì„œ ìƒˆ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
    while (this.dataBuffer.length > 0) {
      const data = this.dataBuffer.shift()!;
      chart.data.datasets[0].data.push({
        x: data.timestamp,
        y: data.value
      });
    }
    
    // ì˜¤ë˜ëœ ë°ì´í„° ì œê±°
    const cutoff = Date.now() - 20000;
    chart.data.datasets[0].data = chart.data.datasets[0].data.filter(
      (point: any) => point.x > cutoff
    );
  }
  
  /**
   * ìƒˆ ë°ì´í„° ì¶”ê°€
   */
  public addDataPoint(value: number, timestamp: Date = new Date()): void {
    this.dataBuffer.push({ value, timestamp });
    
    if (!this.props.streaming) {
      this.chart.data.datasets[0].data.push({
        x: timestamp,
        y: value
      });
      this.chart.update('none'); // No animation for real-time
    }
  }
}
```

---

## 6. ì•Œë¦¼ ì‹œìŠ¤í…œ

### 6.1 ì•Œë¦¼ ì—”ì§„

```typescript
export class NotificationEngine {
  private emailService: EmailService;
  private pushService: PushNotificationService;
  private smsService: SMSService;
  private inAppService: InAppNotificationService;
  
  /**
   * ì•Œë¦¼ ë°œì†¡ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜
   */
  async sendNotification(notification: Notification): Promise<void> {
    // 1. ìš°ì„ ìˆœìœ„ í™•ì¸
    if (notification.priority === 'critical') {
      await this.sendImmediate(notification);
    } else {
      await this.queueNotification(notification);
    }
  }
  
  /**
   * ì¦‰ì‹œ ë°œì†¡
   */
  private async sendImmediate(notification: Notification): Promise<void> {
    const promises: Promise<any>[] = [];
    
    // ëª¨ë“  ì±„ë„ë¡œ ë™ì‹œ ë°œì†¡
    if (notification.channels.includes('email')) {
      promises.push(this.emailService.send(notification));
    }
    
    if (notification.channels.includes('push')) {
      promises.push(this.pushService.send(notification));
    }
    
    if (notification.channels.includes('sms') && notification.priority === 'critical') {
      promises.push(this.smsService.send(notification));
    }
    
    if (notification.channels.includes('in_app')) {
      promises.push(this.inAppService.send(notification));
    }
    
    const results = await Promise.allSettled(promises);
    
    // ì‹¤íŒ¨í•œ ë°œì†¡ ì¬ì‹œë„
    const failed = results.filter(r => r.status === 'rejected');
    if (failed.length > 0) {
      await this.retryFailed(notification, failed);
    }
  }
  
  /**
   * ì•Œë¦¼ ê·œì¹™ ì •ì˜
   */
  private rules: NotificationRule[] = [
    {
      trigger: 'consistency_low',
      condition: (data) => data.consistencyRatio > 0.15,
      template: {
        title: 'Low Consistency Detected',
        message: 'Consistency ratio is {consistencyRatio}. Please review your evaluations.',
        priority: 'high',
        channels: ['email', 'in_app']
      }
    },
    {
      trigger: 'evaluation_complete',
      condition: (data) => data.progress === 100,
      template: {
        title: 'Evaluation Completed',
        message: 'Your evaluation for {projectName} is complete!',
        priority: 'medium',
        channels: ['email', 'push']
      }
    },
    {
      trigger: 'deadline_approaching',
      condition: (data) => data.hoursRemaining <= 24,
      template: {
        title: 'Deadline Approaching',
        message: 'Only {hoursRemaining} hours left to complete your evaluation.',
        priority: 'high',
        channels: ['email', 'push', 'in_app']
      }
    },
    {
      trigger: 'anomaly_detected',
      condition: (data) => data.anomaly.severity === 'high',
      template: {
        title: 'Unusual Activity Detected',
        message: 'System detected unusual activity: {anomaly.message}',
        priority: 'critical',
        channels: ['email', 'sms', 'push']
      }
    }
  ];
}
```

---

## 7. ì„±ëŠ¥ ìµœì í™”

### 7.1 ë°ì´í„° ì§‘ê³„ ìµœì í™”

```typescript
export class DataAggregator {
  private cache: LRUCache<string, any>;
  private aggregationWorkers: Worker[];
  
  /**
   * ì‹œê³„ì—´ ë°ì´í„° ì§‘ê³„
   */
  async aggregateTimeSeries(
    projectId: string,
    metric: string,
    interval: TimeInterval
  ): Promise<TimeSeriesData> {
    const cacheKey = `ts:${projectId}:${metric}:${interval}`;
    
    // ìºì‹œ í™•ì¸
    const cached = this.cache.get(cacheKey);
    if (cached && cached.timestamp > Date.now() - 60000) {
      return cached.data;
    }
    
    // TimescaleDB í•˜ì´í¼í…Œì´ë¸” ì¿¼ë¦¬
    const query = `
      SELECT 
        time_bucket($1, timestamp) as bucket,
        AVG(metric_value) as avg_value,
        MAX(metric_value) as max_value,
        MIN(metric_value) as min_value,
        COUNT(*) as count
      FROM realtime_metrics
      WHERE project_id = $2
        AND metric_name = $3
        AND timestamp >= NOW() - INTERVAL '1 day'
      GROUP BY bucket
      ORDER BY bucket DESC
    `;
    
    const result = await this.db.query(query, [interval, projectId, metric]);
    
    // ìºì‹œ ì €ì¥
    this.cache.set(cacheKey, {
      data: result,
      timestamp: Date.now()
    });
    
    return result;
  }
  
  /**
   * ì‹¤ì‹œê°„ ìœˆë„ìš° ì§‘ê³„
   */
  async windowAggregate(
    stream: Observable<Event>,
    windowSize: number,
    aggregateFunc: AggregateFunction
  ): Promise<Observable<AggregateResult>> {
    return stream.pipe(
      bufferTime(windowSize),
      map(events => aggregateFunc(events)),
      filter(result => result !== null)
    );
  }
}
```

### 7.2 WebSocket ì—°ê²° ê´€ë¦¬

```typescript
export class WebSocketManager {
  private connections: Map<string, WebSocketConnection>;
  private connectionPool: ConnectionPool;
  
  /**
   * ì—°ê²° í’€ ê´€ë¦¬
   */
  async manageConnectionPool(): Promise<void> {
    setInterval(() => {
      // ìœ íœ´ ì—°ê²° ì •ë¦¬
      for (const [id, conn] of this.connections) {
        if (conn.idleTime > 300000) { // 5ë¶„
          this.closeConnection(id);
        }
      }
      
      // ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
      this.monitorConnections();
      
      // ë¶€í•˜ ë¶„ì‚°
      this.balanceLoad();
    }, 30000);
  }
  
  /**
   * ë©”ì‹œì§€ ë°°ì¹­
   */
  async batchMessages(
    messages: Message[],
    targetConnection: string
  ): Promise<void> {
    const batch: MessageBatch = {
      id: generateUUID(),
      messages,
      timestamp: new Date(),
      compressed: messages.length > 10
    };
    
    if (batch.compressed) {
      batch.data = await this.compress(messages);
    }
    
    await this.sendBatch(targetConnection, batch);
  }
}
```

---

## 8. ëª¨ë‹ˆí„°ë§ ë©”íŠ¸ë¦­

### 8.1 Prometheus ë©”íŠ¸ë¦­ ì •ì˜

```yaml
# prometheus_rules.yml
groups:
  - name: ahp_monitoring
    interval: 30s
    rules:
      - record: ahp:evaluations:rate5m
        expr: rate(evaluations_completed_total[5m])
      
      - record: ahp:consistency:avg
        expr: avg(consistency_ratio) by (project_id)
      
      - record: ahp:response_time:p95
        expr: histogram_quantile(0.95, response_time_bucket)
      
      - alert: HighInconsistencyRate
        expr: ahp:consistency:avg > 0.15
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High inconsistency rate detected"
      
      - alert: SlowResponseTime
        expr: ahp:response_time:p95 > 2000
        for: 10m
        labels:
          severity: critical
        annotations:
          summary: "Response time exceeding threshold"
```

### 8.2 Grafana ëŒ€ì‹œë³´ë“œ ì„¤ì •

```json
{
  "dashboard": {
    "title": "AHP Real-time Monitoring",
    "panels": [
      {
        "id": 1,
        "title": "Evaluation Progress",
        "type": "graph",
        "targets": [
          {
            "expr": "ahp:evaluations:rate5m",
            "legendFormat": "Evaluations/min"
          }
        ]
      },
      {
        "id": 2,
        "title": "Active Users",
        "type": "stat",
        "targets": [
          {
            "expr": "sum(active_evaluators)"
          }
        ]
      },
      {
        "id": 3,
        "title": "Consistency Distribution",
        "type": "histogram",
        "targets": [
          {
            "expr": "consistency_ratio",
            "format": "heatmap"
          }
        ]
      }
    ]
  }
}
```

---

## 9. êµ¬í˜„ ê°€ì´ë“œë¼ì¸

### 9.1 Sonnet êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸

```markdown
## Backend Implementation
- [ ] WebSocket ì„œë²„ ì„¤ì •
- [ ] Redis Streams êµ¬ì„±
- [ ] ì´ë²¤íŠ¸ í”„ë¡œì„¸ì„œ êµ¬í˜„
- [ ] ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸° êµ¬í˜„
- [ ] ì•Œë¦¼ í ì‹œìŠ¤í…œ

## Frontend Implementation
- [ ] ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ ì»´í¬ë„ŒíŠ¸
- [ ] WebSocket í´ë¼ì´ì–¸íŠ¸
- [ ] ì°¨íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ í†µí•©
- [ ] ì•Œë¦¼ UI ì»´í¬ë„ŒíŠ¸
- [ ] ì§„í–‰ë¥  í‘œì‹œ ìœ„ì ¯

## DevOps
- [ ] Prometheus ì„¤ì •
- [ ] Grafana ëŒ€ì‹œë³´ë“œ
- [ ] ELK Stack êµ¬ì„±
- [ ] ì•Œë¦¼ ê·œì¹™ ì„¤ì •
```

---

## 10. ë§ˆë¬´ë¦¬

ì‹¤ì‹œê°„ í‰ê°€ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì„¤ê³„ë¥¼ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.
WebSocket ê¸°ë°˜ ì‹¤ì‹œê°„ í†µì‹ , ì´ìƒ íƒì§€, ì„±ëŠ¥ ìµœì í™” ë“±
í¬ê´„ì ì¸ ëª¨ë‹ˆí„°ë§ ì†”ë£¨ì…˜ì„ ì œê³µí•©ë‹ˆë‹¤.

**ë¬¸ì„œ ì‘ì„± ì™„ë£Œ**: 2024-11-11
**ì´ ì„¤ê³„ ë¬¸ì„œ**: 5ê°œ ì™„ì„±