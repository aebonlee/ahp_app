# Phase 2a: 평가자 초대 시스템 설계 문서

**문서 버전**: v1.0
**작성일**: 2026-02-18
**작성자**: Claude Opus 4.6
**대상 구현자**: Claude Sonnet (백엔드), Claude Opus (프론트엔드)
**프로젝트**: Multi-Layer AHP Decision Support Platform

---

## 0. 현재 상태 분석 및 구현 범위

### 이미 구현된 것 (40%)

| 구성 요소 | 파일 경로 | 상태 |
|-----------|-----------|------|
| `EvaluatorInvitationHandler` | `src/components/evaluation/EvaluatorInvitationHandler.tsx` | 토큰 기반 수락 UI 존재 (백엔드 미연결) |
| `EvaluatorWorkflow` | `src/components/evaluator/EvaluatorWorkflow.tsx` | `?eval=PROJECT_ID&token=TOKEN` URL 파라미터 동작 |
| `InviteEvaluators` | `src/components/evaluation/assignment/InviteEvaluators.tsx` | 이메일 입력 UI 존재 (발송 로직 미구현) |
| `EvaluatorAssignmentDashboard` | `src/components/evaluation/assignment/EvaluatorAssignmentDashboard.tsx` | 탭 기반 관리 대시보드 셸 |
| `InvitationHistory` | `src/components/evaluation/assignment/InvitationHistory.tsx` | 기록 조회 UI (API 미연결) |
| `EmailTemplateManager` | `src/components/evaluation/assignment/EmailTemplateManager.tsx` | 템플릿 관리 UI (API 미연결) |
| Django `EvaluationInvitation` 모델 | `backend/invitations/models.py` | 모델 정의 완료 (마이그레이션/뷰 미확인) |
| Django `ParticipantPermission` 모델 | `backend/invitations/models.py` | 역할 기반 권한 모델 정의 완료 |
| Django `InvitationActivity` 모델 | `backend/invitations/models.py` | 활동 로그 모델 정의 완료 |

### 이번 Phase에서 구현할 것 (나머지 60%)

1. **JWT 기반 초대 토큰 생성/검증/만료/재발송 백엔드 로직**
2. **이메일 발송 시스템** (Django + SendGrid)
3. **초대 상태 머신** (상태 전환 API)
4. **관리자용 초대 관리 UI** (`EvaluatorInvitationManager` 컴포넌트)
5. **`useEvaluatorInvite` 커스텀 Hook**
6. **권한 검증 미들웨어** (초대된 평가자만 해당 프로젝트 접근)

---

## 1. JWT 기반 초대 토큰 시스템

### 1.1 토큰 구조

초대 토큰은 일반 인증 JWT와 분리된 **전용 토큰**으로 설계한다. 기존 `authService.ts`의 JWT(`ahp_access_token`)와 혼동을 방지하기 위해 별도의 signing key를 사용한다.

```python
# Django settings.py 에 추가
INVITATION_TOKEN_SECRET = os.environ.get('INVITATION_TOKEN_SECRET', 'inv-secret-change-me')
INVITATION_TOKEN_ALGORITHM = 'HS256'
```

**JWT Payload 구조**:

```python
# backend/invitations/token_service.py

import jwt
import hashlib
from datetime import datetime, timedelta
from django.conf import settings
from django.utils import timezone


class InvitationTokenService:
    """초대 토큰 생성 및 검증 서비스"""

    @staticmethod
    def generate_token(
        invitation_id: str,
        project_id: str,
        evaluator_email: str,
        invited_by: str,
        expires_days: int = 7
    ) -> str:
        """초대 토큰 생성"""
        now = datetime.utcnow()
        payload = {
            # 표준 JWT 클레임
            'iat': now,                                      # 발급 시각
            'exp': now + timedelta(days=expires_days),        # 만료 시각
            'nbf': now,                                      # 유효 시작 시각

            # 커스텀 클레임
            'inv_id': str(invitation_id),                    # 초대 레코드 ID (UUID)
            'pid': str(project_id),                          # 프로젝트 ID (UUID)
            'email': evaluator_email,                        # 피초대자 이메일
            'inviter': str(invited_by),                      # 초대자 user_id
            'typ': 'evaluation_invitation',                  # 토큰 타입 식별자
            'ver': 1,                                        # 토큰 버전 (향후 마이그레이션용)
        }

        token = jwt.encode(
            payload,
            settings.INVITATION_TOKEN_SECRET,
            algorithm=settings.INVITATION_TOKEN_ALGORITHM
        )
        return token

    @staticmethod
    def verify_token(token: str) -> dict:
        """
        토큰 검증 및 payload 반환.

        Raises:
            jwt.ExpiredSignatureError: 토큰 만료
            jwt.InvalidTokenError: 토큰 무효
            ValueError: 토큰 타입 불일치
        """
        payload = jwt.decode(
            token,
            settings.INVITATION_TOKEN_SECRET,
            algorithms=[settings.INVITATION_TOKEN_ALGORITHM]
        )

        # 토큰 타입 확인
        if payload.get('typ') != 'evaluation_invitation':
            raise ValueError('Invalid token type: not an invitation token')

        return payload

    @staticmethod
    def get_token_hash(token: str) -> str:
        """토큰의 SHA-256 해시 (DB 조회용)"""
        return hashlib.sha256(token.encode()).hexdigest()
```

### 1.2 토큰 만료 시간 권장값

| 시나리오 | 만료 기간 | 근거 |
|----------|-----------|------|
| 일반 초대 | **7일** (기본값) | 대부분의 평가자가 1주 내 응답 |
| 긴급 평가 | **3일** | 마감이 촉박한 경우 |
| 장기 프로젝트 | **30일** | 다수 평가자 참여 프로젝트 |
| 최대 허용 | **90일** | 보안상 상한선 |

**프론트엔드에서 선택 가능한 옵션** (기존 `InviteEvaluators.tsx`의 `expiryDays` 상태와 호환):

```typescript
const EXPIRY_OPTIONS = [
  { value: 3, label: '3일 (긴급)' },
  { value: 7, label: '7일 (기본)' },
  { value: 14, label: '14일' },
  { value: 30, label: '30일' },
  { value: 60, label: '60일' },
  { value: 90, label: '90일 (최대)' },
] as const;
```

### 1.3 토큰 재발송 로직

```python
# backend/invitations/services.py

from django.utils import timezone
from datetime import timedelta
from .models import EvaluationInvitation, InvitationActivity


class InvitationService:
    """초대 비즈니스 로직 서비스"""

    # 재발송 제한 설정
    MAX_REMINDERS = 3              # 최대 리마인더 횟수
    REMINDER_COOLDOWN_HOURS = 24   # 리마인더 간 최소 간격 (시간)
    MAX_RESENDS = 5                # 최대 재발송 횟수 (초기 발송 포함)
    RESEND_COOLDOWN_MINUTES = 10   # 재발송 간 최소 간격 (분)

    @classmethod
    def can_resend(cls, invitation: EvaluationInvitation) -> tuple[bool, str]:
        """
        재발송 가능 여부 확인.

        Returns:
            (가능 여부, 불가 사유)
        """
        if invitation.status != 'pending':
            return False, f'초대 상태가 "{invitation.get_status_display()}"이므로 재발송할 수 없습니다.'

        if invitation.is_expired():
            return False, '만료된 초대입니다. 새로운 초대를 생성하세요.'

        if invitation.reminder_count >= cls.MAX_REMINDERS:
            return False, f'리마인더 최대 횟수({cls.MAX_REMINDERS}회)를 초과했습니다.'

        if invitation.last_reminder_at:
            time_since_last = timezone.now() - invitation.last_reminder_at
            if time_since_last < timedelta(hours=cls.REMINDER_COOLDOWN_HOURS):
                remaining = timedelta(hours=cls.REMINDER_COOLDOWN_HOURS) - time_since_last
                hours = int(remaining.total_seconds() // 3600)
                minutes = int((remaining.total_seconds() % 3600) // 60)
                return False, f'쿨다운 중입니다. {hours}시간 {minutes}분 후 재발송 가능합니다.'

        return True, ''

    @classmethod
    def resend_invitation(cls, invitation: EvaluationInvitation, actor=None) -> bool:
        """
        초대 재발송 처리.
        토큰은 유지하되 리마인더 카운트를 증가시킨다.
        """
        can_send, reason = cls.can_resend(invitation)
        if not can_send:
            raise ValueError(reason)

        invitation.reminder_count += 1
        invitation.last_reminder_at = timezone.now()
        invitation.save(update_fields=['reminder_count', 'last_reminder_at'])

        # 활동 로그 기록
        InvitationActivity.objects.create(
            invitation=invitation,
            action='reminder_sent',
            actor=actor,
            metadata={
                'reminder_number': invitation.reminder_count,
                'sent_at': timezone.now().isoformat()
            }
        )

        return True

    @classmethod
    def regenerate_token(cls, invitation: EvaluationInvitation, new_expiry_days: int = 7):
        """
        만료된 초대의 토큰을 재생성.
        기존 토큰은 무효화되고 새 토큰이 발급된다.
        """
        from .token_service import InvitationTokenService

        if invitation.status not in ('pending', 'expired'):
            raise ValueError('수락/거절/철회된 초대의 토큰은 재생성할 수 없습니다.')

        new_token = InvitationTokenService.generate_token(
            invitation_id=str(invitation.id),
            project_id=str(invitation.project_id),
            evaluator_email=invitation.invitee_email,
            invited_by=str(invitation.inviter_id),
            expires_days=new_expiry_days
        )

        invitation.token = new_token
        invitation.token_hash = InvitationTokenService.get_token_hash(new_token)
        invitation.expires_at = timezone.now() + timedelta(days=new_expiry_days)
        invitation.status = 'pending'  # 만료 상태였다면 다시 pending으로
        invitation.reminder_count = 0  # 리마인더 카운트 리셋
        invitation.last_reminder_at = None
        invitation.save()

        return new_token
```

### 1.4 취소/무효화 메커니즘

```python
# backend/invitations/services.py (InvitationService 클래스에 추가)

    @classmethod
    def revoke_invitation(cls, invitation: EvaluationInvitation, actor=None, reason: str = ''):
        """초대 철회 (관리자가 수동으로 취소)"""
        if invitation.status not in ('pending',):
            raise ValueError(f'"{invitation.get_status_display()}" 상태의 초대는 철회할 수 없습니다.')

        invitation.status = 'revoked'
        invitation.revoked_at = timezone.now()
        invitation.save(update_fields=['status', 'revoked_at'])

        InvitationActivity.objects.create(
            invitation=invitation,
            action='revoked',
            actor=actor,
            metadata={'reason': reason}
        )

    @classmethod
    def expire_stale_invitations(cls):
        """
        만료된 초대들을 일괄 처리 (Cron Job / Celery Task).
        Render.com에서는 cron-job.org 또는 Django management command로 실행.
        """
        expired = EvaluationInvitation.objects.filter(
            status='pending',
            expires_at__lt=timezone.now()
        )
        count = expired.update(status='expired')
        return count
```

**토큰 무효화 전략**:

토큰 자체를 블랙리스트에 등록하는 방식 대신, DB의 `status` 필드를 확인하는 방식을 채택한다. JWT 토큰 검증 시 반드시 DB 조회를 수행하여 상태가 `pending`인 경우에만 유효한 것으로 처리한다.

```python
# 토큰 검증 시 DB 상태도 함께 확인하는 패턴
def validate_invitation_token(token: str) -> EvaluationInvitation:
    """토큰 + DB 상태 이중 검증"""
    # 1단계: JWT 서명 및 만료 검증
    payload = InvitationTokenService.verify_token(token)

    # 2단계: DB에서 초대 레코드 조회 및 상태 확인
    token_hash = InvitationTokenService.get_token_hash(token)
    try:
        invitation = EvaluationInvitation.objects.select_related(
            'project', 'inviter'
        ).get(
            token_hash=token_hash,
            status='pending'   # pending 상태만 유효
        )
    except EvaluationInvitation.DoesNotExist:
        raise ValueError('유효하지 않거나 이미 처리된 초대입니다.')

    # 3단계: 추가 만료 확인 (JWT exp와 DB expires_at 이중 확인)
    if invitation.is_expired():
        invitation.status = 'expired'
        invitation.save(update_fields=['status'])
        raise ValueError('만료된 초대입니다.')

    return invitation
```

---

## 2. 초대 상태 머신 (State Machine)

### 2.1 상태 전환 다이어그램

```
                       +-----------+
           생성 ------>|  pending   |
                       +-----+-----+
                             |
              +--------------+--------------+------------------+
              |              |              |                  |
        (수락 클릭)    (거절 클릭)    (만료시간 경과)      (관리자 철회)
              |              |              |                  |
              v              v              v                  v
        +-----------+  +-----------+  +-----------+     +-----------+
        | accepted  |  | declined  |  |  expired  |     |  revoked  |
        +-----------+  +-----------+  +-----+-----+     +-----------+
              |                             |
              |                             |
              v                       (토큰 재생성)
     ParticipantPermission                  |
        레코드 생성                          v
                                      +-----------+
                                      |  pending   | (새 토큰으로 복귀)
                                      +-----------+
```

### 2.2 상태 정의 및 전환 조건

| 현재 상태 | 전환 대상 | 트리거 조건 | 전환 후 처리 |
|-----------|-----------|-------------|-------------|
| `pending` | `accepted` | 평가자가 토큰 URL 클릭 후 수락 | `ParticipantPermission` 생성, `accepted_at` 기록, 평가 세션 시작 |
| `pending` | `declined` | 평가자가 거절 버튼 클릭 | `rejected_at` 기록, 관리자에게 알림 |
| `pending` | `expired` | `expires_at < now()` | 자동 배치 처리 또는 접근 시 실시간 갱신 |
| `pending` | `revoked` | 관리자가 초대 취소 | `revoked_at` 기록, 토큰 무효화 |
| `expired` | `pending` | 관리자가 토큰 재생성 | 새 토큰 발급, `expires_at` 갱신, `reminder_count` 리셋 |

**주의**: `accepted`, `declined`, `revoked` 상태는 **최종 상태**(terminal state)이다. 이 상태에서 다른 상태로의 전환은 불가능하다. 새로운 초대가 필요하면 새 `EvaluationInvitation` 레코드를 생성한다.

### 2.3 상태별 UI 표시 방식

```typescript
// src/components/evaluation/assignment/invitationStatusConfig.ts

export interface InvitationStatusConfig {
  label: string;
  color: string;         // Tailwind 색상 클래스
  bgColor: string;       // 배경 색상
  icon: string;          // Heroicons 아이콘 이름
  description: string;
  actions: ('resend' | 'revoke' | 'regenerate' | 'view_detail')[];
}

export const INVITATION_STATUS_MAP: Record<string, InvitationStatusConfig> = {
  pending: {
    label: '대기중',
    color: 'text-yellow-700',
    bgColor: 'bg-yellow-100',
    icon: 'ClockIcon',
    description: '평가자가 아직 초대에 응답하지 않았습니다.',
    actions: ['resend', 'revoke', 'view_detail'],
  },
  accepted: {
    label: '수락됨',
    color: 'text-green-700',
    bgColor: 'bg-green-100',
    icon: 'CheckCircleIcon',
    description: '평가자가 초대를 수락했습니다.',
    actions: ['view_detail'],
  },
  declined: {
    label: '거절됨',
    color: 'text-red-700',
    bgColor: 'bg-red-100',
    icon: 'XCircleIcon',
    description: '평가자가 초대를 거절했습니다.',
    actions: ['view_detail'],
  },
  expired: {
    label: '만료됨',
    color: 'text-gray-700',
    bgColor: 'bg-gray-100',
    icon: 'ExclamationCircleIcon',
    description: '초대 유효기간이 경과했습니다.',
    actions: ['regenerate', 'view_detail'],
  },
  revoked: {
    label: '철회됨',
    color: 'text-orange-700',
    bgColor: 'bg-orange-100',
    icon: 'NoSymbolIcon',
    description: '관리자가 초대를 철회했습니다.',
    actions: ['view_detail'],
  },
};
```

---

## 3. Django 백엔드 API 스펙

### 3.1 엔드포인트 목록

기존 API 구조(`/api/service/...`)에 맞추어 설계한다.

#### 3.1.1 초대 생성 (단건)

```
POST /api/service/invitations/
```

**Request Body**:
```json
{
  "project_id": "uuid-string",
  "invitee_email": "evaluator@example.com",
  "invitee_name": "홍길동",
  "role": "evaluator",
  "custom_message": "이 프로젝트 평가에 참여해주세요.",
  "expiry_days": 7
}
```

**Response (201 Created)**:
```json
{
  "id": "uuid-string",
  "project_id": "uuid-string",
  "project_title": "AHP 의사결정 프로젝트",
  "invitee_email": "evaluator@example.com",
  "invitee_name": "홍길동",
  "role": "evaluator",
  "status": "pending",
  "token": "eyJhbGciOiJIUzI1NiIs...",
  "invitation_url": "https://aebonlee.github.io/ahp_app/#/invitation?token=eyJhbGci...",
  "expires_at": "2026-02-25T00:00:00Z",
  "created_at": "2026-02-18T00:00:00Z",
  "email_sent": true
}
```

**에러 응답**:
- `400`: 이메일 형식 오류, 필수 필드 누락
- `409`: 동일 프로젝트에 대한 중복 pending 초대 존재

#### 3.1.2 대량 초대 발송

```
POST /api/service/invitations/bulk/
```

**Request Body**:
```json
{
  "project_id": "uuid-string",
  "evaluator_emails": [
    "user1@example.com",
    "user2@example.com",
    "user3@example.com"
  ],
  "custom_message": "AHP 평가에 참여해주세요.",
  "expiry_days": 7,
  "template_id": "uuid-or-null"
}
```

**Response (201 Created)**:
```json
{
  "total_requested": 3,
  "invitations_created": 2,
  "duplicates_skipped": 1,
  "errors": [],
  "invitations": [
    {
      "id": "uuid-1",
      "invitee_email": "user1@example.com",
      "status": "pending",
      "email_sent": true
    },
    {
      "id": "uuid-2",
      "invitee_email": "user2@example.com",
      "status": "pending",
      "email_sent": true
    }
  ],
  "skipped": [
    {
      "email": "user3@example.com",
      "reason": "이미 pending 상태의 초대가 존재합니다."
    }
  ]
}
```

#### 3.1.3 프로젝트별 초대 목록 조회

```
GET /api/service/invitations/?project_id={uuid}
```

**Query Parameters**:
- `project_id` (필수): 프로젝트 UUID
- `status` (선택): 상태 필터 (`pending`, `accepted`, `declined`, `expired`, `revoked`)
- `page` (선택): 페이지네이션
- `ordering` (선택): `-created_at` (기본), `status`, `invitee_email`

**Response (200 OK)**:
```json
{
  "count": 15,
  "next": null,
  "previous": null,
  "results": [
    {
      "id": "uuid-string",
      "invitee_email": "evaluator@example.com",
      "invitee_name": "홍길동",
      "role": "evaluator",
      "status": "pending",
      "expires_at": "2026-02-25T00:00:00Z",
      "reminder_count": 0,
      "last_reminder_at": null,
      "created_at": "2026-02-18T00:00:00Z",
      "accepted_at": null
    }
  ],
  "stats": {
    "total": 15,
    "pending": 5,
    "accepted": 8,
    "declined": 1,
    "expired": 1,
    "revoked": 0
  }
}
```

#### 3.1.4 초대 토큰 검증 (비인증 엔드포인트)

```
POST /api/service/invitations/verify-token/
```

**중요**: 이 엔드포인트는 **인증 불필요** (AllowAny). 초대 링크를 받은 외부 평가자가 로그인 없이 접근한다.

**Request Body**:
```json
{
  "token": "eyJhbGciOiJIUzI1NiIs..."
}
```

**Response (200 OK)**:
```json
{
  "valid": true,
  "invitation": {
    "id": "uuid-string",
    "project_id": "uuid-string",
    "project_name": "AHP 의사결정 프로젝트",
    "project_description": "프로젝트 설명...",
    "invitee_email": "evaluator@example.com",
    "invitee_name": "홍길동",
    "role": "evaluator",
    "inviter_name": "김관리자",
    "expires_at": "2026-02-25T00:00:00Z",
    "custom_message": "이 프로젝트 평가에 참여해주세요."
  }
}
```

**에러 응답**:
- `400`: 토큰 누락
- `404`: 토큰에 해당하는 초대 없음
- `410`: 만료된 초대 (`Gone`)
- `409`: 이미 수락/거절/철회된 초대 (`Conflict`)

#### 3.1.5 초대 수락

```
POST /api/service/invitations/{invitation_id}/accept/
```

**인증**: 선택적. 기존 계정이 있는 평가자는 JWT 토큰으로 인증. 없는 경우 초대 토큰만으로도 수락 가능 (게스트 계정 자동 생성).

**Request Body**:
```json
{
  "token": "eyJhbGciOiJIUzI1NiIs...",
  "evaluator_name": "홍길동",
  "create_account": false
}
```

**Response (200 OK)**:
```json
{
  "status": "accepted",
  "project_id": "uuid-string",
  "evaluator_id": "uuid-string",
  "evaluation_url": "/evaluation/uuid-string?token=session_token",
  "session_token": "temporary-session-jwt-for-evaluation",
  "message": "초대를 수락했습니다. 평가를 시작하세요."
}
```

#### 3.1.6 초대 거절

```
POST /api/service/invitations/{invitation_id}/decline/
```

**Request Body**:
```json
{
  "token": "eyJhbGciOiJIUzI1NiIs...",
  "reason": "일정상 참여가 어렵습니다."
}
```

**Response (200 OK)**:
```json
{
  "status": "declined",
  "message": "초대를 거절했습니다."
}
```

#### 3.1.7 초대 재발송 (리마인더)

```
POST /api/service/invitations/{invitation_id}/resend/
```

**인증**: 필수 (프로젝트 관리자만)

**Response (200 OK)**:
```json
{
  "success": true,
  "reminder_count": 2,
  "max_reminders": 3,
  "next_available_at": "2026-02-19T12:00:00Z",
  "message": "리마인더가 발송되었습니다."
}
```

#### 3.1.8 초대 철회

```
POST /api/service/invitations/{invitation_id}/revoke/
```

**인증**: 필수 (프로젝트 관리자만)

**Request Body**:
```json
{
  "reason": "평가 일정이 변경되었습니다."
}
```

**Response (200 OK)**:
```json
{
  "status": "revoked",
  "message": "초대가 철회되었습니다."
}
```

#### 3.1.9 만료 초대 토큰 재생성

```
POST /api/service/invitations/{invitation_id}/regenerate-token/
```

**인증**: 필수 (프로젝트 관리자만)

**Request Body**:
```json
{
  "expiry_days": 14
}
```

**Response (200 OK)**:
```json
{
  "success": true,
  "new_token": "eyJhbGciOiJIUzI1NiIs...",
  "new_invitation_url": "https://aebonlee.github.io/ahp_app/#/invitation?token=...",
  "expires_at": "2026-03-04T00:00:00Z",
  "email_sent": true,
  "message": "새 초대 토큰이 생성되어 발송되었습니다."
}
```

### 3.2 Django 모델 변경사항

기존 `backend/invitations/models.py`의 `EvaluationInvitation` 모델은 이미 충분한 필드를 보유하고 있다. 다음 사항만 추가/수정한다:

```python
# backend/invitations/models.py 수정사항

class EvaluationInvitation(models.Model):
    # ... (기존 필드 유지)

    # 추가 필드
    email_sent = models.BooleanField(default=False)          # 이메일 실제 발송 여부
    email_sent_at = models.DateTimeField(null=True, blank=True)
    email_error = models.TextField(blank=True)               # 이메일 발송 실패 시 에러 메시지

    # declined -> rejected 용어 통일 (기존 모델은 'rejected'를 사용)
    # 주의: 기존 STATUS_CHOICES의 'rejected'와 프론트엔드의 'declined'를 매핑

    decline_reason = models.TextField(blank=True, max_length=500)  # 거절 사유

    class Meta:
        # 기존 Meta 유지 + 추가 인덱스
        indexes = [
            # ... 기존 인덱스 유지
            models.Index(fields=['email_sent', 'status']),  # 미발송 초대 재발송 쿼리용
        ]
```

**마이그레이션 명령어**:
```bash
python manage.py makemigrations invitations
python manage.py migrate
```

### 3.3 Django ViewSet 구현

```python
# backend/invitations/views.py

from rest_framework import viewsets, status, permissions
from rest_framework.decorators import action
from rest_framework.response import Response
from django.shortcuts import get_object_or_404

from .models import EvaluationInvitation, InvitationActivity, ParticipantPermission
from .serializers import (
    EvaluationInvitationSerializer,
    CreateInvitationSerializer,
    BulkInvitationSerializer,
    VerifyTokenSerializer,
    AcceptInvitationSerializer,
    DeclineInvitationSerializer,
)
from .services import InvitationService
from .token_service import InvitationTokenService
from .email_service import InvitationEmailService


class IsProjectOwnerOrAdmin(permissions.BasePermission):
    """프로젝트 소유자 또는 관리자만 허용"""

    def has_object_permission(self, request, view, obj):
        project = obj.project if hasattr(obj, 'project') else obj
        return (
            request.user == project.owner or
            request.user.role in ('super_admin', 'service_admin') or
            ParticipantPermission.objects.filter(
                user=request.user,
                project=project,
                role__in=('owner', 'admin')
            ).exists()
        )


class InvitationViewSet(viewsets.ModelViewSet):
    """평가 초대 관리 ViewSet"""

    serializer_class = EvaluationInvitationSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        queryset = EvaluationInvitation.objects.select_related(
            'project', 'inviter'
        )

        project_id = self.request.query_params.get('project_id')
        if project_id:
            queryset = queryset.filter(project_id=project_id)

        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)

        return queryset

    def create(self, request):
        """단건 초대 생성 및 이메일 발송"""
        serializer = CreateInvitationSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        data = serializer.validated_data
        project = get_object_or_404(
            request.user.owned_projects.all() |
            request.user.participated_projects.all(),
            id=data['project_id']
        )

        # 중복 체크
        existing = EvaluationInvitation.objects.filter(
            project=project,
            invitee_email=data['invitee_email'],
            status='pending'
        ).first()

        if existing:
            return Response(
                {'error': '이미 대기중인 초대가 존재합니다.', 'invitation_id': str(existing.id)},
                status=status.HTTP_409_CONFLICT
            )

        # 초대 생성
        invitation = EvaluationInvitation(
            project=project,
            inviter=request.user,
            invitee_email=data['invitee_email'],
            invitee_name=data.get('invitee_name', ''),
            role=data.get('role', 'evaluator'),
            custom_message=data.get('custom_message', ''),
        )

        # 토큰 생성
        expiry_days = data.get('expiry_days', 7)
        token = InvitationTokenService.generate_token(
            invitation_id=str(invitation.id),
            project_id=str(project.id),
            evaluator_email=data['invitee_email'],
            invited_by=str(request.user.id),
            expires_days=expiry_days
        )
        invitation.token = token
        invitation.token_hash = InvitationTokenService.get_token_hash(token)
        invitation.save()

        # 이메일 발송
        email_sent = InvitationEmailService.send_invitation_email(invitation)

        # 활동 로그
        InvitationActivity.objects.create(
            invitation=invitation,
            action='created',
            actor=request.user
        )

        response_data = EvaluationInvitationSerializer(invitation).data
        response_data['token'] = token  # 생성 시에만 토큰 평문 반환
        response_data['email_sent'] = email_sent
        response_data['invitation_url'] = invitation.get_accept_url(
            base_url='https://aebonlee.github.io/ahp_app/#'
        )

        return Response(response_data, status=status.HTTP_201_CREATED)

    @action(detail=False, methods=['post'])
    def bulk(self, request):
        """대량 초대 발송"""
        serializer = BulkInvitationSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        data = serializer.validated_data
        project = get_object_or_404(
            request.user.owned_projects.all() |
            request.user.participated_projects.all(),
            id=data['project_id']
        )

        results = {
            'total_requested': len(data['evaluator_emails']),
            'invitations_created': 0,
            'duplicates_skipped': 0,
            'errors': [],
            'invitations': [],
            'skipped': []
        }

        for email in data['evaluator_emails']:
            # 중복 체크
            existing = EvaluationInvitation.objects.filter(
                project=project,
                invitee_email=email,
                status='pending'
            ).exists()

            if existing:
                results['duplicates_skipped'] += 1
                results['skipped'].append({
                    'email': email,
                    'reason': '이미 pending 상태의 초대가 존재합니다.'
                })
                continue

            try:
                invitation = EvaluationInvitation(
                    project=project,
                    inviter=request.user,
                    invitee_email=email,
                    role='evaluator',
                    custom_message=data.get('custom_message', ''),
                )

                expiry_days = data.get('expiry_days', 7)
                token = InvitationTokenService.generate_token(
                    invitation_id=str(invitation.id),
                    project_id=str(project.id),
                    evaluator_email=email,
                    invited_by=str(request.user.id),
                    expires_days=expiry_days
                )
                invitation.token = token
                invitation.token_hash = InvitationTokenService.get_token_hash(token)
                invitation.save()

                email_sent = InvitationEmailService.send_invitation_email(invitation)

                results['invitations_created'] += 1
                results['invitations'].append({
                    'id': str(invitation.id),
                    'invitee_email': email,
                    'status': 'pending',
                    'email_sent': email_sent
                })

            except Exception as e:
                results['errors'].append({
                    'email': email,
                    'error': str(e)
                })

        return Response(results, status=status.HTTP_201_CREATED)

    @action(detail=False, methods=['post'], permission_classes=[permissions.AllowAny])
    def verify_token(self, request):
        """토큰 검증 (비인증 엔드포인트)"""
        token = request.data.get('token')
        if not token:
            return Response(
                {'error': '토큰이 필요합니다.'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            # JWT 서명 검증
            payload = InvitationTokenService.verify_token(token)
        except Exception as e:
            error_msg = str(e)
            if 'expired' in error_msg.lower():
                return Response(
                    {'valid': False, 'error': '만료된 초대 토큰입니다.'},
                    status=status.HTTP_410_GONE
                )
            return Response(
                {'valid': False, 'error': '유효하지 않은 토큰입니다.'},
                status=status.HTTP_404_NOT_FOUND
            )

        # DB 조회
        token_hash = InvitationTokenService.get_token_hash(token)
        try:
            invitation = EvaluationInvitation.objects.select_related(
                'project', 'inviter'
            ).get(token_hash=token_hash)
        except EvaluationInvitation.DoesNotExist:
            return Response(
                {'valid': False, 'error': '초대를 찾을 수 없습니다.'},
                status=status.HTTP_404_NOT_FOUND
            )

        # 상태 확인
        if invitation.status != 'pending':
            status_messages = {
                'accepted': '이미 수락된 초대입니다.',
                'rejected': '이미 거절된 초대입니다.',
                'revoked': '철회된 초대입니다.',
                'expired': '만료된 초대입니다.'
            }
            return Response(
                {
                    'valid': False,
                    'error': status_messages.get(invitation.status, '처리된 초대입니다.'),
                    'status': invitation.status
                },
                status=status.HTTP_409_CONFLICT
            )

        if invitation.is_expired():
            invitation.status = 'expired'
            invitation.save(update_fields=['status'])
            return Response(
                {'valid': False, 'error': '만료된 초대입니다.'},
                status=status.HTTP_410_GONE
            )

        # 열람 활동 기록
        InvitationActivity.objects.create(
            invitation=invitation,
            action='viewed',
            actor_ip=request.META.get('REMOTE_ADDR'),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )

        return Response({
            'valid': True,
            'invitation': {
                'id': str(invitation.id),
                'project_id': str(invitation.project_id),
                'project_name': invitation.project.title,
                'project_description': invitation.project.description,
                'invitee_email': invitation.invitee_email,
                'invitee_name': invitation.invitee_name,
                'role': invitation.role,
                'inviter_name': (
                    f"{invitation.inviter.first_name} {invitation.inviter.last_name}".strip()
                    if invitation.inviter else '관리자'
                ),
                'expires_at': invitation.expires_at.isoformat(),
                'custom_message': invitation.custom_message,
            }
        })

    @action(detail=True, methods=['post'], permission_classes=[permissions.AllowAny])
    def accept(self, request, pk=None):
        """초대 수락"""
        invitation = self.get_object()
        token = request.data.get('token')

        # 토큰 검증
        token_hash = InvitationTokenService.get_token_hash(token) if token else ''
        if not token or invitation.token_hash != token_hash:
            return Response(
                {'error': '유효하지 않은 토큰입니다.'},
                status=status.HTTP_403_FORBIDDEN
            )

        if not invitation.can_accept():
            return Response(
                {'error': '수락할 수 없는 초대입니다.', 'status': invitation.status},
                status=status.HTTP_409_CONFLICT
            )

        # 상태 변경
        invitation.status = 'accepted'
        invitation.save()

        # ParticipantPermission 생성
        user = request.user if request.user.is_authenticated else None
        if user:
            ParticipantPermission.create_from_role(
                user=user,
                project=invitation.project,
                role=invitation.role,
                assigned_by=invitation.inviter
            )

        # 활동 로그
        InvitationActivity.objects.create(
            invitation=invitation,
            action='accepted',
            actor=user,
            actor_ip=request.META.get('REMOTE_ADDR'),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )

        return Response({
            'status': 'accepted',
            'project_id': str(invitation.project_id),
            'evaluator_id': str(user.id) if user else str(invitation.id),
            'evaluation_url': f'/evaluation/{invitation.project_id}',
            'message': '초대를 수락했습니다. 평가를 시작하세요.'
        })

    @action(detail=True, methods=['post'], permission_classes=[permissions.AllowAny])
    def decline(self, request, pk=None):
        """초대 거절"""
        invitation = self.get_object()
        token = request.data.get('token')

        token_hash = InvitationTokenService.get_token_hash(token) if token else ''
        if not token or invitation.token_hash != token_hash:
            return Response(
                {'error': '유효하지 않은 토큰입니다.'},
                status=status.HTTP_403_FORBIDDEN
            )

        if invitation.status != 'pending':
            return Response(
                {'error': '이미 처리된 초대입니다.'},
                status=status.HTTP_409_CONFLICT
            )

        invitation.status = 'rejected'
        invitation.decline_reason = request.data.get('reason', '')
        invitation.save()

        InvitationActivity.objects.create(
            invitation=invitation,
            action='rejected',
            actor_ip=request.META.get('REMOTE_ADDR'),
            metadata={'reason': request.data.get('reason', '')}
        )

        return Response({
            'status': 'declined',
            'message': '초대를 거절했습니다.'
        })

    @action(detail=True, methods=['post'])
    def resend(self, request, pk=None):
        """리마인더 재발송"""
        invitation = self.get_object()
        self.check_object_permissions(request, invitation)

        try:
            InvitationService.resend_invitation(invitation, actor=request.user)
            InvitationEmailService.send_reminder_email(invitation)
        except ValueError as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_429_TOO_MANY_REQUESTS
            )

        return Response({
            'success': True,
            'reminder_count': invitation.reminder_count,
            'max_reminders': InvitationService.MAX_REMINDERS,
            'message': '리마인더가 발송되었습니다.'
        })

    @action(detail=True, methods=['post'])
    def revoke(self, request, pk=None):
        """초대 철회"""
        invitation = self.get_object()
        self.check_object_permissions(request, invitation)

        reason = request.data.get('reason', '')

        try:
            InvitationService.revoke_invitation(invitation, actor=request.user, reason=reason)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

        return Response({
            'status': 'revoked',
            'message': '초대가 철회되었습니다.'
        })

    @action(detail=True, methods=['post'])
    def regenerate_token(self, request, pk=None):
        """만료 초대 토큰 재생성"""
        invitation = self.get_object()
        self.check_object_permissions(request, invitation)

        expiry_days = request.data.get('expiry_days', 7)

        try:
            new_token = InvitationService.regenerate_token(invitation, new_expiry_days=expiry_days)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

        email_sent = InvitationEmailService.send_invitation_email(invitation)

        return Response({
            'success': True,
            'new_invitation_url': invitation.get_accept_url(
                base_url='https://aebonlee.github.io/ahp_app/#'
            ),
            'expires_at': invitation.expires_at.isoformat(),
            'email_sent': email_sent,
            'message': '새 초대 토큰이 생성되어 발송되었습니다.'
        })
```

**URL 라우팅**:

```python
# backend/invitations/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import InvitationViewSet

router = DefaultRouter()
router.register(r'invitations', InvitationViewSet, basename='invitation')

urlpatterns = [
    path('', include(router.urls)),
]

# backend/urls.py (메인)
urlpatterns += [
    path('api/service/', include('invitations.urls')),
]
```

### 3.4 이메일 발송 서비스

**권장 라이브러리**: `django-anymail[sendgrid]`

Render.com 환경에서 SendGrid의 무료 티어 (100통/일)를 사용한다. `django-anymail`은 SendGrid, Mailgun, AWS SES 등 다양한 ESP를 일관된 인터페이스로 지원하므로, 향후 ESP 변경 시에도 코드 수정이 최소화된다.

```bash
pip install django-anymail[sendgrid]
```

```python
# backend/settings.py 추가

INSTALLED_APPS += ['anymail']

ANYMAIL = {
    'SENDGRID_API_KEY': os.environ.get('SENDGRID_API_KEY'),
}
EMAIL_BACKEND = 'anymail.backends.sendgrid.EmailBackend'
DEFAULT_FROM_EMAIL = 'AHP Platform <noreply@ahp-platform.com>'

# 프론트엔드 URL (초대 링크에 사용)
FRONTEND_BASE_URL = os.environ.get(
    'FRONTEND_BASE_URL',
    'https://aebonlee.github.io/ahp_app'
)
```

```python
# backend/invitations/email_service.py

from django.conf import settings
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.utils.html import strip_tags


class InvitationEmailService:
    """초대 이메일 발송 서비스"""

    @classmethod
    def send_invitation_email(cls, invitation) -> bool:
        """초대 이메일 발송"""
        try:
            invitation_url = invitation.get_accept_url(
                base_url=f"{settings.FRONTEND_BASE_URL}/#"
            )

            context = {
                'invitee_name': invitation.invitee_name or '평가자',
                'project_name': invitation.project.title,
                'inviter_name': (
                    f"{invitation.inviter.first_name} {invitation.inviter.last_name}".strip()
                    if invitation.inviter else '프로젝트 관리자'
                ),
                'invitation_url': invitation_url,
                'custom_message': invitation.custom_message,
                'expires_at': invitation.expires_at.strftime('%Y년 %m월 %d일'),
                'project_description': invitation.project.description,
            }

            subject = f'[AHP Platform] "{invitation.project.title}" 프로젝트 평가에 초대되었습니다'

            # HTML 이메일 본문
            html_message = cls._render_invitation_html(context)
            plain_message = strip_tags(html_message)

            send_mail(
                subject=subject,
                message=plain_message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[invitation.invitee_email],
                html_message=html_message,
                fail_silently=False,
            )

            invitation.email_sent = True
            invitation.email_sent_at = __import__('django.utils.timezone', fromlist=['timezone']).timezone.now()
            invitation.save(update_fields=['email_sent', 'email_sent_at'])

            return True

        except Exception as e:
            invitation.email_error = str(e)
            invitation.save(update_fields=['email_error'])
            return False

    @classmethod
    def send_reminder_email(cls, invitation) -> bool:
        """리마인더 이메일 발송"""
        try:
            invitation_url = invitation.get_accept_url(
                base_url=f"{settings.FRONTEND_BASE_URL}/#"
            )

            context = {
                'invitee_name': invitation.invitee_name or '평가자',
                'project_name': invitation.project.title,
                'invitation_url': invitation_url,
                'expires_at': invitation.expires_at.strftime('%Y년 %m월 %d일'),
                'reminder_number': invitation.reminder_count,
            }

            subject = f'[리마인더] "{invitation.project.title}" 평가 참여를 기다리고 있습니다'

            html_message = cls._render_reminder_html(context)
            plain_message = strip_tags(html_message)

            send_mail(
                subject=subject,
                message=plain_message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[invitation.invitee_email],
                html_message=html_message,
                fail_silently=False,
            )

            return True

        except Exception as e:
            return False

    @staticmethod
    def _render_invitation_html(context: dict) -> str:
        """초대 이메일 HTML 렌더링"""
        return f"""
        <!DOCTYPE html>
        <html>
        <head><meta charset="utf-8"></head>
        <body style="font-family: 'Apple SD Gothic Neo', 'Noto Sans KR', sans-serif;
                     max-width: 600px; margin: 0 auto; padding: 20px;
                     background-color: #f8fafc;">
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        padding: 30px; border-radius: 12px 12px 0 0; text-align: center;">
                <h1 style="color: white; margin: 0; font-size: 24px;">
                    AHP 평가 시스템
                </h1>
                <p style="color: rgba(255,255,255,0.9); margin-top: 8px;">
                    평가 참여 초대
                </p>
            </div>

            <div style="background: white; padding: 30px; border-radius: 0 0 12px 12px;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <p style="font-size: 16px; color: #374151;">
                    안녕하세요, <strong>{context['invitee_name']}</strong>님.
                </p>
                <p style="color: #6b7280; line-height: 1.6;">
                    <strong>{context['inviter_name']}</strong>님이
                    <strong>"{context['project_name']}"</strong> 프로젝트의 평가에
                    참여를 요청했습니다.
                </p>

                {f'<div style="background: #f0f9ff; border-left: 4px solid #3b82f6; padding: 12px 16px; margin: 16px 0; border-radius: 4px;"><p style="color: #1e40af; margin: 0; font-style: italic;">&ldquo;{context["custom_message"]}&rdquo;</p></div>' if context.get('custom_message') else ''}

                <div style="text-align: center; margin: 30px 0;">
                    <a href="{context['invitation_url']}"
                       style="display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                              color: white; text-decoration: none; padding: 14px 40px;
                              border-radius: 8px; font-size: 16px; font-weight: bold;">
                        평가 참여하기
                    </a>
                </div>

                <div style="background: #fef3c7; border-radius: 8px; padding: 12px 16px;
                            margin-top: 20px;">
                    <p style="color: #92400e; margin: 0; font-size: 14px;">
                        이 초대는 <strong>{context['expires_at']}</strong>까지 유효합니다.
                    </p>
                </div>

                <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 24px 0;">

                <p style="color: #9ca3af; font-size: 12px; text-align: center;">
                    이 메일은 AHP Decision Support Platform에서 발송되었습니다.<br>
                    본인이 요청하지 않은 메일이라면 무시해주세요.
                </p>
            </div>
        </body>
        </html>
        """

    @staticmethod
    def _render_reminder_html(context: dict) -> str:
        """리마인더 이메일 HTML 렌더링"""
        return f"""
        <!DOCTYPE html>
        <html>
        <head><meta charset="utf-8"></head>
        <body style="font-family: 'Apple SD Gothic Neo', 'Noto Sans KR', sans-serif;
                     max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="background: white; padding: 30px; border-radius: 12px;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <h2 style="color: #374151;">평가 참여 리마인더</h2>
                <p style="color: #6b7280; line-height: 1.6;">
                    안녕하세요, <strong>{context['invitee_name']}</strong>님.<br>
                    <strong>"{context['project_name']}"</strong> 프로젝트의 평가가
                    아직 완료되지 않았습니다.
                </p>

                <div style="text-align: center; margin: 24px 0;">
                    <a href="{context['invitation_url']}"
                       style="display: inline-block; background: #3b82f6;
                              color: white; text-decoration: none; padding: 12px 32px;
                              border-radius: 8px; font-weight: bold;">
                        지금 평가하기
                    </a>
                </div>

                <p style="color: #ef4444; font-size: 14px;">
                    마감일: {context['expires_at']}
                </p>
            </div>
        </body>
        </html>
        """
```

---

## 4. React 프론트엔드 구현 가이드

### 4.1 API 엔드포인트 설정 추가

기존 `src/config/api.ts`에 초대 관련 엔드포인트를 추가한다.

```typescript
// src/config/api.ts 에 추가

export const API_ENDPOINTS = {
  // ... 기존 엔드포인트 유지

  // Invitations (Phase 2a 추가)
  INVITATIONS: {
    LIST: '/api/service/invitations/',
    CREATE: '/api/service/invitations/',
    BULK: '/api/service/invitations/bulk/',
    VERIFY_TOKEN: '/api/service/invitations/verify_token/',
    ACCEPT: (id: string) => `/api/service/invitations/${id}/accept/`,
    DECLINE: (id: string) => `/api/service/invitations/${id}/decline/`,
    RESEND: (id: string) => `/api/service/invitations/${id}/resend/`,
    REVOKE: (id: string) => `/api/service/invitations/${id}/revoke/`,
    REGENERATE: (id: string) => `/api/service/invitations/${id}/regenerate_token/`,
    DETAIL: (id: string) => `/api/service/invitations/${id}/`,
  },
};
```

### 4.2 `useEvaluatorInvite` 커스텀 Hook

```typescript
// src/hooks/useEvaluatorInvite.ts

import { useState, useCallback } from 'react';
import { API_BASE_URL, API_ENDPOINTS } from '../config/api';
import authService from '../services/authService';

// ===== 타입 정의 =====

export interface InvitationData {
  id: string;
  project_id: string;
  project_name: string;
  project_description?: string;
  invitee_email: string;
  invitee_name: string;
  role: 'evaluator' | 'viewer' | 'admin';
  status: InvitationStatus;
  expires_at: string;
  reminder_count: number;
  last_reminder_at: string | null;
  created_at: string;
  accepted_at: string | null;
  inviter_name?: string;
  custom_message?: string;
}

export type InvitationStatus = 'pending' | 'accepted' | 'declined' | 'expired' | 'revoked';

export interface InvitationStats {
  total: number;
  pending: number;
  accepted: number;
  declined: number;
  expired: number;
  revoked: number;
}

export interface CreateInvitationParams {
  project_id: string;
  invitee_email: string;
  invitee_name?: string;
  role?: string;
  custom_message?: string;
  expiry_days?: number;
}

export interface BulkInvitationParams {
  project_id: string;
  evaluator_emails: string[];
  custom_message?: string;
  expiry_days?: number;
  template_id?: string;
}

export interface BulkInvitationResult {
  total_requested: number;
  invitations_created: number;
  duplicates_skipped: number;
  errors: Array<{ email: string; error: string }>;
  invitations: Array<{ id: string; invitee_email: string; status: string; email_sent: boolean }>;
  skipped: Array<{ email: string; reason: string }>;
}

export interface TokenVerificationResult {
  valid: boolean;
  invitation?: {
    id: string;
    project_id: string;
    project_name: string;
    project_description: string;
    invitee_email: string;
    invitee_name: string;
    role: string;
    inviter_name: string;
    expires_at: string;
    custom_message: string;
  };
  error?: string;
  status?: string;
}

// ===== Hook 구현 =====

interface UseEvaluatorInviteReturn {
  // 상태
  invitations: InvitationData[];
  stats: InvitationStats | null;
  loading: boolean;
  error: string | null;

  // 관리자 액션
  fetchInvitations: (projectId: string, statusFilter?: InvitationStatus) => Promise<void>;
  createInvitation: (params: CreateInvitationParams) => Promise<InvitationData | null>;
  createBulkInvitations: (params: BulkInvitationParams) => Promise<BulkInvitationResult | null>;
  resendInvitation: (invitationId: string) => Promise<boolean>;
  revokeInvitation: (invitationId: string, reason?: string) => Promise<boolean>;
  regenerateToken: (invitationId: string, expiryDays?: number) => Promise<boolean>;

  // 평가자 액션 (비인증)
  verifyToken: (token: string) => Promise<TokenVerificationResult>;
  acceptInvitation: (invitationId: string, token: string, name?: string) => Promise<{
    project_id: string;
    evaluator_id: string;
    evaluation_url: string;
  } | null>;
  declineInvitation: (invitationId: string, token: string, reason?: string) => Promise<boolean>;

  // 유틸리티
  clearError: () => void;
}

export function useEvaluatorInvite(): UseEvaluatorInviteReturn {
  const [invitations, setInvitations] = useState<InvitationData[]>([]);
  const [stats, setStats] = useState<InvitationStats | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 내부 헬퍼: 인증된 요청
  const authenticatedRequest = useCallback(async <T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> => {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      ...((options.headers as Record<string, string>) || {}),
    };

    const token = authService.getAccessToken();
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }

    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      credentials: 'include',
      ...options,
      headers,
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.error || errorData.detail || `HTTP ${response.status}`);
    }

    return response.json();
  }, []);

  // 내부 헬퍼: 비인증 요청 (토큰 검증, 수락/거절)
  const publicRequest = useCallback(async <T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> => {
    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...((options.headers as Record<string, string>) || {}),
      },
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.error || data.detail || `HTTP ${response.status}`);
    }

    return data;
  }, []);

  // ===== 관리자 액션 =====

  const fetchInvitations = useCallback(async (
    projectId: string,
    statusFilter?: InvitationStatus
  ) => {
    setLoading(true);
    setError(null);
    try {
      let url = `${API_ENDPOINTS.INVITATIONS.LIST}?project_id=${projectId}`;
      if (statusFilter) {
        url += `&status=${statusFilter}`;
      }

      const data = await authenticatedRequest<{
        results: InvitationData[];
        stats: InvitationStats;
      }>(url);

      setInvitations(data.results || []);
      setStats(data.stats || null);
    } catch (err: any) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [authenticatedRequest]);

  const createInvitation = useCallback(async (
    params: CreateInvitationParams
  ): Promise<InvitationData | null> => {
    setLoading(true);
    setError(null);
    try {
      const data = await authenticatedRequest<InvitationData>(
        API_ENDPOINTS.INVITATIONS.CREATE,
        {
          method: 'POST',
          body: JSON.stringify(params),
        }
      );

      // 목록에 추가
      setInvitations(prev => [data, ...prev]);
      return data;
    } catch (err: any) {
      setError(err.message);
      return null;
    } finally {
      setLoading(false);
    }
  }, [authenticatedRequest]);

  const createBulkInvitations = useCallback(async (
    params: BulkInvitationParams
  ): Promise<BulkInvitationResult | null> => {
    setLoading(true);
    setError(null);
    try {
      const data = await authenticatedRequest<BulkInvitationResult>(
        API_ENDPOINTS.INVITATIONS.BULK,
        {
          method: 'POST',
          body: JSON.stringify(params),
        }
      );

      // 전체 목록 새로고침
      await fetchInvitations(params.project_id);
      return data;
    } catch (err: any) {
      setError(err.message);
      return null;
    } finally {
      setLoading(false);
    }
  }, [authenticatedRequest, fetchInvitations]);

  const resendInvitation = useCallback(async (invitationId: string): Promise<boolean> => {
    setError(null);
    try {
      await authenticatedRequest(
        API_ENDPOINTS.INVITATIONS.RESEND(invitationId),
        { method: 'POST' }
      );

      // 로컬 상태 업데이트
      setInvitations(prev => prev.map(inv =>
        inv.id === invitationId
          ? { ...inv, reminder_count: inv.reminder_count + 1, last_reminder_at: new Date().toISOString() }
          : inv
      ));

      return true;
    } catch (err: any) {
      setError(err.message);
      return false;
    }
  }, [authenticatedRequest]);

  const revokeInvitation = useCallback(async (
    invitationId: string,
    reason?: string
  ): Promise<boolean> => {
    setError(null);
    try {
      await authenticatedRequest(
        API_ENDPOINTS.INVITATIONS.REVOKE(invitationId),
        {
          method: 'POST',
          body: JSON.stringify({ reason: reason || '' }),
        }
      );

      setInvitations(prev => prev.map(inv =>
        inv.id === invitationId ? { ...inv, status: 'revoked' as InvitationStatus } : inv
      ));

      return true;
    } catch (err: any) {
      setError(err.message);
      return false;
    }
  }, [authenticatedRequest]);

  const regenerateToken = useCallback(async (
    invitationId: string,
    expiryDays: number = 7
  ): Promise<boolean> => {
    setError(null);
    try {
      const data = await authenticatedRequest<{ expires_at: string }>(
        API_ENDPOINTS.INVITATIONS.REGENERATE(invitationId),
        {
          method: 'POST',
          body: JSON.stringify({ expiry_days: expiryDays }),
        }
      );

      setInvitations(prev => prev.map(inv =>
        inv.id === invitationId
          ? { ...inv, status: 'pending' as InvitationStatus, expires_at: data.expires_at, reminder_count: 0 }
          : inv
      ));

      return true;
    } catch (err: any) {
      setError(err.message);
      return false;
    }
  }, [authenticatedRequest]);

  // ===== 평가자 액션 (비인증) =====

  const verifyToken = useCallback(async (token: string): Promise<TokenVerificationResult> => {
    try {
      const data = await publicRequest<TokenVerificationResult>(
        API_ENDPOINTS.INVITATIONS.VERIFY_TOKEN,
        {
          method: 'POST',
          body: JSON.stringify({ token }),
        }
      );
      return data;
    } catch (err: any) {
      return { valid: false, error: err.message };
    }
  }, [publicRequest]);

  const acceptInvitation = useCallback(async (
    invitationId: string,
    token: string,
    name?: string
  ) => {
    setLoading(true);
    setError(null);
    try {
      const data = await publicRequest<{
        project_id: string;
        evaluator_id: string;
        evaluation_url: string;
      }>(
        API_ENDPOINTS.INVITATIONS.ACCEPT(invitationId),
        {
          method: 'POST',
          body: JSON.stringify({ token, evaluator_name: name }),
        }
      );
      return data;
    } catch (err: any) {
      setError(err.message);
      return null;
    } finally {
      setLoading(false);
    }
  }, [publicRequest]);

  const declineInvitation = useCallback(async (
    invitationId: string,
    token: string,
    reason?: string
  ): Promise<boolean> => {
    setError(null);
    try {
      await publicRequest(
        API_ENDPOINTS.INVITATIONS.DECLINE(invitationId),
        {
          method: 'POST',
          body: JSON.stringify({ token, reason: reason || '' }),
        }
      );
      return true;
    } catch (err: any) {
      setError(err.message);
      return false;
    }
  }, [publicRequest]);

  const clearError = useCallback(() => setError(null), []);

  return {
    invitations,
    stats,
    loading,
    error,
    fetchInvitations,
    createInvitation,
    createBulkInvitations,
    resendInvitation,
    revokeInvitation,
    regenerateToken,
    verifyToken,
    acceptInvitation,
    declineInvitation,
    clearError,
  };
}
```

### 4.3 `EvaluatorInvitationManager` 컴포넌트 (관리자용)

이 컴포넌트는 기존 `EvaluatorAssignmentDashboard`의 하위 컴포넌트로 배치된다.

```typescript
// src/components/evaluation/assignment/EvaluatorInvitationManager.tsx

import React, { useState, useEffect, useCallback } from 'react';
import {
  EnvelopeIcon,
  ArrowPathIcon,
  CheckCircleIcon,
  XCircleIcon,
  ClockIcon,
  NoSymbolIcon,
  ExclamationCircleIcon,
  PaperAirplaneIcon,
} from '@heroicons/react/24/outline';
import {
  useEvaluatorInvite,
  InvitationData,
  InvitationStatus,
  INVITATION_STATUS_MAP,
} from '../../../hooks/useEvaluatorInvite';

interface EvaluatorInvitationManagerProps {
  projectId: string;
}

const EvaluatorInvitationManager: React.FC<EvaluatorInvitationManagerProps> = ({
  projectId,
}) => {
  const {
    invitations,
    stats,
    loading,
    error,
    fetchInvitations,
    resendInvitation,
    revokeInvitation,
    regenerateToken,
    clearError,
  } = useEvaluatorInvite();

  const [statusFilter, setStatusFilter] = useState<InvitationStatus | 'all'>('all');
  const [actionLoading, setActionLoading] = useState<string | null>(null);

  useEffect(() => {
    fetchInvitations(
      projectId,
      statusFilter === 'all' ? undefined : statusFilter
    );
  }, [projectId, statusFilter, fetchInvitations]);

  const handleResend = useCallback(async (invitationId: string) => {
    setActionLoading(invitationId);
    const success = await resendInvitation(invitationId);
    setActionLoading(null);
    if (success) {
      alert('리마인더가 발송되었습니다.');
    }
  }, [resendInvitation]);

  const handleRevoke = useCallback(async (invitationId: string) => {
    if (!window.confirm('이 초대를 철회하시겠습니까?')) return;
    setActionLoading(invitationId);
    const reason = window.prompt('철회 사유를 입력하세요 (선택사항):') || '';
    await revokeInvitation(invitationId, reason);
    setActionLoading(null);
  }, [revokeInvitation]);

  const handleRegenerate = useCallback(async (invitationId: string) => {
    if (!window.confirm('새 초대 토큰을 생성하고 이메일을 발송하시겠습니까?')) return;
    setActionLoading(invitationId);
    await regenerateToken(invitationId, 7);
    setActionLoading(null);
  }, [regenerateToken]);

  const getStatusIcon = (status: InvitationStatus) => {
    const iconMap: Record<string, React.ReactElement> = {
      pending: <ClockIcon className="h-5 w-5 text-yellow-600" />,
      accepted: <CheckCircleIcon className="h-5 w-5 text-green-600" />,
      declined: <XCircleIcon className="h-5 w-5 text-red-600" />,
      expired: <ExclamationCircleIcon className="h-5 w-5 text-gray-500" />,
      revoked: <NoSymbolIcon className="h-5 w-5 text-orange-600" />,
    };
    return iconMap[status] || null;
  };

  const renderActions = (invitation: InvitationData) => {
    const isActionLoading = actionLoading === invitation.id;
    const config = INVITATION_STATUS_MAP[invitation.status];
    if (!config) return null;

    return (
      <div className="flex gap-2">
        {config.actions.includes('resend') && (
          <button
            onClick={() => handleResend(invitation.id)}
            disabled={isActionLoading}
            className="text-xs px-3 py-1 bg-blue-50 text-blue-700 rounded-lg
                       hover:bg-blue-100 transition-colors disabled:opacity-50"
            title={`재발송 (${invitation.reminder_count}/3)`}
          >
            <PaperAirplaneIcon className="h-4 w-4 inline mr-1" />
            재발송
          </button>
        )}
        {config.actions.includes('revoke') && (
          <button
            onClick={() => handleRevoke(invitation.id)}
            disabled={isActionLoading}
            className="text-xs px-3 py-1 bg-red-50 text-red-700 rounded-lg
                       hover:bg-red-100 transition-colors disabled:opacity-50"
          >
            철회
          </button>
        )}
        {config.actions.includes('regenerate') && (
          <button
            onClick={() => handleRegenerate(invitation.id)}
            disabled={isActionLoading}
            className="text-xs px-3 py-1 bg-green-50 text-green-700 rounded-lg
                       hover:bg-green-100 transition-colors disabled:opacity-50"
          >
            <ArrowPathIcon className="h-4 w-4 inline mr-1" />
            토큰 재생성
          </button>
        )}
      </div>
    );
  };

  return (
    <div className="bg-white rounded-2xl shadow-card p-6">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-xl font-bold">초대 관리</h2>
        <button
          onClick={() => fetchInvitations(projectId, statusFilter === 'all' ? undefined : statusFilter)}
          className="btn btn-ghost text-sm"
        >
          <ArrowPathIcon className="h-4 w-4 mr-1" />
          새로고침
        </button>
      </div>

      {/* 통계 카드 */}
      {stats && (
        <div className="grid grid-cols-2 md:grid-cols-5 gap-3 mb-6">
          {(['pending', 'accepted', 'declined', 'expired', 'revoked'] as const).map((s) => {
            const cfg = INVITATION_STATUS_MAP[s];
            return (
              <button
                key={s}
                onClick={() => setStatusFilter(statusFilter === s ? 'all' : s)}
                className={`p-3 rounded-lg text-center transition-all border-2 ${
                  statusFilter === s ? 'border-blue-500 shadow-md' : 'border-transparent'
                } ${cfg.bgColor}`}
              >
                <div className={`text-2xl font-bold ${cfg.color}`}>
                  {stats[s]}
                </div>
                <div className="text-xs text-gray-600 mt-1">{cfg.label}</div>
              </button>
            );
          })}
        </div>
      )}

      {/* 에러 표시 */}
      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-3 mb-4">
          <p className="text-sm text-red-700">{error}</p>
          <button onClick={clearError} className="text-xs text-red-500 underline mt-1">
            닫기
          </button>
        </div>
      )}

      {/* 초대 목록 테이블 */}
      {loading ? (
        <div className="flex justify-center py-12">
          <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-500" />
        </div>
      ) : invitations.length === 0 ? (
        <div className="text-center py-12 text-gray-500">
          <EnvelopeIcon className="h-12 w-12 mx-auto mb-3 text-gray-300" />
          <p>초대 기록이 없습니다.</p>
        </div>
      ) : (
        <div className="overflow-x-auto">
          <table className="w-full text-sm">
            <thead>
              <tr className="text-left text-gray-500 border-b">
                <th className="pb-3 font-medium">이메일</th>
                <th className="pb-3 font-medium">이름</th>
                <th className="pb-3 font-medium">상태</th>
                <th className="pb-3 font-medium">만료일</th>
                <th className="pb-3 font-medium">재발송</th>
                <th className="pb-3 font-medium">액션</th>
              </tr>
            </thead>
            <tbody>
              {invitations.map((inv) => {
                const cfg = INVITATION_STATUS_MAP[inv.status];
                return (
                  <tr key={inv.id} className="border-b border-gray-100 hover:bg-gray-50">
                    <td className="py-3">{inv.invitee_email}</td>
                    <td className="py-3 text-gray-600">{inv.invitee_name || '-'}</td>
                    <td className="py-3">
                      <span className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs ${cfg?.bgColor} ${cfg?.color}`}>
                        {getStatusIcon(inv.status)}
                        {cfg?.label}
                      </span>
                    </td>
                    <td className="py-3 text-gray-600">
                      {new Date(inv.expires_at).toLocaleDateString('ko-KR')}
                    </td>
                    <td className="py-3 text-gray-600">
                      {inv.reminder_count}/3
                    </td>
                    <td className="py-3">
                      {renderActions(inv)}
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
};

export default EvaluatorInvitationManager;
```

### 4.4 URL 파라미터 처리 방식

GitHub Pages는 HashRouter를 사용하므로, 초대 URL은 다음 형태를 따른다:

```
https://aebonlee.github.io/ahp_app/#/invitation?token=eyJhbGciOiJIUzI1NiIs...
```

**AppRouter.tsx에서의 라우팅 처리** (기존 `invitation-handler` case를 수정):

```typescript
// src/router/AppRouter.tsx - 기존 case 'invitation-handler' 수정

case 'invitation-handler': {
  const urlParams = new URLSearchParams(window.location.search);
  const hashParams = new URLSearchParams(window.location.hash.split('?')[1] || '');
  const token = urlParams.get('token') || hashParams.get('token');

  return (
    <EvaluatorInvitationHandler
      token={token}
      onAccept={() => changeTab('evaluator-workflow')}
    />
  );
}
```

**App.tsx에서 토큰 자동 감지** (기존 useEffect에 추가):

```typescript
// src/App.tsx - 초대 토큰 자동 감지 로직 추가

useEffect(() => {
  // 기존 eval/project 파라미터 처리...

  // 초대 토큰 감지 (Hash 라우팅 대응)
  const hash = window.location.hash;
  if (hash.includes('/invitation') || hash.includes('token=')) {
    const hashSearch = hash.split('?')[1] || '';
    const hashParams = new URLSearchParams(hashSearch);
    const invitationToken = hashParams.get('token');

    if (invitationToken) {
      console.log('Invitation token detected, activating invitation handler');
      setActiveTab('invitation-handler');
    }
  }
}, []);
```

### 4.5 기존 InviteEvaluators 컴포넌트 연동

기존 `InviteEvaluators.tsx`의 `handleSubmit`을 `useEvaluatorInvite` Hook으로 교체한다.

```typescript
// src/components/evaluation/assignment/InviteEvaluators.tsx 수정 포인트

// 기존:
// import api from '../../../services/api';

// 변경:
import { useEvaluatorInvite } from '../../../hooks/useEvaluatorInvite';

// 컴포넌트 내부에서:
const { createBulkInvitations, loading: inviteLoading, error: inviteError } = useEvaluatorInvite();

const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  if (!validateEmails()) return;

  const emailList = inputMode === 'bulk'
    ? bulkEmail.split(/[\n,;]+/).map(e => e.trim()).filter(e => e)
    : emails.filter(e => e);

  const result = await createBulkInvitations({
    project_id: String(projectId),
    evaluator_emails: emailList,
    custom_message: message,
    expiry_days: expiryDays,
  });

  if (result) {
    const msg = [
      `${result.invitations_created}명에게 초대를 발송했습니다.`,
      result.duplicates_skipped > 0 ? `(${result.duplicates_skipped}명 중복 제외)` : '',
      result.errors.length > 0 ? `\n실패: ${result.errors.map(e => e.email).join(', ')}` : '',
    ].filter(Boolean).join(' ');

    alert(msg);
    setEmails(['']);
    setBulkEmail('');
    setMessage('');
    onSuccess();
  }
};
```

---

## 5. 보안 고려사항

### 5.1 토큰 탈취 방지

| 위협 | 대응 방안 | 구현 위치 |
|------|-----------|-----------|
| URL 로그 노출 | 토큰을 URL fragment(`#`)가 아닌 query parameter로 전달. 서버 로그에 기록되지 않도록 POST로 토큰 검증 | `verify_token` API |
| 이메일 가로채기 | HTTPS 강제. 토큰 1회성 사용 (수락 시 상태 변경). 만료 시간 설정 | `EvaluationInvitation.can_accept()` |
| 브루트포스 | `secrets.token_urlsafe(32)` = 256비트 엔트로피. DB에는 SHA-256 해시만 저장 | `InvitationTokenService` |
| 재사용 공격 | 수락/거절 후 `status` 변경으로 토큰 무효화. DB 상태와 JWT 이중 검증 | `validate_invitation_token()` |
| XSS 토큰 탈취 | 토큰은 `sessionStorage`에 저장 (평가 세션 동안만). `localStorage` 사용 금지 | 프론트엔드 |
| CSRF | Django의 CSRF 미들웨어 + REST framework의 `SessionAuthentication` 비활성화 (JWT만 사용) | Django settings |

**Rate Limiting** (추가 권장):

```python
# backend/invitations/throttles.py

from rest_framework.throttling import AnonRateThrottle, UserRateThrottle

class InvitationVerifyThrottle(AnonRateThrottle):
    """토큰 검증 요청 제한 (비인증 엔드포인트)"""
    rate = '20/hour'  # IP당 시간당 20회

class InvitationCreateThrottle(UserRateThrottle):
    """초대 생성 요청 제한"""
    rate = '50/hour'  # 사용자당 시간당 50회

class InvitationResendThrottle(UserRateThrottle):
    """리마인더 발송 제한"""
    rate = '10/hour'
```

```python
# ViewSet에 적용
class InvitationViewSet(viewsets.ModelViewSet):
    # ...

    def get_throttles(self):
        if self.action == 'verify_token':
            return [InvitationVerifyThrottle()]
        elif self.action == 'create':
            return [InvitationCreateThrottle()]
        elif self.action == 'resend':
            return [InvitationResendThrottle()]
        return super().get_throttles()
```

### 5.2 중복 초대 방지

기존 모델의 `UniqueConstraint`가 이미 이를 처리한다:

```python
# backend/invitations/models.py (기존)
class Meta:
    constraints = [
        models.UniqueConstraint(
            fields=['project', 'invitee_email'],
            condition=models.Q(status='pending'),
            name='unique_pending_invitation_per_project'
        )
    ]
```

이 제약조건은 동일 프로젝트에 대해 **동일 이메일로 pending 상태의 초대가 2개 이상 존재할 수 없도록** 보장한다. 이전 초대가 `expired`, `declined`, `revoked` 상태가 된 후에는 같은 이메일로 새 초대를 보낼 수 있다.

**프론트엔드 레벨 중복 방지**: 대량 초대 시 이메일 목록을 `Set`으로 중복 제거한 뒤 API에 전송한다.

```typescript
// InviteEvaluators.tsx 내부
const emailList = [...new Set(
  rawEmails.map(e => e.trim().toLowerCase()).filter(e => e)
)];
```

### 5.3 권한 검증 (초대받은 프로젝트만 접근 가능)

```python
# backend/invitations/permissions.py

from rest_framework.permissions import BasePermission
from .models import ParticipantPermission, EvaluationInvitation


class HasProjectAccess(BasePermission):
    """
    초대를 수락한 평가자 또는 프로젝트 소유자/관리자만
    해당 프로젝트의 평가 데이터에 접근 가능.
    """

    def has_permission(self, request, view):
        project_id = (
            view.kwargs.get('project_id') or
            request.query_params.get('project_id') or
            request.data.get('project_id')
        )

        if not project_id:
            return True  # project_id가 없는 엔드포인트는 다른 permission에서 처리

        user = request.user

        if not user.is_authenticated:
            # 비인증 사용자: 초대 토큰 기반 접근 확인
            token = (
                request.META.get('HTTP_X_INVITATION_TOKEN') or
                request.query_params.get('invitation_token')
            )
            if not token:
                return False

            try:
                from .token_service import InvitationTokenService
                payload = InvitationTokenService.verify_token(token)
                return str(payload.get('pid')) == str(project_id)
            except Exception:
                return False

        # 인증된 사용자: 역할 확인
        if user.role in ('super_admin', 'service_admin'):
            return True

        # ParticipantPermission 테이블에서 권한 확인
        has_permission = ParticipantPermission.objects.filter(
            user=user,
            project_id=project_id,
        ).exists()

        if has_permission:
            return True

        # 프로젝트 소유자 확인
        from projects.models import Project
        return Project.objects.filter(id=project_id, owner=user).exists()
```

**프론트엔드 권한 가드** (기존 AppRouter의 evaluator-workflow case에 추가):

```typescript
// AppRouter.tsx 수정 - evaluator-workflow에 권한 확인 추가

case 'evaluator-workflow': {
  const urlParams = new URLSearchParams(window.location.search);
  const projectId = urlParams.get('eval') || urlParams.get('project');
  const evaluatorToken = urlParams.get('token') || urlParams.get('key');

  // 초대 토큰이 있는 경우 sessionStorage에 저장
  if (evaluatorToken && projectId) {
    const existingSession = sessionStorage.getItem('evaluator_session');
    if (!existingSession) {
      sessionStorage.setItem('evaluator_session', JSON.stringify({
        projectId,
        token: evaluatorToken,
        accessedAt: new Date().toISOString(),
      }));
    }
  }

  // 권한 확인: 토큰 또는 인증된 사용자
  if (!evaluatorToken && !user) {
    return (
      <div className="text-center py-12">
        <p className="text-red-600">접근 권한이 없습니다. 초대 링크를 확인하세요.</p>
      </div>
    );
  }

  return (
    <EvaluatorWorkflow
      projectId={projectId || ''}
      evaluatorToken={evaluatorToken || undefined}
    />
  );
}
```

---

## 6. 구현 우선순위 및 일정 제안

| 순서 | 작업 | 담당 | 예상 소요 | 의존성 |
|------|------|------|-----------|--------|
| 1 | Django `InvitationTokenService` 구현 | Backend | 2시간 | 없음 |
| 2 | Django `InvitationViewSet` 구현 (CRUD + verify) | Backend | 4시간 | #1 |
| 3 | Django `InvitationEmailService` 구현 (SendGrid) | Backend | 3시간 | #2 |
| 4 | `useEvaluatorInvite` Hook 구현 | Frontend | 2시간 | #2 API 스펙 확정 |
| 5 | `EvaluatorInvitationManager` 컴포넌트 | Frontend | 3시간 | #4 |
| 6 | 기존 `InviteEvaluators` 컴포넌트 Hook 연동 | Frontend | 1시간 | #4 |
| 7 | `EvaluatorInvitationHandler` 컴포넌트 리팩토링 | Frontend | 2시간 | #4 |
| 8 | `HasProjectAccess` 권한 미들웨어 | Backend | 2시간 | #2 |
| 9 | Rate Limiting 및 보안 강화 | Backend | 1시간 | #2 |
| 10 | 통합 테스트 | Both | 3시간 | 전체 |

**총 예상 소요**: 약 23시간 (백엔드 12시간, 프론트엔드 8시간, 통합 3시간)

---

## 7. 환경 변수 요약

### Render.com 환경 변수 (백엔드)

```
INVITATION_TOKEN_SECRET=<random-64-char-string>
SENDGRID_API_KEY=<sendgrid-api-key>
FRONTEND_BASE_URL=https://aebonlee.github.io/ahp_app
DEFAULT_FROM_EMAIL=AHP Platform <noreply@ahp-platform.com>
```

### GitHub Pages 환경 변수 (프론트엔드)

```
REACT_APP_API_URL=https://ahp-django-backend.onrender.com
```

(이미 `.env.production`에 설정되어 있으므로 추가 변경 불필요)

---

## 8. 테스트 체크리스트

### 백엔드 테스트

- [ ] 토큰 생성 후 검증 성공
- [ ] 만료된 토큰 검증 시 410 반환
- [ ] 이미 수락된 토큰 재사용 시 409 반환
- [ ] 중복 pending 초대 생성 시 409 반환
- [ ] 리마인더 쿨다운 (24시간 미만 시 429 반환)
- [ ] 리마인더 최대 3회 초과 시 429 반환
- [ ] 철회된 초대 수락 시 409 반환
- [ ] 대량 초대 시 중복 이메일 자동 건너뛰기
- [ ] 이메일 발송 실패 시 error 기록 (초대 자체는 생성)
- [ ] `expire_stale_invitations` 관리 명령어 동작 확인

### 프론트엔드 테스트

- [ ] 초대 링크 클릭 시 `invitation-handler` 탭 활성화
- [ ] 유효한 토큰으로 수락 후 `evaluator-workflow` 전환
- [ ] 만료 토큰 시 적절한 에러 메시지 표시
- [ ] 관리자 대시보드에서 초대 목록 조회/필터링
- [ ] 리마인더 버튼 클릭 후 카운트 증가
- [ ] 철회 버튼 클릭 후 상태 변경
- [ ] 토큰 재생성 후 상태 `pending`으로 복귀
- [ ] 대량 초대 발송 후 결과 요약 표시
- [ ] 비인증 평가자의 프로젝트 접근 권한 제한

---

*문서 끝. 이 설계를 기반으로 Sonnet이 백엔드를, Opus가 프론트엔드를 구현할 수 있다.*
